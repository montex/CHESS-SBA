-- @path IM=/org.chess.statebased/metamodels/IM2.ecore
-- @path CHESS=/org.polarsys.chess.chessmlprofile/model/chessmlprofile.ecore
-- @nsURI MARTE=http://www.eclipse.org/papyrus/MARTE/1
-- @nsURI UML=http://www.eclipse.org/uml2/4.0.0/UML
-- @nsURI CHESS=http://CHESS
-- @nsURI SYSML=http://www.eclipse.org/papyrus/0.7.0/SysML

module CHESS2IM;
create OUT : IM from IN1 : CHESS, IN2 : MARTE, IN3 : UML, IN4 : SYSML;

helper def: umlInstancesAll : Sequence(UML!InstanceSpecification) = Sequence{}; 	--All the InstanceSpecification of the considered platform
helper def: umlInstancesConnectors : Set(UML!InstanceSpecification) = Set{};		--Instances of connectors
helper def: umlInstancesBlocks : Set(UML!InstanceSpecification) = Set{}; 			--Instances of components/blocks
helper def: umlInstancesStereo : Set(UML!InstanceSpecification) = Set{}; 			--Instances that have dependability information
helper def: umlInstancesRelevant : Set(UML!InstanceSpecification) = Set{}; 			--Instances that are relevant for the analysis
helper def: umlAllocations : Set(MARTE!Assign) = Set{};

--Stereotypes that can be used on Blocks/Components for state based analysis
helper def: sbaStereotypes : Sequence(OclAny) = Sequence{CHESS!SimpleStochasticBehavior, CHESS!FLABehavior, CHESS!ErrorModelBehavior, CHESS!DependableComponent,
														 CHESS!StatelessSoftware, CHESS!StatefulSoftware, CHESS!StatelessHardware, CHESS!StatefulHardware};
--Stereotypes that can be used on Transitions of an Error Model
helper def: sbaTransitions : Sequence(OclAny) = Sequence{CHESS!Failure, CHESS!InternalPropagation, CHESS!InternalFault};														 
helper def: flaNoFailure : String = 'noFailure';
helper def: flaWildcard : String = 'wildcard';
													 
helper def: flaRules : Map(IM!Component, Map(String, IM!Error)) = Map{};			--Map to obtain the list of flarules for a component, and the corresponding IM!Error elements

--rule to transform the CHESS!StateBasedAnalysis into an IM!Sistema
rule System {

	from
		sba : CHESS!StateBasedAnalysis
		--at the moment is it implied that there is only a StateBasedAnalysis in the model
	using {
		platform : UML!Package = sba.platform->first().base_Package;
		instances : Sequence(UML!InstanceSpecification) = UML!InstanceSpecification.allInstances()->select(i | i.refImmediateComposite() = platform);
		comments : Sequence(UML!Comment) = instances->collect(i | i.ownedComment)->flatten();
		instSystem : UML!InstanceSpecification = instances->first();
	} 
	to
		s : IM!Sistema (
			Name <- sba.base_StructuredClassifier.name
		)
	do {
		--Filter out and categorize relevant CHESS elements
		thisModule.umlInstancesAll <- instances;
		thisModule.umlInstancesConnectors <- instances->select(i | i.classifier.isEmpty());
		thisModule.umlInstancesBlocks <- instances->select(i | not i.classifier.isEmpty());
		thisModule.umlAllocations <- MARTE!Assign.allInstances()->select(a | comments.includes(a.base_Comment));
		
		thisModule.umlInstancesBlocks <- thisModule.umlInstancesAll->select(i | thisModule.umlInstancesConnectors.excludes(i));
		thisModule.umlInstancesStereo <- thisModule.umlInstancesBlocks->select(i | i.getSBAStereotype() <> OclUndefined);

		thisModule.umlInstancesRelevant <- instSystem.findSBAConstituents();
		
		
		--thisModule.umlInstancesStereo <- thisModule.umlInstancesBlocks;

--		for(i in thisModule.umlInstancesStereo) {
--			i.debug('i->');
--			i.getSBAStereotype().toString().debug('stereotype: ');
--			i.slot->collect(sl | sl.definingFeature.name).debug('slots: ');
--			i.getSubInstances().debug('sub instances');
--
--			i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))->collect(s | s.hasInputFlow()).debug('is input: ');
--			i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))->collect(s | s.hasOutputFlow()).debug('is output: ');	
--			
--			for(p in i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))) {
--				p.definingFeature.name.debug('>>');
--				p.hasInputFlow().debug('input? ');
--				p.hasOutputFlow().debug('output? ');
--				
--				thisModule.umlInstancesConnectors.debug();
--				thisModule.umlInstancesConnectors->collect(c | c.slot).debug();
--				
--				p.getConnectors().debug('getConnectors');
--				p.getConnectors()->collect(c | c.isConnection()).debug('isConnection');
--				p.getConnectors()->collect(c | c.isDelegation()).debug('isDelegation');
--				p.getConnectedImmediate()->collect(i|i.definingFeature.name).debug('getConnectedImmediate');
--				p.getDelegationEnds()->collect(i|i.definingFeature.name).debug('getDelegationEnds');
--				p.getDelegationEndsDownwards()->collect(i|i.definingFeature.name).debug('getDelegationEndsDownwards');
--				p.getDelegationEndsUpwards()->collect(i|i.definingFeature.name).debug('getDelegationEndsUpwards');
--				p.getSBADelegations()->collect(i|i.definingFeature.name).debug('getSBADelegations');
--				p.getSBAConnections()->collect(i|i.definingFeature.name).debug('getSBAConnections');
--				thisModule.umlInstancesConnectors->select(c | not c.slot->select(s | s.definingFeature = p.definingFeature and s.value->first().instance = i)->isEmpty())();
--				thisModule.umlInstancesConnectors->collect(c | c.slot->collect(s | s.value->first().instance))('conns');
--				
--			}
--			thisModule('------------------------');
--		}
--		thisModule.umlInstancesStereo();
--		UML!InstanceSpecification.allInstances()->collect(i | i.getSimpleStochasticBehavior()('##'));
----		
----		
----		UML!InstanceSpecification.allInstances()->collect(i | CHESS!SimpleStochasticBehavior.allInstances()->exists(ssb | ssb.base_Class = i.getBaseItem())());
----	
----		thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten();
--
----helper context UML!Port def: isInputPort : Boolean =
----MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first().kind 
--
--		MARTE!ClientServerPort.allInstances()->collect(p | p.kind)();
--		SYSML!FlowPort.allInstances()->collect(p | p.hasInputFlow())();
--		UML!Port.allInstances()->collect(p | p.hasInputFlow())();

		--DEBUG: Print the obtained sets
		thisModule.umlInstancesAll.debug('Instances ['+ thisModule.umlInstancesAll.size() +']');
		thisModule.umlInstancesConnectors.debug('Connectors ['+ thisModule.umlInstancesConnectors.size() +']');
		thisModule.umlInstancesBlocks.debug('Blocks ['+ thisModule.umlInstancesBlocks.size() +']');	
		thisModule.umlInstancesStereo.debug('Stereotypes [' + thisModule.umlInstancesStereo.size() + ']');
		thisModule.umlInstancesRelevant.debug('Relevant [' + thisModule.umlInstancesRelevant.size() + ']');
		thisModule.umlAllocations.debug('Allocations ['+ thisModule.umlAllocations.size() +']');
		--/DEBUG
		
		--Generate IM!Component elements, failure modes, and what can be done immediately
		for(i in thisModule.umlInstancesRelevant) {
			s.components <- s.components.append(
				thisModule.InstanceToComponent(i)
			);
			
			if(i.getSBAStereotype().oclType() = CHESS!SimpleStochasticBehavior) {
				thisModule.SimpleStochasticBehaviorToComponent(i);
			}else if(i.getSBAStereotype().oclType() = CHESS!FLABehavior){
				thisModule.FLASpecificationToComponent(i);
			}else if(i.getSBAStereotype().oclType() = CHESS!ErrorModelBehavior) {
				thisModule.ErrorModelToComponent(i);
			}
		}
		
		--Generate external faults
		for(i in thisModule.umlInstancesRelevant) {
			thisModule.PopulateExternalFaults(i);	
		}
		
		--Generate FGE, i.e., connect external faults
		for(i in thisModule.umlInstancesRelevant) {
			if(i.getSBAStereotype().oclType() = CHESS!SimpleStochasticBehavior) {
				thisModule.SimpleStochasticBehavior_FGE(i);
			}else if(i.getSBAStereotype().oclType() = CHESS!FLABehavior){
				thisModule.FLASpecification_FGE(i);
			}else if(i.getSBAStereotype().oclType() = CHESS!ErrorModelBehavior) {
				thisModule.ErrorModel_FGE(i);
			}
		}
		--Set FGE Backlinks
		for(fge in IM!FaultsGenerateErrors.allInstances()) {
			thisModule.setFGEBackLinks(fge.PropagationLogic, fge);	
		}
		
		--Handle metrics
		if (sba.WhichMeasure = 'Reliability'){
			thisModule.Reliability(sba, sba.measure.getTime);
		}else if (sba.WhichMeasure = 'Availability'){
			thisModule.Availability(sba, sba.measure.getTime);
		}else{
			---TODO: others?
		}
	}
}

unique lazy rule InstanceToComponent {
	from
		inst : UML!InstanceSpecification
	to 
		c : IM!Component (
			Name <- inst.name
		)
}

--------------------------------------------------------------------
-- Rules to project component instances to IM!Component elements
--------------------------------------------------------------------

rule SimpleStochasticBehaviorToComponent(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!SimpleStochasticBehavior = inst.getSBAStereotype();
		tmpFailures : Set(TupleType(fm : String, p : Real)) = OclUndefined;
		tmpError : IM!Error = OclUndefined;
		tmpFailureMode : IM!FailureMode = OclUndefined;
		myFailureModes : String = if st.failureModesDistribution.oclIsUndefined() then '' else st.failureModesDistribution endif;
	}
	to
		fault : IM!InternalFault (
			Component <- c,
			Name <- inst.name + '_ift',
			PermanentProbability <- 1,
			Occurrence <- st.failureOccurrence.parseDistribution(),
			TransientDuration <- thisModule.Deterministic(0)
		)
	do {
		c.Faults = c.Faults.including(fault);
		
		for(slot in inst.getPortSlots()->select(p | p.hasOutputFlow())) {
			tmpFailures <- myFailureModes.parseFailureModesForPort(slot.name);
				
			tmpError <- thisModule.AddError('e_' + slot.name, c);
			for(fmSpec in tmpFailures) {
				thisModule.AddEPF(
					tmpError,
					thisModule.AddFailureMode(slot.name + '.' + fmSpec.fm, c),
					thisModule.Deterministic(0),
					1,
					fmSpec.p
				);
			}
		}
	}
}

rule FLASpecificationToComponent(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!FLABehavior = inst.getSBAStereotype();
		flaRules : Sequence(String) = st.fptc.regexReplaceAll('FLA:', ' ').trim().split(';');
		tmpLeft : String = OclUndefined;
		tmpRight : String = OclUndefined;
		tmpFailures : Sequence(String) = OclUndefined;
		errorMap : Map(String,IM!Error) = Map{};
		tmpError : IM!Error = OclUndefined;
		tmpEPF : IM!ErrorsProducesFailures = OclUndefined;
		j : Integer = 0;
	}
	
	do {
		--For every line of the FLA specification
		for(spec in flaRules) {
			j <- j+1;
			tmpError <- thisModule.AddError('e_'+j,c);
			tmpEPF <- thisModule.AddFLARuleEPF(tmpError);
			
			tmpRight <- spec.trim().split('->')->last().trim();			--Get right hand side
			tmpFailures <- tmpRight.split(',');							--Get the different failures in the right hand side
			
			--For every failure in the right side of the rule
			for(failure in tmpFailures) {
				--If it is not the 'noFailure' element
				if(failure.indexOf('.' + thisModule.flaNoFailure) = -1) {
					--If the failure mode does not exist already
					if(not c.hasFailureMode(failure)) {
						thisModule.AddFailureMode(failure, c);
					}
					
					tmpEPF.Destination <- tmpEPF.Destination->including(c.FailureModes->select(f | f.Name = failure)->first());
				}
			}
		}
	}		
}

rule ErrorModelToComponent(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!ErrorModelBehavior = inst.getSBAStereotype();
		errorModel : CHESS!ErrorModel = st.errorModel->first();
		states : Sequence(UML!State) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(UML!State));
		pseudo : Sequence(CHESS!Pseudostate) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(CHESS!Pseudostate));
		transitions : Sequence(UML!Transition) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(UML!Transition));
		tmpStereotype : OclAny = OclUndefined;
		tmpExternalFaults : String = OclUndefined;
	}
	do {	
		--Scan all CHESS!Failure elements in the error model,
		--to create the needed IM!FailureMode elements
		for(tr in transitions) {
			tmpStereotype <- tr.getFailureStereotype();
			if(not tmpStereotype.oclIsUndefined()) {
				for(f in tmpStereotype.mode) {
					--If it is not the 'noFailure' element
					if(f.indexOf('.' + thisModule.flaNoFailure) = -1) {
						--If the failure mode does not exist already
						if(not c.hasFailureMode(f)) {
							thisModule.AddFailureMode(f, c);
						}
					}
				}
			}
		}
		
		--Transform ErrorModel States
		for(s in states) {
			thisModule.ErrorModelStateToError(s,inst);
		}
		
		--Transform ErrorModel Pseudostates (choice)
		for(s in pseudo->select(p | p.kind = #choice)) {
			thisModule.ErrorModelStateToError(s,inst);
		}
		
		--Transform ErrorModel <<Failure>> Transitions
		for(tr in transitions) {
			tmpStereotype <- tr.getSBAStereotype();
			if(tmpStereotype.oclIsTypeOf(CHESS!Failure)) {		
				thisModule.AddEPFFromErrorModelFailure(tmpStereotype);
			}
		}
				
		--<<InternalFault>> become IM!InternalFault
		for(tr in transitions) {
			tmpStereotype <- tr.getSBAStereotype();
			if(tmpStereotype.oclIsTypeOf(CHESS!InternalFault)) {
				thisModule.InternalFault(tmpStereotype,inst);
			}
		}
		
		--Transform ErrorModel <<InternalPropagation>> Transitions,
		--but only those for which the 'externalFaults' attribute is empty.
		--(for the others all the external faults need to be in place)
		for(tr in transitions) {
			tmpStereotype <- tr.getSBAStereotype();
			if(tmpStereotype.oclIsTypeOf(CHESS!InternalPropagation)) {
				if(tmpStereotype.oclIsTypeOf(CHESS!InternalFault)) {
					--Do nothing (processed elsewhere)				
				}else{
					--Match <<InternalPropagation>> stereotype only
					tmpExternalFaults <- tmpStereotype.externalFaults;
					if(tmpExternalFaults.oclIsUndefined()) {
						thisModule.InternalPropagation(tmpStereotype,inst);
					}
				}
			}
		}
	}
}

--------------------------------------------------------------------
-- Rule to generate external faults for component instances
--------------------------------------------------------------------

rule PopulateExternalFaults(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		inPorts : Set(UML!Slot) = inst.getPortSlots()->select(p | p.hasInputFlow());
		faultName : String = OclUndefined;
		connPort : UML!Slot = OclUndefined;
		connComp : IM!Component = OclUndefined;
		tmpExternalFault : IM!ExternalFault = OclUndefined;
	}	
	do {
		for(p in inPorts) {
			--Find connected port
			connPort <- p.getSBAConnections()->first();
			--Find connected component (slot owner)
			connComp <- thisModule.InstanceToComponent(connPort.refImmediateComposite());
			
			for(f in connComp.FailureModes->select(fm | fm.Name.noNamespace(connComp.Name).startsWith(connPort.name + '.'))) {
				faultName <- f.Name.split('\\.')->last();
				--If the external faults has not already been added then add it
				if(c.Faults->select(ft | ft.Name = connComp.Name + '_' + f)->isEmpty()) {				
					tmpExternalFault <- thisModule.AddExternalFault(p.name + '.' + faultName, inst);
					tmpExternalFault.Source <- f;
				}
			}
		}
	}
}

--------------------------------------------------------------------
-- Rule to generate FGE elements
--------------------------------------------------------------------
rule SimpleStochasticBehavior_FGE(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		fge : IM!FaultsGenerateErrors = OclUndefined;
		externals : Sequence(IM!Fault) = c.Faults->select(ft | ft.oclIsTypeOf(IM!ExternalFault));
	}
	do {
		if(externals->size() > 0) {
			fge <- thisModule.AddFGE(externals, c.Errors, 'det(0)'.parseDistribution(), 1, 1);
			fge.PropagationLogic <- thisModule.FEXP_MultiOr(
				externals->collect(f | thisModule.FEXP_Fault(f))
			);
			fge.PropagationLogicStringFormat <- fge.PropagationLogic.toString();
		}
	}
}

rule FLASpecification_FGE(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!FLABehavior = inst.getSBAStereotype();
		flaRules : Sequence(String) = st.fptc.regexReplaceAll('FLA:', ' ').trim().split(';');
		tmpLeft : String = OclUndefined;
		tmpRight : String = OclUndefined;
		tmpFaults : Sequence(String) = OclUndefined;
		tmpError : IM!Error = OclUndefined;
		fExpression : IM!FaultsExpressionNode = OclUndefined;
		fSources : Set(IM!Fault) = Set{};
		selFaults : Sequence(String) = OclUndefined;
		tmpExpressions : Sequence(IM!FaultsExpressionNode) = Sequence{};
		j : Integer = 0;
		faultPort : String = OclUndefined;
		faultMode : String = OclUndefined;
		tmpFGE : IM!FaultsGenerateErrors = OclUndefined;
	}
	
	do {
		--For every line of the FLA specification
		for(spec in flaRules) {
			j <- j+1;
			tmpError <- c.Errors->select(e | e.Name = 'e_'+j);
			
			tmpLeft <- spec.trim().split('->')->first().trim();			--Get right hand side
			tmpFaults <- tmpLeft.split(',');							--Get the different failures in the right hand side
			
			--For every fault in the left side of the rule
			tmpExpressions <- Sequence{};
			for(fault in tmpFaults) {
				faultPort <- fault.split('\\.')->first();
				faultMode <- fault.split('\\.')->last();
								
				if(faultMode = thisModule.flaNoFailure) {
					selFaults <- c.Faults->select(ft | ft.Name.noNamespace(c.Name).startsWith(faultPort + '.'));
					fExpression <- thisModule.FEXP_MultiOr(
						selFaults->collect(f | thisModule.FEXP_Fault(f))
					);
					fExpression <- thisModule.FEXP_Not(fExpression);
				}else if(faultMode = thisModule.flaWildcard) {
					selFaults <- c.Faults->select(ft | ft.Name.noNamespace(c.Name).startsWith(faultPort + '.')); 
					fExpression <- thisModule.FEXP_MultiOr(
						selFaults->collect(f | thisModule.FEXP_Fault(f))
					);
				}else{
					selFaults <- c.Faults->select(ft | ft.Name.noNamespace(c.Name) = fault);
					fExpression <- thisModule.FEXP_Fault(
						selFaults->first()
					);
				}
				tmpExpressions <- tmpExpressions->append(fExpression);
			}
			fExpression <- thisModule.FEXP_MultiAnd(tmpExpressions);
			
			tmpFGE <- thisModule.AddFGE(selFaults, Set{tmpError}, 'det(0)'.parseDistribution(), 1, 1);
			fExpression.faultsGenerateErrors <- tmpFGE;
			tmpFGE.PropagationLogic <- fExpression;
			tmpFGE.PropagationLogicStringFormat <- fExpression.toString();
		}
	}		
}

rule ErrorModel_FGE(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!ErrorModelBehavior = inst.getSBAStereotype();
		errorModel : CHESS!ErrorModel = st.errorModel->first();
		states : Sequence(UML!State) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(UML!State));
		pseudo : Sequence(CHESS!Pseudostate) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(CHESS!Pseudostate));
		transitions : Sequence(UML!Transition) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(UML!Transition));
		tmpStereotype : OclAny = OclUndefined;
		tmpExternalFaults : String = OclUndefined;
		tmpFGE : IM!FaultsGenerateErrors = OclUndefined;
		tmpExpression : IM!FaultsExpressionNode = OclUndefined;
	}
	do {
		--Transform ErrorModel <<InternalPropagation>> Transitions,
		--for which the 'externalFaults' attribute is *not* empty.
		--(the others have been processed previously in rule ErrorModelToComponent)
		for(tr in transitions) {
			tmpStereotype <- tr.getSBAStereotype();
			if(tmpStereotype.oclIsTypeOf(CHESS!InternalPropagation)) {
				if(tmpStereotype.oclIsTypeOf(CHESS!InternalFault)) {
					--Do nothing (processed elsewhere)				
				}else{
					--Match <<InternalPropagation>> stereotype only
					
					--Set a default for the delay and weight
					if(tmpStereotype.delay.oclIsUndefined()) {
						tmpStereotype.delay <- 'det(0)';	
					}
					if(tmpStereotype.weight.oclIsUndefined()) {
						tmpStereotype.weight <- '1';	
					}
					
					tmpExternalFaults <- tmpStereotype.externalFaults;
					if(tr.source.isInitialState()) {
						tmpExpression <- thisModule.FEXP_ParseString(tmpExternalFaults, inst);
						tmpFGE <- thisModule.AddFGE(
							tmpExpression.faultsList(),
							Sequence{thisModule.ErrorModelStateToError(tr.target)},
							tmpStereotype.delay.parseDistribution(),
							1,
							tmpStereotype.weight.toReal()
						);
						tmpExpression.faultsGenerateErrors <- tmpFGE;
						tmpFGE.PropagationLogic <- tmpExpression;
						tmpFGE.PropagationLogicStringFormat <- tmpExpression.toString();
					}else{
						---TODO
						--Not implemented: Requires modifications to IDM
					}
				}
			}
		}
	}
}


lazy rule AddExternalFault {
	from
		fault : String,
		inst : UML!InstanceSpecification
	to 
		xft : IM!ExternalFault (
			Component <- thisModule.InstanceToComponent(inst),
			Name <- inst.name + '_' + fault
		)
}

unique lazy rule ErrorModelStateToError {
	from 
		state : UML!Vertex,
		inst : UML!InstanceSpecification
	to
		err : IM!Error (
			Name <- inst.name + '_' + state.name,
			Component <- thisModule.InstanceToComponent(inst)
		)
}

unique lazy rule InternalFault {
	from
		chIntFault : CHESS!InternalFault,
		inst : UML!InstanceSpecification
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
	}
	to
		ift : IM!InternalFault (
			Name <- 'ift_' + c.Faults->select(f | f.oclIsKindOf(IM!InternalFault))->size()+1,
			Occurrence <- chIntFault.occurrence.parseDistribution(),
			PermanentProbability <- 1,
			Component <- c
		)
}

unique lazy rule InternalPropagation {
	from 
		chIntProp : CHESS!InternalPropagation,
		inst : UML!InstanceSpecification
	using {
		myDelay : String = if chIntProp.delay.oclIsUndefined() then 'det(0)' else chIntProp.delay endif;
		myWeight : Real = if chIntProp.weight.oclIsUndefined() then 1 else chIntProp.weight.toReal() endif;
		c : IM!Component = thisModule.InstanceToComponent(inst);
	}
	to
		imIntProp : IM!InternalPropagation (
			Component <- c,
			Name <- c.Name + '_intprop_' + c.InternalPropagation->size()+1,
			Source <- thisModule.ErrorModelStateToError(chIntProp.base_Transition.source),
			Destination <- thisModule.ErrorModelStateToError(chIntProp.base_Transition.target),
			PropagationProbability <- 1,
			PropagationDelay <- myDelay.parseDistribution(),
			Weight <- myWeight
		)
}

rule AddFailureMode(name : String, c : IM!Component) {
	to 
		fm : IM!FailureMode (
			Name <- c.Name + '_' + name
		)
	do {
		c.FailureModes <- c.FailureModes->append(fm);
	
		fm;
	}
}

rule AddError(name : String, c : IM!Component) {
	to
		e : IM!Error (
			Name <- c.Name + '_' + name,
			Component <- c
		)
	do {
		e;
	}
}

unique lazy rule AddEPFFromErrorModelFailure {
	from
		f : CHESS!Failure
	using {
		eSource : IM!Error = thisModule.ErrorModelStateToError(f.base_Transition.source);
		myDelay : String = if f.delay.oclIsUndefined() then 'det(0)' else f.delay endif;
		myWeight : Real = if f.weight.oclIsUndefined() then 1 else f.weight.toReal() endif;
		c : IM!Component = eSource.Component;
	}
	to
		epf : IM!ErrorsProducesFailures (
			Name <- c.Name + '_epf_' + c.ErrorsGeneratesFailures->size()+1,
			Source <- Sequence{eSource},
			Destination <- eSource.Component.FailureModes->select(fm | f.mode->includes(fm.Name)),
			Component <- c,
			PropagationDelay <- myDelay.parseDistribution(),
			PropagationProbability <- 1,
			Weight <- myWeight
		)
	do {
		epf;
	}	
}

rule AddFLARuleEPF(e : IM!Error) {
	to
		epf : IM!ErrorsProducesFailures (
			Name <- e.Name + '_epf',
			Source <- Sequence{e},
			Destination <- Sequence{},
			Component <- e.Component,
			PropagationDelay <- thisModule.Deterministic(0),
			PropagationProbability <- 1,
			Weight <- 1
		)
	do{
		epf;
	}
}

rule AddFGE(f : Sequence(IM!Fault), e : Sequence(IM!Error), delay : IM!Distribution, p : Real, weight : Real) {
	using {
		c : IM!Component = f->first().Component;
	}
	to
		fge : IM!FaultsGenerateErrors (
			Name <- c.Name + '_fge_' + c.FaultsGeneratesErrors->size()+1,
			Component <- c,
			Source <- f,
			Destination <- e,
			ActivationDelay <- delay,
			PropagationProbability <- p,
			Weight <- weight
		)
	do {
		fge;	
	}
}

rule AddEPF(e : IM!Error, fm : IM!FailureMode, delay : IM!Distribution, p : Real, weight : Real) {
	using {
		c : IM!Component = fm.Component;			
	}
	to 
		epf : IM!ErrorsProducesFailures (
			Name <- c.Name + '_epf_' + c.FaultsGeneratesErrors->size()+1,
			Component <- c,
			Source <- Set{e},
			Destination <- Set{fm},
			PropagationDelay <- delay,
			PropagationProbability <- p,
			Weight <- weight
		)
}

rule AddSourceError(fm : IM!FailureMode) {
	using {
		c : IM!Component = fm.Component;
	}
	to 
		e : IM!Error (
			Name <- c.Name + '_e_' + fm.Name,
			Component <- c
		),
		epf : IM!ErrorsProducesFailures (
			Source <- Set{e},
			Destination <- Set{fm},
			Component <- c
		)
}

--------------------------------------------------------------------
-- Rules related to the definition of the metric
--------------------------------------------------------------------

lazy rule newEvalIntervalOfTime {
	from
		t : Real
	to
		iot : IM!IntervalOfTimeAveraged
		(
			begin <- 0,
			end <- t
		)
}
lazy rule newEvalInstantOfTime {
	from
		t : Real
	to
		instant : IM!InstantOfTime ( timePoint <- t )
}

rule Reliability(sba : CHESS!StateBasedAnalysis, time : Real){

	using {
		strClean : String = sba.measure.regexReplaceAll('[={}]', ' ').trim();
		iInstant : Integer = strClean.indexOf('instantOfTime');

		--Select all the failure modes of component instance specified as 'targetDepComponent'
		allFailuresOfSelectedInstances : Set(IM!FailureMode) =
			sba.targetDepComponent->
				collect(i | thisModule.InstanceToComponent(i).FailureModes)->flatten()->asSet();

		---TODO: the facility to select the failure mode must be reimplemented
		--Select all the failure modes (of all the instances) specified as 'targetFailureModes'
		fmSelected : Set(IM!FailureMode) = Set{};
			--thisModule.FailuresMap->getKeys()->select(k | sba.targetFailureMode->collect(fm | fm.base_State)->includes(k.st))->collect(selK | thisModule.FailuresMap->get(selK))->asSet();
			
		imsistema : IM!Sistema = IM!Sistema.allInstances()->first();
	}
	to
		re : IM!Reliability (
			Name <-	'Reliability'
		)

	do{
		imsistema.measures.add(re);
		if (iInstant > 0) {
			re.evaluations.add(
				thisModule.newEvalInstantOfTime(
					strClean.substring(iInstant + 1 + 'instantOfTime'.size(), strClean.size()).toReal()
				)
			);
		}
		else{
			--Should not happen!
		}

		--[allFailuresOfSelectedInstances]: all the failure modes of selected component instances
		--[fmSelected]: all the selected failure modes
		--Idea: select only SELECTED failure modes, of SELECTED component instances
		--(i.e., perform an intersection between the two)
		--If one of the two is not specified, then select all the failure modes specified by the other
		if(fmSelected.isEmpty()) {
			re.target <- allFailuresOfSelectedInstances;
			re.Name <- re.Name + sba.targetDepComponent->collect(i | '_' + i.name)->sum();
		}else{
			if(allFailuresOfSelectedInstances.isEmpty()) {
				re.target <- fmSelected;
			}else{
				re.target <- allFailuresOfSelectedInstances->intersection(fmSelected);
			}
			re.Name <- re.Name + re.target->collect(fm | '_' + fm.Name)->sum();
		}
	}
}

rule Availability(sba : CHESS!StateBasedAnalysis, time : Real){

	using {
		strClean : String = sba.measure.regexReplaceAll('[={}]', ' ').trim();
		iInterval : Integer = strClean.indexOf('intervalEnd');
		iInstant : Integer = strClean.indexOf('instantOfTime');

		--Select all the failure modes of component instance specified as 'targetDepComponent'
		allFailuresOfSelectedInstances : Set(IM!FailureMode) =
			sba.targetDepComponent->collect(i | thisModule.InstanceToComponent(i).FailureModes)->flatten()->asSet();

		---TODO: the facility to select the failure mode must be reimplemented
		--Select all the failure modes (of all the instances) specified as 'targetFailureModes'
		fmSelected : Set(IM!FailureMode) = Set{};
			--thisModule.FailuresMap->getKeys()->select(k | sba.targetFailureMode->collect(fm | fm.base_State)->includes(k.st))->collect(selK | thisModule.FailuresMap->get(selK))->asSet();
			
		imsistema : IM!Sistema = IM!Sistema.allInstances()->first();
	}
	to
		re : IM!Availability (
			Name <-	'Availability_'
		)
	do{
		imsistema.measures.add(re);

		if (iInterval > 0)
		{
			re.evaluations.add(
				thisModule.newEvalIntervalOfTime(
					strClean.substring(iInterval + 1 + 'intervalEnd'.size(), strClean.size()).toReal()
				)
			);
		}
		else if (iInstant > 0) {
			re.evaluations.add(
				thisModule.newEvalInstantOfTime(
					strClean.substring(iInstant + 1 + 'instantOfTime'.size(), strClean.size()).toReal()
				)
			);
		}
		else{
			--Should not happen!
		}

		--[allFailuresOfSelectedInstances]: all the failure modes of selected component instances
		--[fmSelected]: all the selected failure modes
		--Idea: select only SELECTED failure modes, of SELECTED component instances
		--(i.e., perform an intersection between the two)
		--If one of the two is not specified, then select all the failure modes specified by the other
		if(fmSelected.isEmpty()) {
			re.target <- allFailuresOfSelectedInstances;
			re.Name <- re.Name + sba.targetDepComponent->collect(i | '_' + i.name)->sum();
		}else{
			if(allFailuresOfSelectedInstances.isEmpty()) {
				re.target <- fmSelected;
			}else{
				re.target <- allFailuresOfSelectedInstances->intersection(fmSelected);
			}
			re.Name <- re.Name + re.target->collect(fm | '_' + fm.Name)->sum();
		}
	}
}

--------------------------------------------------------------------
-- Rules to create IM!Distribution elements
--------------------------------------------------------------------
lazy rule Exponential {
	from
		lambda : Real
	to
		e : IM!Exponential ( Rate <- lambda )
}

lazy rule Deterministic {
	from
		value : Real
	to
		d : IM!Deterministic ( Value <- value )
}

lazy rule Uniform {
	from
		lower : Real,
		upper : Real
	to
		d : IM!Uniform ( 
			Lower <- lower,
			Upper <- upper
		)
}

lazy rule Gaussian {
	from
		mean : Real,
		variance : Real
	to 
		g : IM!Gaussian (
			Mean <- mean,
			Variance <- variance
		)
}

lazy rule Gamma {
	from
		a : Real,
		b : Real
	to 
		g : IM!Gamma (
			Alpha <- a,
			Beta <- b
		)
}

lazy rule Weibull {
	from
		a : Real,
		b : Real
	to 
		g : IM!Weibull (
			Alpha <- a,
			Beta <- b
		)
}

--------------------------------------------------------------------
-- Rules to build Faults/Errors expressions
--------------------------------------------------------------------
rule FEXP_Fault(f: IM!Fault) {
	to
		fefn : IM!FaultsExpressionFaultNode (
			Fault <- f
		)
	do{
		fefn;
	}
}

rule FEXP_Or(e1 : IM!FaultsExpressionNode, e2: IM!FaultsExpressionNode) {
	to
		feon : IM!FaultsExpressionOrNode (
			FaultsExpression1 <- e1,
			FaultsExpression2 <- e2
		)
	do{
		feon;
	}
}

rule FEXP_And(e1 : IM!FaultsExpressionNode, e2: IM!FaultsExpressionNode) {
	to
		fean : IM!FaultsExpressionAndNode (
			FaultsExpression1 <- e1,
			FaultsExpression2 <- e2
		)
	do{
		fean;
	}
}

rule FEXP_Not(e : IM!FaultsExpressionNode) {
	to 
		fenn : IM!FaultsExpressionNotNode (
			FaultsExpression <- e	
		)
	do {
		fenn;
	}
}

rule FEXP_MultiOr(fe : Sequence(IM!FaultsExpressionNode)) {
	using {
		tmpExpression1 : IM!FaultsExpressionNode = OclUndefined;
		tmpExpression2 : IM!FaultsExpressionNode = OclUndefined;
		tmpSequence : Sequence(IM!Fault) = fe;
	}
	do {
		if(fe->size() = 1) {
			tmpExpression1 <- fe->first();
		}else{
			tmpExpression1 <- tmpSequence->first();
			tmpSequence <- tmpSequence.subSequence(2, tmpSequence.size());
			tmpExpression2 <- tmpSequence->first();
			tmpSequence <- tmpSequence.subSequence(2, tmpSequence.size());
			
			tmpExpression1 <- thisModule.FEXP_Or(tmpExpression1,tmpExpression2);
			for(ft in tmpSequence) {
				tmpExpression2 <- 	thisModule.FEXP_Or(
										tmpExpression1,
										ft
								 	);
				tmpExpression1 <- tmpExpression2;
			}
		}
		
		tmpExpression1;
	}	
}

rule FEXP_MultiAnd(fe : Sequence(IM!FaultsExpressionNode)) {
	using {
		tmpExpression1 : IM!FaultsExpressionNode = OclUndefined;
		tmpExpression2 : IM!FaultsExpressionNode = OclUndefined;
		tmpSequence : Sequence(IM!Fault) = fe;
	}
	do {
		if(fe->size() = 1) {
			tmpExpression1 <- fe->first();
		}else{
			tmpExpression1 <- tmpSequence->first();
			tmpSequence <- tmpSequence.subSequence(2, tmpSequence.size());
			tmpExpression2 <- tmpSequence->first();
			tmpSequence <- tmpSequence.subSequence(2, tmpSequence.size());
			
			tmpExpression1 <- thisModule.FEXP_And(tmpExpression1,tmpExpression2);
			for(ft in tmpSequence) {
				tmpExpression2 <- 	thisModule.FEXP_And(
										tmpExpression1,
										ft
								 	);
				tmpExpression1 <- tmpExpression2;
			}
		}
		
		tmpExpression1;
	}	
}

--Parses a string into a FaultsExpression
---TODO: Implement more advanced parsing
rule FEXP_ParseString(exp : String, inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		tmpSplit : Sequence(String) = OclUndefined;
		expRet : IM!FaultsExpressionNode = OclUndefined;
	}
	do {
		tmpSplit <- exp.toLower().split(' and | AND ');
		if(tmpSplit.size() > 1) {
			expRet <-
			thisModule.FEXP_MultiAnd(
				tmpSplit->collect(
					ft | c.Faults->select(ff | ff.Name.noNamespace(c.Name) = ft.trim())->first()
				)->
				flatten()->
				collect(ft | thisModule.FEXP_Fault(ft))
			);
		}else {
			tmpSplit <- exp.toLower().split(' or | OR ');
			if(tmpSplit.size() > 1) {
				expRet <-
				thisModule.FEXP_MultiOr(
					tmpSplit->collect(
						s | c.Faults->select(ft | ft.Name.noNamespace(c.Name) = s.trim())
					)->
					flatten()->
					collect(ft | thisModule.FEXP_Fault(ft))
				);
			}else {
				expRet <- thisModule.FEXP_Fault(tmpSplit->first());
			}
		}
		
		expRet;
	}
}

rule setFGEBackLinks(fen: IM!FaultsExpressionNode, fge: IM!FaultsGenerateErrors ) {
	do {
		fen.faultsGenerateErrors <- fge;
		if (fen.oclIsTypeOf(IM!FaultsExpressionOrNode)) {
			thisModule.setFGEBackLinks(fen.FaultsExpression1, fge);
			thisModule.setFGEBackLinks(fen.FaultsExpression2, fge);
		}else if (fen.oclIsTypeOf(IM!FaultsExpressionAndNode)){
			thisModule.setFGEBackLinks(fen.FaultsExpression1, fge);
			thisModule.setFGEBackLinks(fen.FaultsExpression2, fge);
		}else if (fen.oclIsTypeOf(IM!FaultsExpressionNotNode)) {
			thisModule.setFGEBackLinks(fen.FaultsExpression, fge);
		}
	}
}

rule setEPFBackLinks(een: IM!ErrorsExpressionNode, epf: IM!ErrorsProducesFailures ) {
	do {
		een.errorPropagation <- epf;
		if (een.oclIsTypeOf(IM!FaultsExpressionOrNode)) {
			thisModule.setEPFBackLinks(een.FaultsExpression1, epf);
			thisModule.setEPFBackLinks(een.FaultsExpression2, epf);
		} else if (een.oclIsTypeOf(IM!FaultsExpressionAndNode)) {
			thisModule.setEPFBackLinks(een.FaultsExpression1, epf);
			thisModule.setEPFBackLinks(een.FaultsExpression2, epf);
		}
	}
}

--Check if a IM!Component already contains a specific failure mode
helper context IM!Component def: hasFailureMode(fm : String) : Boolean =
	not self.FailureModes->select(f | f.Name.noNamespace(self.Name).trim() = fm.trim())->isEmpty();

--Check if a IM!Component already contains a specific fault
helper context IM!Component def: hasFault(fm : String) : Boolean =
	not self.Faults->select(f | f.Name.noNamespace(self.Name).trim() = fm.trim())->isEmpty();

--Get <<Failure>> stereotype from a Transition
helper context UML!Transition def: getFailureStereotype() : CHESS!Failure =
	CHESS!Failure.allInstances()->select(f | f.base_Transition = self)->first();

--Get <<ErrorState>> stereotype from a State
helper context UML!State def: getErrorStateStereotype() : CHESS!ErrorState =
	CHESS!ErrorState.allInstances()->select(e | e.base_State = self)->first();

--Check if a Vertex is an initial state (healty state of the error model)
helper context UML!Vertex def: isInitialState() : Boolean =
	if(self.oclIsKindOf(CHESS!Pseudostate)) then
		self.kind = #initial
	else
		false
	endif;

--Remove the component name
helper context String def: noNamespace(n : String) : String =
	self.regexReplaceAll(n + '_', '');
	

--------------------------------------------------------------------
-- Parse strings in VSL notation into IM!Distribution elements
--------------------------------------------------------------------
helper context String def: parseDistribution() : IM!Distribution = 
	let dist : String = self.trim().toLower() in
	if dist.startsWith('exp') then
		dist.parseExponential()
	else if dist.startsWith('det') then
		dist.parseDeterministic()
	else if dist.startsWith('uni') then
		dist.parseUniform()
	else if dist.startsWith('norm') or dist.startsWith('gauss') then
		dist.parseGaussian()
	else if dist.startsWith('gam') then
		dist.parseGamma()
	else if dist.startsWith('wei') then
		dist.parseWeibull()
	else
		thisModule.Exponential(0)
	endif endif endif endif endif endif;

helper context String def: parseExponential() : IM!Exponential =
	thisModule.Exponential(self.substring(self.indexOf('(')+2, self.indexOf(')')).toReal());

helper context String def: parseDeterministic() : IM!Deterministic =
	thisModule.Deterministic(self.substring(self.indexOf('(')+2, self.indexOf(')')).toReal());

helper context String def: parseUniform() : IM!Uniform =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Uniform(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseGaussian() : IM!Gaussian =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Gaussian(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseGamma() : IM!Gamma =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Gamma(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseWeibull() : IM!Gamma =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Weibull(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

--------------------------------------------------------------------
-- Collections that are used to filter and categorize model elements
--------------------------------------------------------------------
helper def : Instances : Sequence(UML2!InstanceSpecification) = Sequence {};
helper def : Connectors : Set(UML2!InstanceSpecification) = Set {};
helper def : Comments : Set (UML2!Comment) = Set {};
helper def : Ports : Set (UML2!Port) = Set {};
helper def : States : Set(UML2!State) = Set{};
helper def : Transitions : Set(UML2!Tansition) = Set{};

helper context UML!InstanceSpecification def: getBaseItem() : UML!Classifier = self.classifier->first();

--Find the SimpleStochasticBehavior element associated with a Classifier or an InstanceSpecification
--if it exists. Returns OclUndefined otherwise
helper context UML!Classifier def: getSimpleStochasticBehavior() : CHESS!SimpleStochasticBehavior =
	CHESS!SimpleStochasticBehavior->allInstances()->select(ssb | ssb.base_Class = self)->first();

helper context UML!InstanceSpecification def: getSimpleStochasticBehavior() : CHESS!SimpleStochasticBehavior =
	let instssb : CHESS!SimpleStochasticBehavior = 
		CHESS!SimpleStochasticBehavior->allInstances()->select(ssb | ssb.base_InstanceSpecification = self)->first() in
	if instssb <> OclUndefined then instssb else 
		let base : UML!Class = self.getBaseItem() in 
			if base = OclUndefined then base else base.getSimpleStochasticBehavior() endif
	endif;

--------------------------------------------------------------------
-- Helpers to get dependability information from stereotypes
--------------------------------------------------------------------
	
--Do we have dependability information for this instance?
helper context UML!InstanceSpecification def: hasSBAInformation() : Boolean = self.getSBAStereotype() <> OclUndefined;

--If the InstanceSpecification has its own stereotype then return it,
-- otherwise return the one of the classifier
helper context UML!InstanceSpecification def: getSBAStereotype() : OclAny = 
	let s : OclAny = self.getSBAStereotypeInstance() in
	if s = OclUndefined then self.classifier->first().getSBAStereotypeClassifier() else s endif;

--Get the SBA stereotype applied to the instance, if any
helper context UML!InstanceSpecification def: getSBAStereotypeInstance() : OclAny =
	thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten()->select(st | st.base_InstanceSpecification = self)->first();

--Find the CHESS stereotype that is used on a given instance specification, or on its classifier
helper context UML!Class def: getSBAStereotypeClassifier() : OclAny =
	thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten()->select(st | st.base_Class = self)->first();

--Recursive helper to identify which instances need to be taken into account,
--i.e., to identify those that have dependability information attached, or no
--subinstances
helper context UML!InstanceSpecification  def: findSBAConstituents() : Set(UML!InstanceSpecification) =
	if self.hasSBAInformation() or self.getSubInstances().isEmpty() then
		Set{self}
	else
		self.getSubInstances()->collect(i | i.findSBAConstituents())->flatten()
	endif;

--Get the stereotype associated to an error model transition
helper context UML!Transition def: getSBAStereotype() : OclAny =
	thisModule.sbaTransitions->collect(s | s.allInstances())->
								flatten()->select(t | t.base_Transition = self)->
								first();

--Does this error model transition has dependability information associated with it?
helper context UML!Transition def: hasSBAInformation() : Boolean = not self.getSBAStereotype().oclIsUndefined();

--------------------------------------------------------------------
-- Helpers to get, start from a given InstanceSpecification,
-- port instances and subcomponent instances
--------------------------------------------------------------------
helper context UML!InstanceSpecification def: getPortSlots() : Set(UML!Slot) = 
	self.slot->select(s | s.definingFeature.oclIsKindOf(UML!Port));

helper context UML!InstanceSpecification def: getSubInstanceSlots() : Set(UML!Slot) =
	self.slot->select(s | not s.definingFeature.oclIsKindOf(UML!Port));

helper context UML!InstanceSpecification def: getSubInstances() : Set(UML!InstanceSpecification) = 
	self.getSubInstanceSlots()->collect(s | s.value->first().instance);

helper context UML!InstanceSpecification def: isSubInstanceOf(parent : UML!InstanceSpecification) : Boolean =
	parent.getSubInstances()->includes(self);

--Get the name of a port slot, as the name of the originating port
helper context UML!Slot def: name : String = self.definingFeature.name;
 
--helper context UML!Slot def: getConnectedSlotsInput() : Set(UML!Slot) =
--	self;
--helper context UML!Slot def: getConnectedSlotsOutput() : Set(UML!Slot) = 
--	self;
--helper context UML!Slot def: getConnectedSlots() : Set(UML!Slot) =
--	self.getConnectedSlotsInput->union(self.getConnectedSlotsOutput);

--------------------------------------------------------------------
-- Check if a Port (or Slot) has input or output dataflow
--------------------------------------------------------------------
helper context UML!Slot def: hasInputFlow() : Boolean = self.definingFeature.hasInputFlow();
helper context UML!Slot def: hasOutputFlow() : Boolean = self.definingFeature.hasOutputFlow();
helper context UML!Port def: hasInputFlow() : Boolean =
	let clientserverport : MARTE!ClientServerPort = MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first() in
	let flowport : SYSML!FlowPort = SYSML!FlowPort.allInstances()->select(c | c.base_Port = self)->first() in
	if clientserverport <> OclUndefined then clientserverport.hasInputFlow() else
		if flowport <> OclUndefined then flowport.hasInputFlow() else
			false
	endif endif;
helper context UML!Port def: hasOutputFlow() : Boolean =
	let clientserverport : MARTE!ClientServerPort = MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first() in
	let flowport : SYSML!FlowPort = SYSML!FlowPort.allInstances()->select(c | c.base_Port = self)->first() in
	if clientserverport <> OclUndefined then clientserverport.hasOutputFlow() else
		if flowport <> OclUndefined then flowport.hasOutputFlow() else
			false
	endif endif;
helper context SYSML!FlowPort def: hasInputFlow() : Boolean = self.direction <> #out;
helper context SYSML!FlowPort def: hasOutputFlow() : Boolean = self.direction = #out or self.direction = #inout;
helper context MARTE!ClientServerPort def: hasInputFlow() : Boolean = self.kind <> #provided;
helper context MARTE!ClientServerPort def: hasOutputFlow() : Boolean = self.kind <> #required;

--------------------------------------------------------------------
-- Helpers to explore the model and get the component that is
-- connected to the other side of a port
--------------------------------------------------------------------

--Get connectors that are linked to a certain port instance
helper context UML!Slot def: getConnectors() : Set(UML!InstanceSpecification) =
	thisModule.umlInstancesConnectors->
				select(c | not c.slot->select(s | s.definingFeature = self.definingFeature 
					and s.value->first().instance = self.refImmediateComposite())->isEmpty());

--Is the connector instance a "normal" connection
--betweentwo components at the same level?
helper context UML!InstanceSpecification def: isConnection() : Boolean = 
	let sl : OrderedSet(UML!Slot) = self.slot->asOrderedSet() in
	let i1 : UML!InstanceSpecification = sl->first().value->first().instance in
	let i2 : UML!InstanceSpecification = sl->last().value->first().instance in
	not i1.isSubInstanceOf(i2) and not i2.isSubInstanceOf(i1);

--Is the connector instance a delegation?
helper context UML!InstanceSpecification def: isDelegation() : Boolean = 
	let sl : OrderedSet(UML!Slot) = self.slot->asOrderedSet() in
	let i1 : UML!InstanceSpecification = sl->first().value->first().instance in
	let i2 : UML!InstanceSpecification = sl->last().value->first().instance in
	i1.isSubInstanceOf(i2) or i2.isSubInstanceOf(i1);

--Get port instances that are *directly* connected to a certain port instance
helper context UML!Slot def: getConnectedImmediate() : Set(UML!Slot) =
	let connectorsSlots : Set(UML!Slot) = 
	self.getConnectors()->select(c | c.isConnection())->
							collect(c | c.slot)->
							flatten()->
							select(s | s.definingFeature <> self.definingFeature)
	in
	connectorsSlots->collect(s | s.value->first().instance.slot->
									select(sl | sl.definingFeature = s.definingFeature))->flatten();

--Get port instances that receive/send delegation from/to a certain port instance
helper context UML!Slot def: getDelegationEnds() : Set(UML!Slot) =
	let connectorsSlots : Set(UML!Slot) =
	self.getConnectors()->select(c | c.isDelegation())->
							collect(c | c.slot)->
							flatten()->
							select(s | s.definingFeature <> self.definingFeature)
	in
	connectorsSlots->collect(s | s.value->first().instance.slot->
									select(sl | sl.definingFeature = s.definingFeature))->flatten();

--Get taget(s) of delegation in sub-instances
helper context UML!Slot def: getDelegationEndsDownwards() : Set(UML!Slot) = 
	self.getDelegationEnds()->select(s | s.refImmediateComposite().isSubInstanceOf(self.refImmediateComposite()));

--Get source(s) of delegation in parent instance
helper context UML!Slot def: getDelegationEndsUpwards() : Set(UML!Slot) = 
	self.getDelegationEnds()->select(s | self.refImmediateComposite().isSubInstanceOf(s.refImmediateComposite()));

--Get the target of delegation taking into account SBA stereotypes,
--i.e., get the first slot whose owning instnace has SBA information.
--(it can be even the slot under examination itself)
helper context UML!Slot def: getSBADelegations() : Set(UML!Slot) =
	let inst : UML!InstanceSpecification = self.refImmediateComposite() in
	let deleg : Set(UML!Slot) = self.getDelegationEndsDownwards() in
	if deleg.isEmpty() or 
		inst.hasSBAInformation() or 
		inst.getSubInstances().isEmpty() 
	then
		Set{self} 
	else
		deleg->collect(e | e.getSBADelegations())->flatten()
	endif;

--Get the target of connection taking into account SBA stereotypes,
--i.e., get the first slot whose owning instance has SBA information.
--(it can be even the slot directly connected to the one under examination)
helper context UML!Slot def: getSBAConnections() : Set(UML!Slot) =
	self.getConnectedImmediate()->collect(sl | sl.getSBADelegations())->flatten();	

--------------------------------------------------------------------
-- Parse failure modes for SimpleStochasticBehavior elements
--------------------------------------------------------------------

--Split the specification into different parts, one for each port, and find the
--failure modes for the port name passed as input. Calls parseFailureModes() below
helper context String def: parseFailureModesForPort(port : String) : Set(TupleType(fm: String, p: Real)) =
	let strSeq : Sequence(String) = self.trim()->split(';') in
	let strSelected : String = strSeq->select(s | s.trim().startsWith(port))->first() in
	if strSelected = OclUndefined then
		strSeq->first().parseFailureModes()
	else 
		strSelected.parseFailureModes()
	endif;

--From the specification in string format get the failure modes and proabilities for a single port
helper context String def: parseFailureModes() : Set(TupleType(fm: String, p: Real)) =
	let str : String = 
		if self.indexOf('{') < 0 then
			self.trim()
		else
			self.substring(self.indexOf('{')+2, self.size()).replaceAll('}', ' ').trim()
		endif	
	in
	let default : Set(TupleType(fm: String, p: Real)) = Set{Tuple{fm = 'failure', p = 1.0}} in
	if str.size() = 0 then
		default
	else
		let ret : Set(TupleType(fm: String, p: Real)) = 
		str.split(',')->collect(s | s.split(':'))->
			collect(seq | Tuple{fm = seq->first().trim(), p = seq.last().toReal()})
		in
		if ret->isEmpty() then
			default
		else
			ret
	endif endif;

--------------------------------------------------------------------
-- Helpers to managethe metrics
--------------------------------------------------------------------

--temporary parser to retrieve which dependability measure a SBAnalysis refers to
helper context CHESS!StateBasedAnalysis def: WhichMeasure : String =
	if self.measure.startsWith('Reliability') then 'Reliability'
	else if self.measure.startsWith('Availability') then 'Availability'
	else 'error'
	endif endif;

--temporary parser to retrieve the time value from a dependability measure
helper context String def: getTime : Real =
	self.substring(self.indexOf('=')+2, self.size()-1).toReal();
		
--------------------------------------------------------------------
-- Helpers to manage Faults/Errors expressions
--------------------------------------------------------------------
helper context IM!FaultsExpressionFaultNode def: toString(): String = self.Fault.Name;
helper context IM!FaultsExpressionOrNode def: toString(): String = '(' + self.FaultsExpression1.toString() + ' OR ' + self.FaultsExpression2.toString() + ')';
helper context IM!FaultsExpressionAndNode def: toString() : String = '(' + self.FaultsExpression1.toString() + ' AND ' + self.FaultsExpression2.toString() + ')';
helper context IM!FaultsExpressionNotNode def: toString() : String = '(NOT ' + self.FaultsExpression.toString() + ')';

--Get the list of Fault elements involved in a FaultsExpression
helper context IM!FaultsExpressionNode def: faultsList() : Sequence(IM!Fault) = 
	if self.oclIsTypeOf(IM!FaultsExpressionFaultNode) then
		let fexp : IM!FaultsExpressionFaultNode = self in 
		Sequence{fexp.Fault}
	else if self.oclIsTypeOf(IM!FaultsExpressionNotNode) then
		let fexp : IM!FaultsExpressionNotNode = self in 
		fexp.FaultsExpression.faultsList()
	else if self.oclIsTypeOf(IM!FaultsExpressionAndNode) then
		let fexp : IM!FaultsExpressionAndNode = self in 
		fexp.FaultsExpression1.faultsList()->union(fexp.FaultsExpression2.faultsList())
	else if self.oclIsTypeOf(IM!FaultsExpressionOrNode) then
		let fexp : IM!FaultsExpressionOrNode = self in 
		fexp.FaultsExpression1.faultsList()->union(fexp.FaultsExpression2.faultsList())
	else
		Sequence{}	--it should never happen
	endif endif endif endif;

helper context IM!ErrorsExpressionErrorNode def: toString(): String = self.Error.Name;
helper context IM!ErrorsExpressionOrNode def: toString(): String = '(' + self.ErrorsExpression1.toString() + ' OR ' + self.ErrorsExpression2.toString() + ')';

--------------------------------------------------------------------
-- For debugging purposes: pretty print SBA stereotypes
--------------------------------------------------------------------
helper context CHESS!SimpleStochasticBehavior def: toString() : String = 
	'<<SimpleStochasticBehavior>>(' + self.failureOccurrence + ', ' + self.repairDelay + ', ' + self.failureModesDistribution + ')';
helper context CHESS!FLABehavior def: toString() : String = '<<FLABehavior>>(' + self.fptc + ')';
helper context CHESS!ErrorModelBehavior def: toString() : String = '<<ErrorModelBehavior>>(' + self.errorModel + ')';
helper context CHESS!ErrorModel def: toString() : String = '<<ErrorModel>>(' + self.base_StateMachine + ')';




