-- @path IM=/org.chess.statebased/metamodels/IM2.ecore
-- @path CHESS=/org.polarsys.chess.chessmlprofile/model/chessmlprofile.ecore
-- @nsURI MARTE=http://www.eclipse.org/papyrus/MARTE/1
-- @nsURI UML=http://www.eclipse.org/uml2/4.0.0/UML
-- @nsURI CHESS=http://CHESS
-- @nsURI SYSML=http://www.eclipse.org/papyrus/0.7.0/SysML

module CHESS2IM;
create OUT : IM from IN1 : CHESS, IN2 : MARTE, IN3 : UML, IN4 : SYSML;

helper def: umlInstancesAll : Sequence(UML!InstanceSpecification) = Sequence{}; 	--All the InstanceSpecification of the considered platform
helper def: umlInstancesConnectors : Set(UML!InstanceSpecification) = Set{};		--Instances of connectors
helper def: umlInstancesBlocks : Set(UML!InstanceSpecification) = Set{}; 			--Instances of components/blocks
helper def: umlInstancesStereo : Set(UML!InstanceSpecification) = Set{}; 			--Instances that have dependability information
helper def: umlInstancesRelevant : Set(UML!InstanceSpecification) = Set{}; 			--Instances that are relevant for the analysis
helper def: umlInstancesPorts : Set(UML!InstanceSpecification) = Set{};				--Instances of ports only
helper def: umlAllocations : Set(MARTE!Assign) = Set{};

--Stereotypes that can be used on Blocks/Components for state based analysis
helper def: sbaStereotypes : Sequence(OclAny) = Sequence{CHESS!SimpleStochasticBehavior, CHESS!FLABehavior, CHESS!ErrorModelBehavior, CHESS!DependableComponent,
														 CHESS!StatelessSoftware, CHESS!StatefulSoftware, CHESS!StatelessHardware, CHESS!StatefulHardware};

--rule to transform the CHESS!StateBasedAnalysis into an IM!Sistema
rule System {

	from
		sba : CHESS!StateBasedAnalysis
		--at the moment is it implied that there is only a StateBasedAnalysis in the model
	using {
		platform : UML!Package = sba.platform->first().base_Package;
		instances : Sequence(UML!InstanceSpecification) = UML!InstanceSpecification.allInstances()->select(i | i.refImmediateComposite() = platform);
		comments : Sequence(UML!Comment) = instances->collect(i | i.ownedComment)->flatten();
	} 
	to
		s : IM!Sistema (
			Name <- sba.base_StructuredClassifier.name
		)
	do {
		--Filter out and categorize relevant CHESS elements
		thisModule.umlInstancesAll <- instances;
		thisModule.umlInstancesConnectors <- instances->select(i | i.classifier.isEmpty());
		thisModule.umlInstancesBlocks <- instances->select(i | not i.classifier.isEmpty());
		thisModule.umlAllocations <- MARTE!Assign.allInstances()->select(a | comments.includes(a.base_Comment));
		
		thisModule.umlInstancesBlocks <- thisModule.umlInstancesAll->select(i | thisModule.umlInstancesConnectors.excludes(i));

--		thisModule.umlInstancesStereo <- thisModule.umlInstancesBlocks->select(i | i.getSBAStereotype() <> OclUndefined);
thisModule.umlInstancesStereo <- thisModule.umlInstancesBlocks;

		for(i in thisModule.umlInstancesStereo) {
			i.debug('i->');
			i.getSBAStereotype().toString().debug('stereotype: ');
			i.slot->collect(sl | sl.definingFeature.name).debug('slots: ');
			i.getSubInstances().debug('sub instances');

			i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))->collect(s | s.hasInputFlow()).debug('is input: ');
			i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))->collect(s | s.hasOutputFlow()).debug('is output: ');	
			
			for(p in i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))) {
				p.definingFeature.name.debug('>>');
				p.hasInputFlow().debug('input? ');
				p.hasOutputFlow().debug('output? ');
				
				thisModule.umlInstancesConnectors.debug();
				thisModule.umlInstancesConnectors->collect(c | c.slot).debug();
				
				p.getConnectors().debug('getConnectors');
				p.getConnectors()->collect(c | c.isConnection()).debug('isConnection');
				p.getConnectors()->collect(c | c.isDelegation()).debug('isDelegation');
				p.getConnectedImmediate()->collect(i|i.definingFeature.name).debug('getConnectedImmediate');
				p.getDelegationEnds()->collect(i|i.definingFeature.name).debug('getDelegationEnds');
				p.getDelegationEndsDownwards()->collect(i|i.definingFeature.name).debug('getDelegationEndsDownwards');
				p.getDelegationEndsUpwards()->collect(i|i.definingFeature.name).debug('getDelegationEndsUpwards');
				p.getSBADelegation()->collect(i|i.definingFeature.name).debug('getSBADelegation');
				thisModule.umlInstancesConnectors->select(c | not c.slot->select(s | s.definingFeature = p.definingFeature and s.value->first().instance = i)->isEmpty()).debug();
				thisModule.umlInstancesConnectors->collect(c | c.slot->collect(s | s.value->first().instance)).debug('conns');
				
			}
			thisModule.debug('------------------------');
		}
		thisModule.umlInstancesStereo.debug();
		UML!InstanceSpecification.allInstances()->collect(i | i.getSimpleStochasticBehavior().debug('##'));
--		
--		
--		UML!InstanceSpecification.allInstances()->collect(i | CHESS!SimpleStochasticBehavior.allInstances()->exists(ssb | ssb.base_Class = i.getBaseItem()).debug());
--	
--		thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten();

--helper context UML!Port def: isInputPort : Boolean =
--MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first().kind 

		MARTE!ClientServerPort.allInstances()->collect(p | p.kind).debug();
		SYSML!FlowPort.allInstances()->collect(p | p.hasInputFlow()).debug();
		UML!Port.allInstances()->collect(p | p.hasInputFlow()).debug();
	


		--DEBUG: Print the obtained sets
		thisModule.umlInstancesAll.debug('Instances ['+ thisModule.umlInstancesAll.size() +']');
		thisModule.umlInstancesConnectors.debug('Connectors ['+ thisModule.umlInstancesConnectors.size() +']');
		thisModule.umlInstancesBlocks.debug('Blocks ['+ thisModule.umlInstancesBlocks.size() +']');	
		thisModule.umlInstancesStereo.debug('Stereotypes [' + thisModule.umlInstancesStereo.size() + ']');
		thisModule.umlInstancesRelevant.debug('Relevant [' + thisModule.umlInstancesRelevant.size() + ']');
		thisModule.umlInstancesPorts.debug('Ports [' + thisModule.umlInstancesPorts.size() + ']');
		thisModule.umlAllocations.debug('Allocations ['+ thisModule.umlAllocations.size() +']');
		--/DEBUG
	}
}

unique lazy rule SimpleStochasticToComponent {
	from
		inst : UML!InstanceSpecification
	using {
		params : CHESS!SimpleStochasticBehavior = inst.getSimpleStochasticBehavior();
	}
	to 
		c : IM!Component (
			Name <- inst.name
		)
}

rule AddFailureMode(name : String, c : IM!Component) {
	to 
		fm : IM!FailureMode (
			Name <- name	
		)
	do {
		c.FailureModes <- c.FailureModes->append(fm);
	}
}

--------------------------------------------------------------------
-- Collections that are used to filter and categorize model elements
--------------------------------------------------------------------
helper def : Instances : Sequence(UML2!InstanceSpecification) = Sequence {};
helper def : Connectors : Set(UML2!InstanceSpecification) = Set {};
helper def : Comments : Set (UML2!Comment) = Set {};
helper def : Ports : Set (UML2!Port) = Set {};
helper def : States : Set(UML2!State) = Set{};
helper def : Transitions : Set(UML2!Tansition) = Set{};

helper context UML!InstanceSpecification def: getBaseItem() : UML!Classifier = self.classifier->first();

--Find the SimpleStochasticBehavior element associated with a Classifier or an InstanceSpecification
--if it exists. Returns OclUndefined otherwise
helper context UML!Classifier def: getSimpleStochasticBehavior() : CHESS!SimpleStochasticBehavior =
	CHESS!SimpleStochasticBehavior->allInstances()->select(ssb | ssb.base_Class = self)->first();

helper context UML!InstanceSpecification def: getSimpleStochasticBehavior() : CHESS!SimpleStochasticBehavior =
	let instssb : CHESS!SimpleStochasticBehavior = 
		CHESS!SimpleStochasticBehavior->allInstances()->select(ssb | ssb.base_InstanceSpecification = self)->first() in
	if instssb <> OclUndefined then instssb else 
		let base : UML!Class = self.getBaseItem() in 
			if base = OclUndefined then base else base.getSimpleStochasticBehavior() endif
	endif;

--------------------------------------------------------------------
-- Helpers to get dependability information from stereotypes
--------------------------------------------------------------------
	
--Do we have dependability information for this instance?
helper context UML!InstanceSpecification def: hasSBAInformation() : Boolean = self.getSBAStereotype() <> OclUndefined;

--If the InstanceSpecification has its own stereotype then return it,
-- otherwise return the one of the classifier
helper context UML!InstanceSpecification def: getSBAStereotype() : OclAny = 
	let s : OclAny = self.getSBAStereotypeInstance() in
	if s = OclUndefined then self.classifier->first().getSBAStereotypeClassifier() else s endif;

--Get the SBA stereotype applied to the instance, if any
helper context UML!InstanceSpecification def: getSBAStereotypeInstance() : OclAny =
	thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten()->select(st | st.base_InstanceSpecification = self)->first();

--Find the CHESS stereotype that is used on a given instance specification, or on its classifier
helper context UML!Class def: getSBAStereotypeClassifier() : OclAny =
	thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten()->select(st | st.base_Class = self)->first();

--------------------------------------------------------------------
-- Helpers to get, start from a given InstanceSpecification,
-- port instances and subcomponent instances
--------------------------------------------------------------------
helper context UML!InstanceSpecification def: getPortSlots() : Set(UML!Slot) = 
	self.slot->select(s | s.definingFeature.oclIsKindOf(UML!Port));

helper context UML!InstanceSpecification def: getSubInstanceSlots() : Set(UML!Slot) =
	self.slot->select(s | not s.definingFeature.oclIsKindOf(UML!Port));

helper context UML!InstanceSpecification def: getSubInstances() : Set(UML!InstanceSpecification) = 
	self.getSubInstanceSlots()->collect(s | s.value->first().instance);

helper context UML!InstanceSpecification def: isSubInstanceOf(parent : UML!InstanceSpecification) : Boolean =
	parent.getSubInstances()->includes(self);

--helper context UML!Slot def: getConnectedSlotsInput() : Set(UML!Slot) =
--	self;
--helper context UML!Slot def: getConnectedSlotsOutput() : Set(UML!Slot) = 
--	self;
--helper context UML!Slot def: getConnectedSlots() : Set(UML!Slot) =
--	self.getConnectedSlotsInput->union(self.getConnectedSlotsOutput);

--------------------------------------------------------------------
-- Check if a Port (or Slot) has input or output dataflow
--------------------------------------------------------------------
helper context UML!Slot def: hasInputFlow() : Boolean = self.definingFeature.hasInputFlow();
helper context UML!Slot def: hasOutputFlow() : Boolean = self.definingFeature.hasOutputFlow();
helper context UML!Port def: hasInputFlow() : Boolean =
	let clientserverport : MARTE!ClientServerPort = MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first() in
	let flowport : SYSML!FlowPort = SYSML!FlowPort.allInstances()->select(c | c.base_Port = self)->first() in
	if clientserverport <> OclUndefined then clientserverport.hasInputFlow() else
		if flowport <> OclUndefined then flowport.hasInputFlow() else
			false
	endif endif;
helper context UML!Port def: hasOutputFlow() : Boolean =
	let clientserverport : MARTE!ClientServerPort = MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first() in
	let flowport : SYSML!FlowPort = SYSML!FlowPort.allInstances()->select(c | c.base_Port = self)->first() in
	if clientserverport <> OclUndefined then clientserverport.hasOutputFlow() else
		if flowport <> OclUndefined then flowport.hasOutputFlow() else
			false
	endif endif;
helper context SYSML!FlowPort def: hasInputFlow() : Boolean = self.direction <> #out;
helper context SYSML!FlowPort def: hasOutputFlow() : Boolean = self.direction = #out or self.direction = #inout;
helper context MARTE!ClientServerPort def: hasInputFlow() : Boolean = self.kind <> #provided;
helper context MARTE!ClientServerPort def: hasOutputFlow() : Boolean = self.kind <> #required;

--------------------------------------------------------------------
-- Helpers to explore the model and get the component that is
-- connected to the other side of a port
--------------------------------------------------------------------

--Get connectors that are linked to a certain port instance
helper context UML!Slot def: getConnectors() : Set(UML!InstanceSpecification) =
	thisModule.umlInstancesConnectors->
				select(c | not c.slot->select(s | s.definingFeature = self.definingFeature 
					and s.value->first().instance = self.refImmediateComposite())->isEmpty());

--Is the connector instance a "normal" connection
--betweentwo components at the same level?
helper context UML!InstanceSpecification def: isConnection() : Boolean = 
	let sl : OrderedSet(UML!Slot) = self.slot->asOrderedSet() in
	let i1 : UML!InstanceSpecification = sl->first().value->first().instance in
	let i2 : UML!InstanceSpecification = sl->last().value->first().instance in
	not i1.isSubInstanceOf(i2) and not i2.isSubInstanceOf(i1);

--Is the connector instance a delegation?
helper context UML!InstanceSpecification def: isDelegation() : Boolean = 
	let sl : OrderedSet(UML!Slot) = self.slot->asOrderedSet() in
	let i1 : UML!InstanceSpecification = sl->first().value->first().instance in
	let i2 : UML!InstanceSpecification = sl->last().value->first().instance in
	i1.isSubInstanceOf(i2) or i2.isSubInstanceOf(i1);

--Get port instances that are *directly* connected to a certain port instance
helper context UML!Slot def: getConnectedImmediate() : Set(UML!Slot) =
	let connectorsSlots : Set(UML!Slot) = 
	self.getConnectors()->select(c | c.isConnection())->
							collect(c | c.slot)->
							flatten()->
							select(s | s.definingFeature <> self.definingFeature)
	in
	connectorsSlots->collect(s | s.value->first().instance.slot->
									select(sl | sl.definingFeature = s.definingFeature))->flatten();

--Get port instances that receive/send delegation from/to a certain port instance
helper context UML!Slot def: getDelegationEnds() : Set(UML!Slot) =
	let connectorsSlots : Set(UML!Slot) =
	self.getConnectors()->select(c | c.isDelegation())->
							collect(c | c.slot)->
							flatten()->
							select(s | s.definingFeature <> self.definingFeature)
	in
	connectorsSlots->collect(s | s.value->first().instance.slot->
									select(sl | sl.definingFeature = s.definingFeature))->flatten();

--Get taget(s) of delegation in sub-instances
helper context UML!Slot def: getDelegationEndsDownwards() : Set(UML!Slot) = 
	self.getDelegationEnds()->select(s | s.refImmediateComposite().isSubInstanceOf(self.refImmediateComposite()));

--Get source(s) of delegation in parent instance
helper context UML!Slot def: getDelegationEndsUpwards() : Set(UML!Slot) = 
	self.getDelegationEnds()->select(s | self.refImmediateComposite().isSubInstanceOf(s.refImmediateComposite()));

--Get the target of delegation taking into account SBA stereotypes,
--i.e., get the first slot whose owning instnace has SBA information.
--(it can be even the slot under examination itself)
helper context UML!Slot def: getSBADelegation() : Set(UML!Slot) =
	let inst : UML!InstanceSpecification = self.refImmediateComposite() in
	let deleg : Set(UML!Slot) = self.getDelegationEndsDownwards() in
	if deleg.isEmpty() or 
		inst.hasSBAInformation() or 
		inst.getSubInstances().isEmpty() 
	then
		Set{self} 
	else
		deleg->collect(e | e.getSBADelegation())->flatten()
	endif;

--------------------------------------------------------------------
-- For debugging purposes: pretty print SBA stereotypes
--------------------------------------------------------------------
helper context CHESS!SimpleStochasticBehavior def: toString() : String = 
	'<<SimpleStochasticBehavior>>(' + self.failureOccurrence + ', ' + self.repairDelay + ', ' + self.failureModesDistribution + ')';
helper context CHESS!FLABehavior def: toString() : String = '<<FLABehavior>>(' + self.fptc + ')';
helper context CHESS!ErrorModelBehavior def: toString() : String = '<<ErrorModelBehavior>>(' + self.errorModel + ')';
helper context CHESS!ErrorModel def: toString() : String = '<<ErrorModel>>(' + self.base_StateMachine + ')';





