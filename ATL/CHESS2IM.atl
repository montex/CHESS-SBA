-- @path IM=/org.chess.statebased/metamodels/IM2.ecore
-- @path CHESS=/org.polarsys.chess.chessmlprofile/model/chessmlprofile.ecore
-- @nsURI MARTE=http://www.eclipse.org/papyrus/MARTE/1
-- @nsURI UML=http://www.eclipse.org/uml2/4.0.0/UML
-- @nsURI CHESS=http://CHESS
-- @nsURI SYSML=http://www.eclipse.org/papyrus/0.7.0/SysML

module CHESS2IM;
create OUT : IM from IN1 : CHESS, IN2 : MARTE, IN3 : UML, IN4 : SYSML;

helper def: umlInstancesAll : Sequence(UML!InstanceSpecification) = Sequence{}; 	--All the InstanceSpecification of the considered platform
helper def: umlInstancesConnectors : Set(UML!InstanceSpecification) = Set{};		--Instances of connectors
helper def: umlInstancesBlocks : Set(UML!InstanceSpecification) = Set{}; 			--Instances of components/blocks
helper def: umlInstancesStereo : Set(UML!InstanceSpecification) = Set{}; 			--Instances that have dependability information
helper def: umlInstancesRelevant : Set(UML!InstanceSpecification) = Set{}; 			--Instances that are relevant for the analysis
helper def: umlAllocations : Set(MARTE!Assign) = Set{};

--Stereotypes that can be used on Blocks/Components for state based analysis
helper def: sbaStereotypes : Sequence(OclAny) = Sequence{CHESS!SimpleStochasticBehavior, CHESS!FLABehavior, CHESS!ErrorModelBehavior, CHESS!DependableComponent,
														 CHESS!StatelessSoftware, CHESS!StatefulSoftware, CHESS!StatelessHardware, CHESS!StatefulHardware};
--Stereotypes that can be used on Transitions of an Error Model
helper def: sbaTransitions : Sequence(OclAny) = Sequence{CHESS!Failure, CHESS!InternalPropagation, CHESS!InternalFault};														 
helper def: flaNoFailure : String = 'noFailure';
helper def: flaWildcard : String = 'wildcard';
													 
helper def: flaRules : Map(IM!Component, Map(String, IM!Error)) = Map{};			--Map to obtain the list of flarules for a component, and the corresponding IM!Error elements

--rule to transform the CHESS!StateBasedAnalysis into an IM!Sistema
rule System {

	from
		sba : CHESS!StateBasedAnalysis
		--at the moment is it implied that there is only a StateBasedAnalysis in the model
	using {
		platform : UML!Package = sba.platform->first().base_Package;
		instances : Sequence(UML!InstanceSpecification) = UML!InstanceSpecification.allInstances()->select(i | i.refImmediateComposite() = platform);
		comments : Sequence(UML!Comment) = instances->collect(i | i.ownedComment)->flatten();
		instSystem : UML!InstanceSpecification = instances->first();
	} 
	to
		s : IM!Sistema (
			Name <- sba.base_StructuredClassifier.name
		)
	do {
		--Filter out and categorize relevant CHESS elements
		thisModule.umlInstancesAll <- instances;
		thisModule.umlInstancesConnectors <- instances->select(i | i.classifier.isEmpty());
		thisModule.umlInstancesBlocks <- instances->select(i | not i.classifier.isEmpty());
		thisModule.umlAllocations <- MARTE!Assign.allInstances()->select(a | comments.includes(a.base_Comment));
		
		thisModule.umlInstancesBlocks <- thisModule.umlInstancesAll->select(i | thisModule.umlInstancesConnectors.excludes(i));
		thisModule.umlInstancesStereo <- thisModule.umlInstancesBlocks->select(i | i.getSBAStereotype() <> OclUndefined);

		thisModule.umlInstancesRelevant <- instSystem.findSBAConstituents();
		
		
		--thisModule.umlInstancesStereo <- thisModule.umlInstancesBlocks;

--		for(i in thisModule.umlInstancesStereo) {
--			i.debug('i->');
--			i.getSBAStereotype().toString().debug('stereotype: ');
--			i.slot->collect(sl | sl.definingFeature.name).debug('slots: ');
--			i.getSubInstances().debug('sub instances');
--
--			i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))->collect(s | s.hasInputFlow()).debug('is input: ');
--			i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))->collect(s | s.hasOutputFlow()).debug('is output: ');	
--			
--			for(p in i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))) {
--				p.definingFeature.name.debug('>>');
--				p.hasInputFlow().debug('input? ');
--				p.hasOutputFlow().debug('output? ');
--				
--				thisModule.umlInstancesConnectors.debug();
--				thisModule.umlInstancesConnectors->collect(c | c.slot).debug();
--				
--				p.getConnectors().debug('getConnectors');
--				p.getConnectors()->collect(c | c.isConnection()).debug('isConnection');
--				p.getConnectors()->collect(c | c.isDelegation()).debug('isDelegation');
--				p.getConnectedImmediate()->collect(i|i.definingFeature.name).debug('getConnectedImmediate');
--				p.getDelegationEnds()->collect(i|i.definingFeature.name).debug('getDelegationEnds');
--				p.getDelegationEndsDownwards()->collect(i|i.definingFeature.name).debug('getDelegationEndsDownwards');
--				p.getDelegationEndsUpwards()->collect(i|i.definingFeature.name).debug('getDelegationEndsUpwards');
--				p.getSBADelegations()->collect(i|i.definingFeature.name).debug('getSBADelegations');
--				p.getSBAConnections()->collect(i|i.definingFeature.name).debug('getSBAConnections');
--				thisModule.umlInstancesConnectors->select(c | not c.slot->select(s | s.definingFeature = p.definingFeature and s.value->first().instance = i)->isEmpty())();
--				thisModule.umlInstancesConnectors->collect(c | c.slot->collect(s | s.value->first().instance))('conns');
--				
--			}
--			thisModule('------------------------');
--		}
--		thisModule.umlInstancesStereo();
--		UML!InstanceSpecification.allInstances()->collect(i | i.getSimpleStochasticBehavior()('##'));
----		
----		
----		UML!InstanceSpecification.allInstances()->collect(i | CHESS!SimpleStochasticBehavior.allInstances()->exists(ssb | ssb.base_Class = i.getBaseItem())());
----	
----		thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten();
--
----helper context UML!Port def: isInputPort : Boolean =
----MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first().kind 
--
--		MARTE!ClientServerPort.allInstances()->collect(p | p.kind)();
--		SYSML!FlowPort.allInstances()->collect(p | p.hasInputFlow())();
--		UML!Port.allInstances()->collect(p | p.hasInputFlow())();

		--DEBUG: Print the obtained sets
		thisModule.umlInstancesAll.debug('Instances ['+ thisModule.umlInstancesAll.size() +']');
		thisModule.umlInstancesConnectors.debug('Connectors ['+ thisModule.umlInstancesConnectors.size() +']');
		thisModule.umlInstancesBlocks.debug('Blocks ['+ thisModule.umlInstancesBlocks.size() +']');	
		thisModule.umlInstancesStereo.debug('Stereotypes [' + thisModule.umlInstancesStereo.size() + ']');
		thisModule.umlInstancesRelevant.debug('Relevant [' + thisModule.umlInstancesRelevant.size() + ']');
		thisModule.umlAllocations.debug('Allocations ['+ thisModule.umlAllocations.size() +']');
		--/DEBUG
		
		--Generate IM!Component elements, failure modes, and what can be done immediately
		for(i in thisModule.umlInstancesRelevant) {
			thisModule.InstanceToComponent(i);	
			
			if(i.getSBAStereotype().oclType() = CHESS!SimpleStochasticBehavior) {
				thisModule.SimpleStochasticBehaviorToComponent(i);
			}else if(i.getSBAStereotype().oclType() = CHESS!FLABehavior){
				thisModule.FLASpecificationToComponent(i);
			}else if(i.getSBAStereotype().oclType() = CHESS!ErrorModelBehavior) {
				thisModule.ErrorModelToComponent(i);
			}
		}
		
		--Generate external faults
		for(i in thisModule.umlInstancesRelevant) {
			thisModule.PopulateExternalFaults(i);	
		}
		
		--Generate FGE, i.e., connect external faults
		for(i in thisModule.umlInstancesRelevant) {
		}
	}
}

unique lazy rule InstanceToComponent {
	from
		inst : UML!InstanceSpecification
	to 
		c : IM!Component (
			Name <- inst.name
		)
}

--------------------------------------------------------------------
-- Rules to project component instances to IM!Component elements
--------------------------------------------------------------------

rule SimpleStochasticBehaviorToComponent(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!SimpleStochasticBehavior = inst.getSBAStereotype();
		tmpFailures : Set(TupleType(fm : String, p : Real)) = OclUndefined;
		tmpError : IM!Error = OclUndefined;
		tmpFailureMode : IM!FailureMode = OclUndefined;
		myFailureModes : String = if st.failureModesDistribution.oclIsUndefined() then '' else st.failureModesDistribution endif;
	}
	to
		fault : IM!InternalFault (
			Component <- c,
			Name <- inst.name + '_ift',
			PermanentProbability <- 1,
			Occurrence <- st.failureOccurrence.parseDistribution(),
			TransientDuration <- thisModule.Deterministic(0)
		)
	do {
		c.Faults = c.Faults.including(fault);
		
		for(slot in inst.getPortSlots()->select(p | p.hasOutputFlow())) {
			tmpFailures <- myFailureModes.parseFailureModesForPort(slot.name);
				
			tmpError <- thisModule.AddError('e_' + slot.name, c);
			for(fmSpec in tmpFailures) {
				thisModule.AddEPF(
					tmpError,
					thisModule.AddFailureMode(slot.name + '.' + fmSpec.fm, c),
					thisModule.Deterministic(0),
					1,
					fmSpec.p
				);
			}
		}
	}
}

rule FLASpecificationToComponent(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!FLABehavior = inst.getSBAStereotype();
		flaRules : Sequence(String) = st.fptc.regexReplaceAll('FLA:', ' ').trim().split(';');
		tmpLeft : String = OclUndefined;
		tmpRight : String = OclUndefined;
		tmpFailures : Sequence(String) = OclUndefined;
		errorMap : Map(String,IM!Error) = Map{};
		tmpError : IM!Error = OclUndefined;
		tmpEPF : IM!ErrorsProducesFailures = OclUndefined;
		j : Integer = 0;
	}
	
	do {
		--For every line of the FLA specification
		for(spec in flaRules) {
			j <- j+1;
			tmpError <- thisModule.AddError('e_'+j,c);
			tmpEPF <- thisModule.AddFLARuleEPF(tmpError);
			
			tmpRight <- spec.trim().split('->')->last().trim();			--Get right hand side
			tmpFailures <- tmpRight.split(',');							--Get the different failures in the right hand side
			
			--For every failure in the right side of the rule
			for(failure in tmpFailures) {
				--If it is not the 'noFailure' element
				if(failure.indexOf('.' + thisModule.flaNoFailure) = -1) {
					--If the failure mode does not exist already
					if(not c.hasFailureMode(failure)) {
						thisModule.AddFailureMode(failure, c);
					}
					
					tmpEPF.Destination <- tmpEPF.Destination->including(c.FailureModes->select(f | f.Name = failure)->first());
				}
			}
		}
	}		
}

rule ErrorModelToComponent(inst : UML!InstanceSpecification) {
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!ErrorModelBehavior = inst.getSBAStereotype();
		errorModel : CHESS!ErrorModel = st.errorModel->first();
		states : Sequence(UML!State) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(UML!State));
		pseudo : Sequence(CHESS!Pseudostate) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(CHESS!Pseudostate));
		transitions : Sequence(UML!Transition) = errorModel.base_StateMachine.ownedElement->first().ownedElement->select(e | e.oclIsKindOf(UML!Transition));
		tmpStereotype : OclAny = OclUndefined;
		tmpExternalFaults : String = OclUndefined;
	}
	do {	
		--Scan all CHESS!Failure elements in the error model,
		--to create the needed IM!FailureMode elements
		for(tr in transitions) {
			tmpStereotype <- tr.getFailureStereotype();
			if(not tmpStereotype.oclIsUndefined()) {
				for(f in tmpStereotype.mode) {
					--If it is not the 'noFailure' element
					if(f.indexOf('.' + thisModule.flaNoFailure) = -1) {
						--If the failure mode does not exist already
						if(not c.hasFailureMode(f)) {
							thisModule.AddFailureMode(f, c);
						}
					}
				}
			}
		}
		
		--Transform ErrorModel States
		for(s in states) {
			thisModule.ErrorModelStateToError(s,inst);
		}
		
		--Transform ErrorModel Pseudostates (choice)
		for(s in pseudo->select(p | p.kind = #choice)) {
			thisModule.ErrorModelStateToError(s,inst);
		}
		
		--Transform ErrorModel <<Failure>> Transitions
		for(tr in transitions) {
			tmpStereotype <- tr.getSBAStereotype();
			if(tmpStereotype.oclIsTypeOf(CHESS!Failure)) {		
				thisModule.AddEPFFromErrorModelFailure(tmpStereotype);
			}
		}
				
		--<<InternalFault>> become IM!InternalFault
		for(tr in transitions) {
			tmpStereotype <- tr.getSBAStereotype();
			if(tmpStereotype.oclIsTypeOf(CHESS!InternalFault)) {
				thisModule.InternalFault(tmpStereotype,inst);
			}
		}
		
		--Transform ErrorModel <<InternalPropagation>> Transitions,
		--but only those for which the 'externalFaults' attribute is empty.
		for(tr in transitions) {
			tmpStereotype <- tr.getSBAStereotype();
			if(tmpStereotype.oclIsTypeOf(CHESS!InternalPropagation)) {
				if(tmpStereotype.oclIsTypeOf(CHESS!InternalFault)) {
					--Do nothing (processed elsewhere)				
				}else{
					--Match <<InternalPropagation>> stereotype only
					tmpExternalFaults <- tmpStereotype.externalFaults;
					if(tmpExternalFaults.oclIsUndefined()) {
						thisModule.InternalPropagation(tmpStereotype,inst);
					}
				}
			}
		}
		
		--<<InternalPropagation>> that refer to external faults are processed later
		--This includes also those that originate from the InitialState
		
	}
}

--------------------------------------------------------------------
-- Rule to generate external faults for component instances
--------------------------------------------------------------------

rule PopulateExternalFaults(inst : UML!InstanceSpecification) {
	using {
		inPorts : Set(UML!Slot) = inst.getPortSlots()->select(p | p.hasInputFlow());
		faultName : String = OclUndefined;
		connPort : UML!Slot = OclUndefined;
		connComp : IM!Component = OclUndefined;
		tmpExternalFault : IM!ExternalFault = OclUndefined;
	}	
	do {
		for(p in inPorts) {
			--Find connected port
			connPort <- p.getSBAConnections()->first();
			--Find connected component (slot owner)
			connComp <- thisModule.InstanceToComponent(connPort.refImmediateComposite());
			
			for(f in connComp.FailureModes->select(fm | fm.Name.noNamespace(connComp.Name).startsWith(connPort.name + '.'))) {
				faultName <- f.Name.split('\\.')->last();
				tmpExternalFault <- thisModule.AddExternalFault(p.name + '.' + faultName, inst);
				tmpExternalFault.Source <- f;
			}
		}
	}
}

unique lazy rule AddExternalFault {
	from
		fault : String,
		inst : UML!InstanceSpecification
	to 
		xft : IM!ExternalFault (
			Component <- thisModule.InstanceToComponent(inst),
			Name <- inst.name + '_' + fault
		)
}

unique lazy rule ErrorModelStateToError {
	from 
		state : UML!Vertex,
		inst : UML!InstanceSpecification
	to
		err : IM!Error (
			Name <- inst.name + '_' + state.name,
			Component <- thisModule.InstanceToComponent(inst)
		)
}

unique lazy rule InternalFault {
	from
		chIntFault : CHESS!InternalFault,
		inst : UML!InstanceSpecification
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
	}
	to
		ift : IM!InternalFault (
			Name <- 'ift_' + c.Faults->select(f | f.oclIsKindOf(IM!InternalFault))->size()+1,
			Occurrence <- chIntFault.occurrence.parseDistribution(),
			PermanentProbability <- 1,
			Component <- c
		)
}

unique lazy rule InternalPropagation {
	from 
		chIntProp : CHESS!InternalPropagation,
		inst : UML!InstanceSpecification
	using {
		myDelay : String = if chIntProp.delay.oclIsUndefined() then 'det(0)' else chIntProp.delay endif;
		myWeight : Real = if chIntProp.weight.oclIsUndefined() then 1 else chIntProp.weight.toReal() endif;
	}
	to
		imIntProp : IM!InternalPropagation (
			Component <- thisModule.InstanceToComponent(inst),
			Name <- chIntProp.base_Transition.source.toString() + '_to_' + chIntProp.base_Transition.target.toString(),
			Source <- thisModule.ErrorModelStateToError(chIntProp.base_Transition.source),
			Destination <- thisModule.ErrorModelStateToError(chIntProp.base_Transition.target),
			PropagationProbability <- 1,
			PropagationDelay <- myDelay.parseDistribution(),
			Weight <- myWeight
		)
}

rule AddFailureMode(name : String, c : IM!Component) {
	to 
		fm : IM!FailureMode (
			Name <- c.Name + '_' + name
		)
	do {
		c.FailureModes <- c.FailureModes->append(fm);
	
		fm;
	}
}

rule AddError(name : String, c : IM!Component) {
	to
		e : IM!Error (
			Name <- c.Name + '_' + name,
			Component <- c
		)
	do {
		e;
	}
}

unique lazy rule AddEPFFromErrorModelFailure {
	from
		f : CHESS!Failure
	using {
		eSource : IM!Error = thisModule.ErrorModelStateToError(f.base_Transition.source);
		myDelay : String = if f.delay.oclIsUndefined() then 'det(0)' else f.delay endif;
		myWeight : Real = if f.weight.oclIsUndefined() then 1 else f.weight.toReal() endif;
	}
	to
		epf : IM!ErrorsProducesFailures (
			Name <- eSource.Name + '_to_' + f.mode,
			Source <- Sequence{eSource},
			Destination <- eSource.Component.FailureModes->select(fm | f.mode->includes(fm.Name)),
			Component <- eSource.Component,
			PropagationDelay <- myDelay.parseDistribution(),
			PropagationProbability <- 1,
			Weight <- myWeight
		)
	do {
		epf;
	}	
}

rule AddFLARuleEPF(e : IM!Error) {
	to
		epf : IM!ErrorsProducesFailures (
			Name <- e.Name + '_epf',
			Source <- Sequence{e},
			Destination <- Sequence{},
			Component <- e.Component,
			PropagationDelay <- thisModule.Deterministic(0),
			PropagationProbability <- 1,
			Weight <- 1
		)
	do{
		epf;
	}
}

rule AddEPF(e : IM!Error, fm : IM!FailureMode, delay : IM!Distribution, p : Real, weight : Real) {
	to 
		epf : IM!ErrorsProducesFailures (
			Name <- e.Name + '_to_' + fm.Name,
			Component <-fm.Component,
			Source <- Set{e},
			Destination <- Set{fm},
			PropagationDelay <- delay,
			PropagationProbability <- p,
			Weight <- weight
		)
}

rule AddSourceError(fm : IM!FailureMode) {
	using {
		c : IM!Component = fm.Component;
	}
	to 
		e : IM!Error (
			Name <- c.Name + '_e_' + fm.Name,
			Component <- c
		),
		epf : IM!ErrorsProducesFailures (
			Source <- Set{e},
			Destination <- Set{fm},
			Component <- c
		)
}

--------------------------------------------------------------------
-- Rules to create IM!Distribution elements
--------------------------------------------------------------------
lazy rule Exponential {
	from
		lambda : Real
	to
		e : IM!Exponential ( Rate <- lambda )
}

lazy rule Deterministic {
	from
		value : Real
	to
		d : IM!Deterministic ( Value <- value )
}

lazy rule Uniform {
	from
		lower : Real,
		upper : Real
	to
		d : IM!Uniform ( 
			Lower <- lower,
			Upper <- upper
		)
}

lazy rule Gaussian {
	from
		mean : Real,
		variance : Real
	to 
		g : IM!Gaussian (
			Mean <- mean,
			Variance <- variance
		)
}

lazy rule Gamma {
	from
		a : Real,
		b : Real
	to 
		g : IM!Gamma (
			Alpha <- a,
			Beta <- b
		)
}

lazy rule Weibull {
	from
		a : Real,
		b : Real
	to 
		g : IM!Weibull (
			Alpha <- a,
			Beta <- b
		)
}

--Check if a IM!Component already contains a specific failure mode
helper context IM!Component def: hasFailureMode(fm : String) : Boolean =
	not self.FailureModes->select(f | f.Name.noNamespace(self.Name).trim() = fm.trim())->isEmpty();

--Check if a IM!Component already contains a specific fault
helper context IM!Component def: hasFault(fm : String) : Boolean =
	not self.Faults->select(f | f.Name.noNamespace(self.Name).trim() = fm.trim())->isEmpty();

--Get <<Failure>> stereotype from a Transition
helper context UML!Transition def: getFailureStereotype() : CHESS!Failure =
	CHESS!Failure.allInstances()->select(f | f.base_Transition = self)->first();

--Get <<ErrorState>> stereotype from a State
helper context UML!State def: getErrorStateStereotype() : CHESS!ErrorState =
	CHESS!ErrorState.allInstances()->select(e | e.base_State = self)->first();

--Check if a Vertex is an initial state (healty state of the error model)
helper context UML!Vertex def: isInitialState() : Boolean =
	if(self.oclIsKindOf(CHESS!Pseudostate)) then
		self.kind = #initial
	else
		false
	endif;

--Remove the component name
helper context String def: noNamespace(n : String) : String =
	self.regexReplaceAll(n + '_', '');
	

--------------------------------------------------------------------
-- Parse strings in VSL notation into IM!Distribution elements
--------------------------------------------------------------------
helper context String def: parseDistribution() : IM!Distribution = 
	let dist : String = self.trim().toLower() in
	if dist.startsWith('exp') then
		dist.parseExponential()
	else if dist.startsWith('det') then
		dist.parseDeterministic()
	else if dist.startsWith('uni') then
		dist.parseUniform()
	else if dist.startsWith('norm') or dist.startsWith('gauss') then
		dist.parseGaussian()
	else if dist.startsWith('gam') then
		dist.parseGamma()
	else if dist.startsWith('wei') then
		dist.parseWeibull()
	else
		thisModule.Exponential(0)
	endif endif endif endif endif endif;

helper context String def: parseExponential() : IM!Exponential =
	thisModule.Exponential(self.substring(self.indexOf('(')+2, self.indexOf(')')).toReal());

helper context String def: parseDeterministic() : IM!Deterministic =
	thisModule.Deterministic(self.substring(self.indexOf('(')+2, self.indexOf(')')).toReal());

helper context String def: parseUniform() : IM!Uniform =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Uniform(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseGaussian() : IM!Gaussian =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Gaussian(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseGamma() : IM!Gamma =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Gamma(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseWeibull() : IM!Gamma =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Weibull(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

--------------------------------------------------------------------
-- Collections that are used to filter and categorize model elements
--------------------------------------------------------------------
helper def : Instances : Sequence(UML2!InstanceSpecification) = Sequence {};
helper def : Connectors : Set(UML2!InstanceSpecification) = Set {};
helper def : Comments : Set (UML2!Comment) = Set {};
helper def : Ports : Set (UML2!Port) = Set {};
helper def : States : Set(UML2!State) = Set{};
helper def : Transitions : Set(UML2!Tansition) = Set{};

helper context UML!InstanceSpecification def: getBaseItem() : UML!Classifier = self.classifier->first();

--Find the SimpleStochasticBehavior element associated with a Classifier or an InstanceSpecification
--if it exists. Returns OclUndefined otherwise
helper context UML!Classifier def: getSimpleStochasticBehavior() : CHESS!SimpleStochasticBehavior =
	CHESS!SimpleStochasticBehavior->allInstances()->select(ssb | ssb.base_Class = self)->first();

helper context UML!InstanceSpecification def: getSimpleStochasticBehavior() : CHESS!SimpleStochasticBehavior =
	let instssb : CHESS!SimpleStochasticBehavior = 
		CHESS!SimpleStochasticBehavior->allInstances()->select(ssb | ssb.base_InstanceSpecification = self)->first() in
	if instssb <> OclUndefined then instssb else 
		let base : UML!Class = self.getBaseItem() in 
			if base = OclUndefined then base else base.getSimpleStochasticBehavior() endif
	endif;

--------------------------------------------------------------------
-- Helpers to get dependability information from stereotypes
--------------------------------------------------------------------
	
--Do we have dependability information for this instance?
helper context UML!InstanceSpecification def: hasSBAInformation() : Boolean = self.getSBAStereotype() <> OclUndefined;

--If the InstanceSpecification has its own stereotype then return it,
-- otherwise return the one of the classifier
helper context UML!InstanceSpecification def: getSBAStereotype() : OclAny = 
	let s : OclAny = self.getSBAStereotypeInstance() in
	if s = OclUndefined then self.classifier->first().getSBAStereotypeClassifier() else s endif;

--Get the SBA stereotype applied to the instance, if any
helper context UML!InstanceSpecification def: getSBAStereotypeInstance() : OclAny =
	thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten()->select(st | st.base_InstanceSpecification = self)->first();

--Find the CHESS stereotype that is used on a given instance specification, or on its classifier
helper context UML!Class def: getSBAStereotypeClassifier() : OclAny =
	thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten()->select(st | st.base_Class = self)->first();

--Recursive helper to identify which instances need to be taken into account,
--i.e., to identify those that have dependability information attached, or no
--subinstances
helper context UML!InstanceSpecification  def: findSBAConstituents() : Set(UML!InstanceSpecification) =
	if self.hasSBAInformation() or self.getSubInstances().isEmpty() then
		Set{self}
	else
		self.getSubInstances()->collect(i | i.findSBAConstituents())->flatten()
	endif;

--Get the stereotype associated to an error model transition
helper context UML!Transition def: getSBAStereotype() : OclAny =
	thisModule.sbaTransitions->collect(s | s.allInstances())->
								flatten()->select(t | t.base_Transition = self)->
								first();

--Does this error model transition has dependability information associated with it?
helper context UML!Transition def: hasSBAInformation() : Boolean = not self.getSBAStereotype().oclIsUndefined();

--------------------------------------------------------------------
-- Helpers to get, start from a given InstanceSpecification,
-- port instances and subcomponent instances
--------------------------------------------------------------------
helper context UML!InstanceSpecification def: getPortSlots() : Set(UML!Slot) = 
	self.slot->select(s | s.definingFeature.oclIsKindOf(UML!Port));

helper context UML!InstanceSpecification def: getSubInstanceSlots() : Set(UML!Slot) =
	self.slot->select(s | not s.definingFeature.oclIsKindOf(UML!Port));

helper context UML!InstanceSpecification def: getSubInstances() : Set(UML!InstanceSpecification) = 
	self.getSubInstanceSlots()->collect(s | s.value->first().instance);

helper context UML!InstanceSpecification def: isSubInstanceOf(parent : UML!InstanceSpecification) : Boolean =
	parent.getSubInstances()->includes(self);

--Get the name of a port slot, as the name of the originating port
helper context UML!Slot def: name : String = self.definingFeature.name;
 
--helper context UML!Slot def: getConnectedSlotsInput() : Set(UML!Slot) =
--	self;
--helper context UML!Slot def: getConnectedSlotsOutput() : Set(UML!Slot) = 
--	self;
--helper context UML!Slot def: getConnectedSlots() : Set(UML!Slot) =
--	self.getConnectedSlotsInput->union(self.getConnectedSlotsOutput);

--------------------------------------------------------------------
-- Check if a Port (or Slot) has input or output dataflow
--------------------------------------------------------------------
helper context UML!Slot def: hasInputFlow() : Boolean = self.definingFeature.hasInputFlow();
helper context UML!Slot def: hasOutputFlow() : Boolean = self.definingFeature.hasOutputFlow();
helper context UML!Port def: hasInputFlow() : Boolean =
	let clientserverport : MARTE!ClientServerPort = MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first() in
	let flowport : SYSML!FlowPort = SYSML!FlowPort.allInstances()->select(c | c.base_Port = self)->first() in
	if clientserverport <> OclUndefined then clientserverport.hasInputFlow() else
		if flowport <> OclUndefined then flowport.hasInputFlow() else
			false
	endif endif;
helper context UML!Port def: hasOutputFlow() : Boolean =
	let clientserverport : MARTE!ClientServerPort = MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first() in
	let flowport : SYSML!FlowPort = SYSML!FlowPort.allInstances()->select(c | c.base_Port = self)->first() in
	if clientserverport <> OclUndefined then clientserverport.hasOutputFlow() else
		if flowport <> OclUndefined then flowport.hasOutputFlow() else
			false
	endif endif;
helper context SYSML!FlowPort def: hasInputFlow() : Boolean = self.direction <> #out;
helper context SYSML!FlowPort def: hasOutputFlow() : Boolean = self.direction = #out or self.direction = #inout;
helper context MARTE!ClientServerPort def: hasInputFlow() : Boolean = self.kind <> #provided;
helper context MARTE!ClientServerPort def: hasOutputFlow() : Boolean = self.kind <> #required;

--------------------------------------------------------------------
-- Helpers to explore the model and get the component that is
-- connected to the other side of a port
--------------------------------------------------------------------

--Get connectors that are linked to a certain port instance
helper context UML!Slot def: getConnectors() : Set(UML!InstanceSpecification) =
	thisModule.umlInstancesConnectors->
				select(c | not c.slot->select(s | s.definingFeature = self.definingFeature 
					and s.value->first().instance = self.refImmediateComposite())->isEmpty());

--Is the connector instance a "normal" connection
--betweentwo components at the same level?
helper context UML!InstanceSpecification def: isConnection() : Boolean = 
	let sl : OrderedSet(UML!Slot) = self.slot->asOrderedSet() in
	let i1 : UML!InstanceSpecification = sl->first().value->first().instance in
	let i2 : UML!InstanceSpecification = sl->last().value->first().instance in
	not i1.isSubInstanceOf(i2) and not i2.isSubInstanceOf(i1);

--Is the connector instance a delegation?
helper context UML!InstanceSpecification def: isDelegation() : Boolean = 
	let sl : OrderedSet(UML!Slot) = self.slot->asOrderedSet() in
	let i1 : UML!InstanceSpecification = sl->first().value->first().instance in
	let i2 : UML!InstanceSpecification = sl->last().value->first().instance in
	i1.isSubInstanceOf(i2) or i2.isSubInstanceOf(i1);

--Get port instances that are *directly* connected to a certain port instance
helper context UML!Slot def: getConnectedImmediate() : Set(UML!Slot) =
	let connectorsSlots : Set(UML!Slot) = 
	self.getConnectors()->select(c | c.isConnection())->
							collect(c | c.slot)->
							flatten()->
							select(s | s.definingFeature <> self.definingFeature)
	in
	connectorsSlots->collect(s | s.value->first().instance.slot->
									select(sl | sl.definingFeature = s.definingFeature))->flatten();

--Get port instances that receive/send delegation from/to a certain port instance
helper context UML!Slot def: getDelegationEnds() : Set(UML!Slot) =
	let connectorsSlots : Set(UML!Slot) =
	self.getConnectors()->select(c | c.isDelegation())->
							collect(c | c.slot)->
							flatten()->
							select(s | s.definingFeature <> self.definingFeature)
	in
	connectorsSlots->collect(s | s.value->first().instance.slot->
									select(sl | sl.definingFeature = s.definingFeature))->flatten();

--Get taget(s) of delegation in sub-instances
helper context UML!Slot def: getDelegationEndsDownwards() : Set(UML!Slot) = 
	self.getDelegationEnds()->select(s | s.refImmediateComposite().isSubInstanceOf(self.refImmediateComposite()));

--Get source(s) of delegation in parent instance
helper context UML!Slot def: getDelegationEndsUpwards() : Set(UML!Slot) = 
	self.getDelegationEnds()->select(s | self.refImmediateComposite().isSubInstanceOf(s.refImmediateComposite()));

--Get the target of delegation taking into account SBA stereotypes,
--i.e., get the first slot whose owning instnace has SBA information.
--(it can be even the slot under examination itself)
helper context UML!Slot def: getSBADelegations() : Set(UML!Slot) =
	let inst : UML!InstanceSpecification = self.refImmediateComposite() in
	let deleg : Set(UML!Slot) = self.getDelegationEndsDownwards() in
	if deleg.isEmpty() or 
		inst.hasSBAInformation() or 
		inst.getSubInstances().isEmpty() 
	then
		Set{self} 
	else
		deleg->collect(e | e.getSBADelegations())->flatten()
	endif;

--Get the target of connection taking into account SBA stereotypes,
--i.e., get the first slot whose owning instance has SBA information.
--(it can be even the slot directly connected to the one under examination)
helper context UML!Slot def: getSBAConnections() : Set(UML!Slot) =
	self.getConnectedImmediate()->collect(sl | sl.getSBADelegations())->flatten();	

--------------------------------------------------------------------
-- Parse failure modes for SimpleStochasticBehavior elements
--------------------------------------------------------------------

--Split the specification into different parts, one for each port, and find the
--failure modes for the port name passed as input. Calls parseFailureModes() below
helper context String def: parseFailureModesForPort(port : String) : Set(TupleType(fm: String, p: Real)) =
	let strSeq : Sequence(String) = self.trim()->split(';') in
	let strSelected : String = strSeq->select(s | s.trim().startsWith(port))->first() in
	if strSelected = OclUndefined then
		strSeq->first().parseFailureModes()
	else 
		strSelected.parseFailureModes()
	endif;

--From the specification in string format get the failure modes and proabilities for a single port
helper context String def: parseFailureModes() : Set(TupleType(fm: String, p: Real)) =
	let str : String = 
		if self.indexOf('{') < 0 then
			self.trim()
		else
			self.substring(self.indexOf('{')+2, self.size()).replaceAll('}', ' ').trim()
		endif	
	in
	let default : Set(TupleType(fm: String, p: Real)) = Set{Tuple{fm = 'failure', p = 1.0}} in
	if str.size() = 0 then
		default
	else
		let ret : Set(TupleType(fm: String, p: Real)) = 
		str.split(',')->collect(s | s.split(':'))->
			collect(seq | Tuple{fm = seq->first().trim(), p = seq.last().toReal()})
		in
		if ret->isEmpty() then
			default
		else
			ret
	endif endif;

--------------------------------------------------------------------
-- For debugging purposes: pretty print SBA stereotypes
--------------------------------------------------------------------
helper context CHESS!SimpleStochasticBehavior def: toString() : String = 
	'<<SimpleStochasticBehavior>>(' + self.failureOccurrence + ', ' + self.repairDelay + ', ' + self.failureModesDistribution + ')';
helper context CHESS!FLABehavior def: toString() : String = '<<FLABehavior>>(' + self.fptc + ')';
helper context CHESS!ErrorModelBehavior def: toString() : String = '<<ErrorModelBehavior>>(' + self.errorModel + ')';
helper context CHESS!ErrorModel def: toString() : String = '<<ErrorModel>>(' + self.base_StateMachine + ')';





