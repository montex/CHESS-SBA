-- @path IM=/org.chess.statebased/metamodels/IM2.ecore
-- @path CHESS=/org.polarsys.chess.chessmlprofile/model/chessmlprofile.ecore
-- @nsURI MARTE=http://www.eclipse.org/papyrus/MARTE/1
-- @nsURI UML=http://www.eclipse.org/uml2/4.0.0/UML
-- @nsURI CHESS=http://CHESS
-- @nsURI SYSML=http://www.eclipse.org/papyrus/0.7.0/SysML

module CHESS2IM;
create OUT : IM from IN1 : CHESS, IN2 : MARTE, IN3 : UML, IN4 : SYSML;

helper def: umlInstancesAll : Sequence(UML!InstanceSpecification) = Sequence{}; 	--All the InstanceSpecification of the considered platform
helper def: umlInstancesConnectors : Set(UML!InstanceSpecification) = Set{};		--Instances of connectors
helper def: umlInstancesBlocks : Set(UML!InstanceSpecification) = Set{}; 			--Instances of components/blocks
helper def: umlInstancesStereo : Set(UML!InstanceSpecification) = Set{}; 			--Instances that have dependability information
helper def: umlInstancesRelevant : Set(UML!InstanceSpecification) = Set{}; 			--Instances that are relevant for the analysis
helper def: umlAllocations : Set(MARTE!Assign) = Set{};

--Stereotypes that can be used on Blocks/Components for state based analysis
helper def: sbaStereotypes : Sequence(OclAny) = Sequence{CHESS!SimpleStochasticBehavior, CHESS!FLABehavior, CHESS!ErrorModelBehavior, CHESS!DependableComponent,
														 CHESS!StatelessSoftware, CHESS!StatefulSoftware, CHESS!StatelessHardware, CHESS!StatefulHardware};

--rule to transform the CHESS!StateBasedAnalysis into an IM!Sistema
rule System {

	from
		sba : CHESS!StateBasedAnalysis
		--at the moment is it implied that there is only a StateBasedAnalysis in the model
	using {
		platform : UML!Package = sba.platform->first().base_Package;
		instances : Sequence(UML!InstanceSpecification) = UML!InstanceSpecification.allInstances()->select(i | i.refImmediateComposite() = platform);
		comments : Sequence(UML!Comment) = instances->collect(i | i.ownedComment)->flatten();
		instSystem : UML!InstanceSpecification = instances->first();
	} 
	to
		s : IM!Sistema (
			Name <- sba.base_StructuredClassifier.name
		)
	do {
		--Filter out and categorize relevant CHESS elements
		thisModule.umlInstancesAll <- instances;
		thisModule.umlInstancesConnectors <- instances->select(i | i.classifier.isEmpty());
		thisModule.umlInstancesBlocks <- instances->select(i | not i.classifier.isEmpty());
		thisModule.umlAllocations <- MARTE!Assign.allInstances()->select(a | comments.includes(a.base_Comment));
		
		thisModule.umlInstancesBlocks <- thisModule.umlInstancesAll->select(i | thisModule.umlInstancesConnectors.excludes(i));
		thisModule.umlInstancesStereo <- thisModule.umlInstancesBlocks->select(i | i.getSBAStereotype() <> OclUndefined);

		thisModule.umlInstancesRelevant <- instSystem.findSBAConstituents();
		
		
		--thisModule.umlInstancesStereo <- thisModule.umlInstancesBlocks;

--		for(i in thisModule.umlInstancesStereo) {
--			i.debug('i->');
--			i.getSBAStereotype().toString().debug('stereotype: ');
--			i.slot->collect(sl | sl.definingFeature.name).debug('slots: ');
--			i.getSubInstances().debug('sub instances');
--
--			i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))->collect(s | s.hasInputFlow()).debug('is input: ');
--			i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))->collect(s | s.hasOutputFlow()).debug('is output: ');	
--			
--			for(p in i.slot->select(sl | sl.definingFeature.oclIsKindOf(UML!Port))) {
--				p.definingFeature.name.debug('>>');
--				p.hasInputFlow().debug('input? ');
--				p.hasOutputFlow().debug('output? ');
--				
--				thisModule.umlInstancesConnectors.debug();
--				thisModule.umlInstancesConnectors->collect(c | c.slot).debug();
--				
--				p.getConnectors().debug('getConnectors');
--				p.getConnectors()->collect(c | c.isConnection()).debug('isConnection');
--				p.getConnectors()->collect(c | c.isDelegation()).debug('isDelegation');
--				p.getConnectedImmediate()->collect(i|i.definingFeature.name).debug('getConnectedImmediate');
--				p.getDelegationEnds()->collect(i|i.definingFeature.name).debug('getDelegationEnds');
--				p.getDelegationEndsDownwards()->collect(i|i.definingFeature.name).debug('getDelegationEndsDownwards');
--				p.getDelegationEndsUpwards()->collect(i|i.definingFeature.name).debug('getDelegationEndsUpwards');
--				p.getSBADelegations()->collect(i|i.definingFeature.name).debug('getSBADelegations');
--				p.getSBAConnections()->collect(i|i.definingFeature.name).debug('getSBAConnections');
--				thisModule.umlInstancesConnectors->select(c | not c.slot->select(s | s.definingFeature = p.definingFeature and s.value->first().instance = i)->isEmpty()).debug();
--				thisModule.umlInstancesConnectors->collect(c | c.slot->collect(s | s.value->first().instance)).debug('conns');
--				
--			}
--			thisModule.debug('------------------------');
--		}
--		thisModule.umlInstancesStereo.debug();
--		UML!InstanceSpecification.allInstances()->collect(i | i.getSimpleStochasticBehavior().debug('##'));
----		
----		
----		UML!InstanceSpecification.allInstances()->collect(i | CHESS!SimpleStochasticBehavior.allInstances()->exists(ssb | ssb.base_Class = i.getBaseItem()).debug());
----	
----		thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten();
--
----helper context UML!Port def: isInputPort : Boolean =
----MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first().kind 
--
--		MARTE!ClientServerPort.allInstances()->collect(p | p.kind).debug();
--		SYSML!FlowPort.allInstances()->collect(p | p.hasInputFlow()).debug();
--		UML!Port.allInstances()->collect(p | p.hasInputFlow()).debug();

		--DEBUG: Print the obtained sets
		thisModule.umlInstancesAll.debug('Instances ['+ thisModule.umlInstancesAll.size() +']');
		thisModule.umlInstancesConnectors.debug('Connectors ['+ thisModule.umlInstancesConnectors.size() +']');
		thisModule.umlInstancesBlocks.debug('Blocks ['+ thisModule.umlInstancesBlocks.size() +']');	
		thisModule.umlInstancesStereo.debug('Stereotypes [' + thisModule.umlInstancesStereo.size() + ']');
		thisModule.umlInstancesRelevant.debug('Relevant [' + thisModule.umlInstancesRelevant.size() + ']');
		thisModule.umlAllocations.debug('Allocations ['+ thisModule.umlAllocations.size() +']');
		--/DEBUG
		
		for(i in thisModule.umlInstancesRelevant) {
			thisModule.InstanceToComponent(i);
			
			if(i.getSBAStereotype().oclType() = CHESS!SimpleStochasticBehavior) {
				thisModule.SimpleStochasticBehaviorToComponent(i);
			}
		}
	}
}

unique lazy rule InstanceToComponent {
	from
		inst : UML!InstanceSpecification
	to 
		c : IM!Component (
			Name <- inst.name
		)
}

unique lazy rule SimpleStochasticBehaviorToComponent {
	from
		inst : UML!InstanceSpecification
	using {
		c : IM!Component = thisModule.InstanceToComponent(inst);
		st : CHESS!SimpleStochasticBehavior = inst.getSBAStereotype();
		tmpFailures : Set(TupleType(fm : String, p : Real)) = OclUndefined;
	}
	to
		fault : IM!InternalFault (
			Component <- c,
			Name <- inst.name + '_ift',
			PermanentProbability <- 1,
			Occurrence <- st.failureOccurrence.parseDistribution(),
			TransientDuration <- thisModule.Deterministic(0)
		)
	do {
		c.Faults = c.Faults.including(fault);
		
		for(slot in inst.getPortSlots()->select(p | p.hasOutputFlow())) {
			slot.name.debug();	
			tmpFailures <- st.failureModesDistribution.parseFailureModesForPort(slot.name);
			
	
			---------------------WORKING HERE
			tmpFailures.debug();
			
			for(fmSpec in tmpFailures) {
				thisModule.AddFailureMode(slot.name + '.' + fmSpec.fm, c);
			}
		}
		
--		thisModule.AddSourceError(
--			thisModule.AddFailureMode('f', c)
--		);
	}
}

rule AddFailureMode(name : String, c : IM!Component) {
	to 
		fm : IM!FailureMode (
			Name <- name
		)
	do {
		c.FailureModes <- c.FailureModes->append(fm);
--		thisModule.AddSourceError(fm);
--		
		fm;
	}
}

unique lazy rule AddSourceError {
	from 
		fm : IM!FailureMode
	using {
		c : IM!Component = fm.Component;
	}
	to 
		e : IM!Error (
			Name <- 'e_' + fm.Name,
			Component <- c
		),
		epf : IM!ErrorsProducesFailures (
			Source <- Set{e},
			Destination <- Set{fm},
			Component <- c
		)
}

--------------------------------------------------------------------
-- Rules to create IM!Distribution elements
--------------------------------------------------------------------
lazy rule Exponential {
	from
		lambda : Real
	to
		e : IM!Exponential ( Rate <- lambda )
}

lazy rule Deterministic {
	from
		value : Real
	to
		d : IM!Deterministic ( Value <- value )
}

lazy rule Uniform {
	from
		lower : Real,
		upper : Real
	to
		d : IM!Uniform ( 
			Lower <- lower,
			Upper <- upper
		)
}

lazy rule Gaussian {
	from
		mean : Real,
		variance : Real
	to 
		g : IM!Gaussian (
			Mean <- mean,
			Variance <- variance
		)
}

lazy rule Gamma {
	from
		a : Real,
		b : Real
	to 
		g : IM!Gamma (
			Alpha <- a,
			Beta <- b
		)
}

lazy rule Weibull {
	from
		a : Real,
		b : Real
	to 
		g : IM!Weibull (
			Alpha <- a,
			Beta <- b
		)
}

--------------------------------------------------------------------
-- Parse strings in VSL notation into IM!Distribution elements
--------------------------------------------------------------------
helper context String def: parseDistribution() : IM!Distribution = 
	let dist : String = self.trim().toLower() in
	if dist.startsWith('exp') then
		dist.parseExponential()
	else if dist.startsWith('det') then
		dist.parseDeterministic()
	else if dist.startsWith('uni') then
		dist.parseUniform()
	else if dist.startsWith('norm') or dist.startsWith('gauss') then
		dist.parseGaussian()
	else if dist.startsWith('gam') then
		dist.parseGamma()
	else if dist.startsWith('wei') then
		dist.parseWeibull()
	else
		thisModule.Exponential(0)
	endif endif endif endif endif endif;

helper context String def: parseExponential() : IM!Exponential =
	thisModule.Exponential(self.substring(self.indexOf('(')+2, self.indexOf(')')).toReal());

helper context String def: parseDeterministic() : IM!Deterministic =
	thisModule.Deterministic(self.substring(self.indexOf('(')+2, self.indexOf(')')).toReal());

helper context String def: parseUniform() : IM!Uniform =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Uniform(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseGaussian() : IM!Gaussian =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Gaussian(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseGamma() : IM!Gamma =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Gamma(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

helper context String def: parseWeibull() : IM!Gamma =
	let iComma : Integer = self.indexOf(',') in
	thisModule.Weibull(
		self.substring(self.indexOf('(')+2, iComma).toReal(),
		self.substring(iComma+2, self.indexOf(')')).toReal()
	);

--------------------------------------------------------------------
-- Collections that are used to filter and categorize model elements
--------------------------------------------------------------------
helper def : Instances : Sequence(UML2!InstanceSpecification) = Sequence {};
helper def : Connectors : Set(UML2!InstanceSpecification) = Set {};
helper def : Comments : Set (UML2!Comment) = Set {};
helper def : Ports : Set (UML2!Port) = Set {};
helper def : States : Set(UML2!State) = Set{};
helper def : Transitions : Set(UML2!Tansition) = Set{};

helper context UML!InstanceSpecification def: getBaseItem() : UML!Classifier = self.classifier->first();

--Find the SimpleStochasticBehavior element associated with a Classifier or an InstanceSpecification
--if it exists. Returns OclUndefined otherwise
helper context UML!Classifier def: getSimpleStochasticBehavior() : CHESS!SimpleStochasticBehavior =
	CHESS!SimpleStochasticBehavior->allInstances()->select(ssb | ssb.base_Class = self)->first();

helper context UML!InstanceSpecification def: getSimpleStochasticBehavior() : CHESS!SimpleStochasticBehavior =
	let instssb : CHESS!SimpleStochasticBehavior = 
		CHESS!SimpleStochasticBehavior->allInstances()->select(ssb | ssb.base_InstanceSpecification = self)->first() in
	if instssb <> OclUndefined then instssb else 
		let base : UML!Class = self.getBaseItem() in 
			if base = OclUndefined then base else base.getSimpleStochasticBehavior() endif
	endif;

--------------------------------------------------------------------
-- Helpers to get dependability information from stereotypes
--------------------------------------------------------------------
	
--Do we have dependability information for this instance?
helper context UML!InstanceSpecification def: hasSBAInformation() : Boolean = self.getSBAStereotype() <> OclUndefined;

--If the InstanceSpecification has its own stereotype then return it,
-- otherwise return the one of the classifier
helper context UML!InstanceSpecification def: getSBAStereotype() : OclAny = 
	let s : OclAny = self.getSBAStereotypeInstance() in
	if s = OclUndefined then self.classifier->first().getSBAStereotypeClassifier() else s endif;

--Get the SBA stereotype applied to the instance, if any
helper context UML!InstanceSpecification def: getSBAStereotypeInstance() : OclAny =
	thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten()->select(st | st.base_InstanceSpecification = self)->first();

--Find the CHESS stereotype that is used on a given instance specification, or on its classifier
helper context UML!Class def: getSBAStereotypeClassifier() : OclAny =
	thisModule.sbaStereotypes->collect(s | s.allInstances())->flatten()->select(st | st.base_Class = self)->first();

--Recursive helper to identify which instances need to be taken into account,
--i.e., to identify those that have dependability information attached, or no
--subinstances
helper context UML!InstanceSpecification  def: findSBAConstituents() : Set(UML!InstanceSpecification) =
	if self.hasSBAInformation() or self.getSubInstances().isEmpty() then
		Set{self}
	else
		self.getSubInstances()->collect(i | i.findSBAConstituents())->flatten()
	endif;

--------------------------------------------------------------------
-- Helpers to get, start from a given InstanceSpecification,
-- port instances and subcomponent instances
--------------------------------------------------------------------
helper context UML!InstanceSpecification def: getPortSlots() : Set(UML!Slot) = 
	self.slot->select(s | s.definingFeature.oclIsKindOf(UML!Port));

helper context UML!InstanceSpecification def: getSubInstanceSlots() : Set(UML!Slot) =
	self.slot->select(s | not s.definingFeature.oclIsKindOf(UML!Port));

helper context UML!InstanceSpecification def: getSubInstances() : Set(UML!InstanceSpecification) = 
	self.getSubInstanceSlots()->collect(s | s.value->first().instance);

helper context UML!InstanceSpecification def: isSubInstanceOf(parent : UML!InstanceSpecification) : Boolean =
	parent.getSubInstances()->includes(self);

--Get the name of a port slot, as the name of the originating port
helper context UML!Slot def: name : String = self.definingFeature.name;
 
--helper context UML!Slot def: getConnectedSlotsInput() : Set(UML!Slot) =
--	self;
--helper context UML!Slot def: getConnectedSlotsOutput() : Set(UML!Slot) = 
--	self;
--helper context UML!Slot def: getConnectedSlots() : Set(UML!Slot) =
--	self.getConnectedSlotsInput->union(self.getConnectedSlotsOutput);

--------------------------------------------------------------------
-- Check if a Port (or Slot) has input or output dataflow
--------------------------------------------------------------------
helper context UML!Slot def: hasInputFlow() : Boolean = self.definingFeature.hasInputFlow();
helper context UML!Slot def: hasOutputFlow() : Boolean = self.definingFeature.hasOutputFlow();
helper context UML!Port def: hasInputFlow() : Boolean =
	let clientserverport : MARTE!ClientServerPort = MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first() in
	let flowport : SYSML!FlowPort = SYSML!FlowPort.allInstances()->select(c | c.base_Port = self)->first() in
	if clientserverport <> OclUndefined then clientserverport.hasInputFlow() else
		if flowport <> OclUndefined then flowport.hasInputFlow() else
			false
	endif endif;
helper context UML!Port def: hasOutputFlow() : Boolean =
	let clientserverport : MARTE!ClientServerPort = MARTE!ClientServerPort.allInstances()->select(c | c.base_Port = self)->first() in
	let flowport : SYSML!FlowPort = SYSML!FlowPort.allInstances()->select(c | c.base_Port = self)->first() in
	if clientserverport <> OclUndefined then clientserverport.hasOutputFlow() else
		if flowport <> OclUndefined then flowport.hasOutputFlow() else
			false
	endif endif;
helper context SYSML!FlowPort def: hasInputFlow() : Boolean = self.direction <> #out;
helper context SYSML!FlowPort def: hasOutputFlow() : Boolean = self.direction = #out or self.direction = #inout;
helper context MARTE!ClientServerPort def: hasInputFlow() : Boolean = self.kind <> #provided;
helper context MARTE!ClientServerPort def: hasOutputFlow() : Boolean = self.kind <> #required;

--------------------------------------------------------------------
-- Helpers to explore the model and get the component that is
-- connected to the other side of a port
--------------------------------------------------------------------

--Get connectors that are linked to a certain port instance
helper context UML!Slot def: getConnectors() : Set(UML!InstanceSpecification) =
	thisModule.umlInstancesConnectors->
				select(c | not c.slot->select(s | s.definingFeature = self.definingFeature 
					and s.value->first().instance = self.refImmediateComposite())->isEmpty());

--Is the connector instance a "normal" connection
--betweentwo components at the same level?
helper context UML!InstanceSpecification def: isConnection() : Boolean = 
	let sl : OrderedSet(UML!Slot) = self.slot->asOrderedSet() in
	let i1 : UML!InstanceSpecification = sl->first().value->first().instance in
	let i2 : UML!InstanceSpecification = sl->last().value->first().instance in
	not i1.isSubInstanceOf(i2) and not i2.isSubInstanceOf(i1);

--Is the connector instance a delegation?
helper context UML!InstanceSpecification def: isDelegation() : Boolean = 
	let sl : OrderedSet(UML!Slot) = self.slot->asOrderedSet() in
	let i1 : UML!InstanceSpecification = sl->first().value->first().instance in
	let i2 : UML!InstanceSpecification = sl->last().value->first().instance in
	i1.isSubInstanceOf(i2) or i2.isSubInstanceOf(i1);

--Get port instances that are *directly* connected to a certain port instance
helper context UML!Slot def: getConnectedImmediate() : Set(UML!Slot) =
	let connectorsSlots : Set(UML!Slot) = 
	self.getConnectors()->select(c | c.isConnection())->
							collect(c | c.slot)->
							flatten()->
							select(s | s.definingFeature <> self.definingFeature)
	in
	connectorsSlots->collect(s | s.value->first().instance.slot->
									select(sl | sl.definingFeature = s.definingFeature))->flatten();

--Get port instances that receive/send delegation from/to a certain port instance
helper context UML!Slot def: getDelegationEnds() : Set(UML!Slot) =
	let connectorsSlots : Set(UML!Slot) =
	self.getConnectors()->select(c | c.isDelegation())->
							collect(c | c.slot)->
							flatten()->
							select(s | s.definingFeature <> self.definingFeature)
	in
	connectorsSlots->collect(s | s.value->first().instance.slot->
									select(sl | sl.definingFeature = s.definingFeature))->flatten();

--Get taget(s) of delegation in sub-instances
helper context UML!Slot def: getDelegationEndsDownwards() : Set(UML!Slot) = 
	self.getDelegationEnds()->select(s | s.refImmediateComposite().isSubInstanceOf(self.refImmediateComposite()));

--Get source(s) of delegation in parent instance
helper context UML!Slot def: getDelegationEndsUpwards() : Set(UML!Slot) = 
	self.getDelegationEnds()->select(s | self.refImmediateComposite().isSubInstanceOf(s.refImmediateComposite()));

--Get the target of delegation taking into account SBA stereotypes,
--i.e., get the first slot whose owning instnace has SBA information.
--(it can be even the slot under examination itself)
helper context UML!Slot def: getSBADelegations() : Set(UML!Slot) =
	let inst : UML!InstanceSpecification = self.refImmediateComposite() in
	let deleg : Set(UML!Slot) = self.getDelegationEndsDownwards() in
	if deleg.isEmpty() or 
		inst.hasSBAInformation() or 
		inst.getSubInstances().isEmpty() 
	then
		Set{self} 
	else
		deleg->collect(e | e.getSBADelegations())->flatten()
	endif;

--Get the target of connection taking into account SBA stereotypes,
--i.e., get the first slot whose owning instance has SBA information.
--(it can be even the slot directly connected to the one under examination)
helper context UML!Slot def: getSBAConnections() : Set(UML!Slot) =
	self.getConnectedImmediate()->collect(sl | sl.getSBADelegations())->flatten();	

--------------------------------------------------------------------
-- Parse failure modes for SimpleStochasticBehavior elements
--------------------------------------------------------------------

--Split the specification into different parts, one for each port, and find the
--failure modes for the port name passed as input. Calls parseFailureModes() below
helper context String def: parseFailureModesForPort(port : String) : Set(TupleType(fm: String, p: Real)) =
	let strSeq : Sequence(String) = self.trim()->split(';') in
	let strSelected : String = strSeq->select(s | s.trim().startsWith(port))->first() in
	if strSelected = OclUndefined then
		strSeq->first().parseFailureModes()
	else 
		strSelected.parseFailureModes()
	endif;

--From the specification in string format get the failure modes and proabilities for a single port
helper context String def: parseFailureModes() : Set(TupleType(fm: String, p: Real)) =
	let str : String = 
		if self.indexOf('{') < 0 then
			self.trim()
		else
			self.substring(self.indexOf('{')+2, self.size()).replaceAll('}', ' ').trim()
		endif	
	in
	let default : Set(TupleType(fm: String, p: Real)) = Set{Tuple{fm = 'failure', p = 1.0}} in
	if str.size() = 0 then
		default
	else
		let ret : Set(TupleType(fm: String, p: Real)) = 
		str.split(',')->collect(s | s.split(':'))->
			collect(seq | Tuple{fm = seq->first().trim(), p = seq.last().toReal()})
		in
		if ret->isEmpty() then
			default
		else
			ret
	endif endif;

--------------------------------------------------------------------
-- For debugging purposes: pretty print SBA stereotypes
--------------------------------------------------------------------
helper context CHESS!SimpleStochasticBehavior def: toString() : String = 
	'<<SimpleStochasticBehavior>>(' + self.failureOccurrence + ', ' + self.repairDelay + ', ' + self.failureModesDistribution + ')';
helper context CHESS!FLABehavior def: toString() : String = '<<FLABehavior>>(' + self.fptc + ')';
helper context CHESS!ErrorModelBehavior def: toString() : String = '<<ErrorModelBehavior>>(' + self.errorModel + ')';
helper context CHESS!ErrorModel def: toString() : String = '<<ErrorModel>>(' + self.base_StateMachine + ')';





