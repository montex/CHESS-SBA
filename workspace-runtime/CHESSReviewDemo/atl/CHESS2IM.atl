-- @path IM=/CHESSReviewDemo/metamodels/IM2.ecore
-- @path CHESS=http://schemas/CHESS/_PfAJsMe6Ed-7etIj5eTw0Q/19
-- @nsURI MARTE=http://www.eclipse.org/papyrus/MARTE/1

module CHESS2IM;
create OUT : IM from IN1 : CHESS, IN2 : MARTE, IN3 : UML2;

--entrypoint rule to call those rules who needs to be applied before anything else
entrypoint rule Entry(){
	
	using {
		--at the moment is it implied that there is only a StateBasedAnalysis in the model
		Analysis :  CHESS!StateBasedAnalysis = CHESS!StateBasedAnalysis.allInstances()->first();	
	}
	do{
		Analysis.base_StructuredClassifier;
		thisModule.System(Analysis);
		
	}
	
}

--rule to transform the CHESS!StateBasedAnalysis into an IM!Sistema
rule System(sba : CHESS!StateBasedAnalysis){
	
	to
		s : IM!Sistema (
			Name <- sba.base_StructuredClassifier.name
		)
		
	do{
		thisModule.SBAnalysis <- sba;
		thisModule.IMSystem <- s;
		thisModule.Platform(sba.platform->first().base_Package);
	}
}

--rule to initate all the resources belonging or linked to the platform specified in the analysis
rule Platform(res : UML2!Package){
	
	do{
		--get connectors from the resources platform
		thisModule.Connectors.addAll(res.getConnectors);
		--get components from the resources platform
		thisModule.Components.addAll(res.getInstances->collect(p | p.classifier->first()));
		
		--get components that are interested by sw-hw allocation
		thisModule.Comments.addAll(res.ownedComment);

		--get resources platform Ports
		for (i in res.getInstances){
			thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
		}
		
		for (a in MARTE!Assign.allInstances()){
			if (res.ownedComment->exists(e | e = a.base_Comment)){
				thisModule.Assign(a);
			}	
		}
		--get the States of the components
		for (c in thisModule.Components){
			for (m in c.ownedBehavior->select(s | s.oclIsTypeOf(UML2!StateMachine))){
				for (r in m.region){
					for (s in r.subvertex){
						thisModule.States.add(s);
					}
				}
			}
		}
	}
}

--get allocated HW/SW from Assign comments
rule Assign (a : MARTE!Assign){	
	
	do{
		--"from" and "to" are keywords in ATL... (works anyway, only issue: they are highlighted)
		thisModule.Components.addAll(a.from->collect(f | f.classifier->first()));
		thisModule.Components.addAll(a.to->collect(f | f.classifier->first()));
		
		--get also connectors from the allocated HW/SW		
		for (f in a.from){
			thisModule.Connectors.addAll(f.owner.getConnectors);
		}
		for (t in a.to){
			thisModule.Connectors.addAll(t.owner.getConnectors);
		}
		
		--finally get pors from the allocated HW/SW
		for (f in a.from){
			for (i in f.owner.getInstances){
				thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
			}
		}
		for (t in a.to){
			for (i in t.owner.getInstances){
				thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
			}
		}
	}
}

--filter the ClientServerPort in the resources platform from the rest
rule ClientServerPort{
	
	from
		s : MARTE!ClientServerPort (
			thisModule.Ports->exists(c | c = s.base_Port)	
		)
	
	do{
		thisModule.CSPort.add(s);
	}
}

--filter the FlowPort in the resources platform from the rest
rule FlowPort{
	
	from
		s : MARTE!FlowPort (
			thisModule.Ports->exists(c | c = s.base_Port)	
		)
	
	do{
		thisModule.FlowPort.add(s);
	}
}

--filter the Propagation comments in the resources platform from the rest
rule PropagationComment{
	
	from
		p : CHESS!Propagation (
			thisModule.Comments->exists(c | c = p.base_Comment)	
		)
		
	do{
		thisModule.PropComm.add(p);
	}
}

--filter the Propagation connectors in the resources platform from the rest
rule PropagationConnector{
	
	from
		p : CHESS!Propagation (
			thisModule.Connectors->exists(c | c = p.base_Connector)	
		)
		
	do{
		thisModule.PropConn.add(p);
	}
}

--filter the FailureMode states of the components in the resources platform from the rest
rule FailureMode{
	
	from
		f : CHESS!FailureMode(
			thisModule.States->exists(s | s = f.base_State)	
		)
	do{
		thisModule.FailureModes.add(f);
	}
}

--filter the StatefulHardware components in the resources platform from the rest
rule StatefulHardware{

	from 
		sfh: CHESS!StatefulHardware (
			thisModule.Components->exists(c | c = sfh.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sfh);
	}
}

--filter the StatelessHardware components in the resources platform from the rest
rule StatelessHardware{

	from 
		slh: CHESS!StatelessHardware (
			thisModule.Components->exists(c | c = slh.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(slh);
	}
}

--filter the StatefulSoftware components in the resources platform from the rest
rule StatefulSoftware{

	from 
		sfs: CHESS!StatefulSoftware (
			thisModule.Components->exists(c | c = sfs.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sfs);
	}
}

--filter the StatelessSoftware components in the resources platform from the rest
rule StatelessSoftware{

	from 
		sls: CHESS!StatelessSoftware (
			thisModule.Components->exists(c | c = sls.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sls);
	}
}


rule StatefulHardware2Component(sfh : CHESS!StatefulHardware){
	
	to c : IM!Component(

			Name <- sfh.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sfh.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sfh.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- sfh.probPermFault.NFPRealValue,
		TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sfh.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- default value?
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- sfh.repairDelay.NFPDurationInvertedValue
		),
		
		ra : IM!RepairActivity(
			
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)
	do{
		thisModule.setFGEName(fge);
		
		-- Failure Modes management
		if (sfh.errorModel = OclUndefined){
			thisModule.setFailureMode(c, sfh.errorLatency.NFPDurationInvertedValue, e);
		}else{
			for (r in sfh.errorModel.base_StateMachine.region){
				for(s in r.subvertex){
					if (thisModule.FailureModes->exists(e | e.base_State = s)){
						thisModule.setFailureMode(c, sfh.errorLatency.NFPDurationInvertedValue, e);
					}
				}
			}
		}
		--reset Counter
		thisModule.Counter <- 1;
	}
}


-- same as StatefulHardware except for this: 
-- in ErrorsProducesFailures the PropagationDelay attribute is always set to Exponetial with Rate = 0
rule StatelessHardware2Component(slh: CHESS!StatelessHardware){
	
	to
		c : IM!Component (
			Name <- slh.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- slh.faultOcc.NFPFrequencyValue
		),
			
		ft : IM!InternalFault(
			Component <- c,
			Name <- slh.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- slh.probPermFault.NFPRealValue,
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- slh.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn  ,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- slh.repairDelay.NFPDurationValue	
		),
		
		ra : IM!RepairActivity(
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd
		)

	do{
		thisModule.setFGEName(fge);
		
		-- Failure Modes management
		if (slh.errorModel = OclUndefined){
			thisModule.setFailureMode(c, 0, e); --this is different from StatefulHardware
		}else{
			for (r in slh.errorModel.base_StateMachine.region){
				for(s in r.subvertex){
					if (thisModule.FailureModes->exists(e | e.base_State = s)){
						thisModule.setFailureMode(c, 0, e);
					}
				}
			}
		}
		--reset Counter
		thisModule.Counter <- 1;
	}
}

-- same as StatefulHardware except for this: 
-- in InternalFault the PermanentProbability attribute is always set to Exponential with Rate = 0
rule StatefulSoftware2Component(sfs : CHESS!StatefulSoftware) {

	to
		c : IM!Component (
			Name <- sfs.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sfs.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sfs.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- 0, --this is different from StatefulHardware
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sfs.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- sfs.repairDelay.NFPDurationValue
		),
		
		ra : IM!RepairActivity(
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)	
		
	do{
		thisModule.setFGEName(fge);
		
		-- Failure Modes management
		if (sfs.errorModel = OclUndefined){
			thisModule.setFailureMode(c, sfs.errorLatency.NFPDurationInvertedValue, e);
		}else{
			for (r in sfs.errorModel.base_StateMachine.region){
				for(s in r.subvertex){
					if (thisModule.FailureModes->exists(e | e.base_State = s)){
						thisModule.setFailureMode(c, sfs.errorLatency.NFPDurationInvertedValue, e);
					}
				}
			}
		}
		--reset Counter
		thisModule.Counter <- 1;
	}
}

-- same as StatefulHardware except for the followings: 
-- in ErrorsProducesFailures the PropagationDelay attribute is always set to Exponential with Rate = 0 (as for StatelessHardware)
-- in InternalFault the PermanentProbability attribute is always set to Exponential with Rate = 0 (as for StatefulSoftware)
-- in RepairActivity the Duration attribute is always set to Exponential with Rate = 0

rule StatelessSoftware2Component(sls : CHESS!StatelessSoftware){

	to
		c : IM!Component (
			Name <- sls.geyName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sls.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sls.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- 0, --this is different from StatefulHardware
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sls.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString(),
			Name <- thisModule.getFGEName()
		),
		
		rd : IM!Deterministic(
			Value <- 0	--this is different from StatefulHardware
		),
		
		ra : IM!RepairActivity(
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)	
		
	do{
		thisModule.setFGEName(fge);
		
		-- Failure Modes management
		if (sls.errorModel = OclUndefined){
			thisModule.setFailureMode(c, 0, e); --this is different from StatefulHardware
		}else{
			for (r in sls.errorModel.base_StateMachine.region){
				for(s in r.subvertex){
					if (thisModule.FailureModes->exists(e | e.base_State = s)){
						thisModule.setFailureMode(c, 0, e);
					}
				}
			}
		}
		--reset Counter
		thisModule.Counter <- 1;
	}
}

-- rule called from the Stateful/Stateless Hardware/Software rules
rule setFailureMode(c : IM!Component, elRate : Real, e : IM!Error){	
	to
		f: IM!FailureMode(		
			Component <- c,
			Name <- c.Name + '_FailureMode' + thisModule.Counter -- multiple failure modes of the same component should have different names
		),
		
		en : IM!ErrorsExpressionErrorNode(
			Error <- e,
			errorPropagation <- epf
		),
		
		epf: IM!ErrorsProducesFailures(
			Source <- e,
			Destination <- f,
			PropagationDelay <- if elRate = 0 then thisModule.newDeterministic(elRate) else thisModule.newExponential(elRate) endif,
			PropagationLogic <- en,
			PropagationLogicStringFormat <- en.toString()
		)
		
	do{
		thisModule.setEPFName(epf);
		
		c.ErrorsGeneratesFailures.add(epf);	
		thisModule.Counter <- thisModule.Counter + 1;
	}

}

rule Allocation(a : MARTE!Assign, parent : UML2!Component, child : UML2!Component){
	
	do{
		for (fm in parent.corrispondingComponent.FailureModes){
			thisModule.AssignXft(fm, parent.corrispondingComponent, child.corrispondingComponent);
		}
		thisModule.AssignFge(child.corrispondingComponent, a);
		thisModule.TempXfts.clear();
	}
}

rule AssignXft(f : IM!FailureMode, parent: IM!Component, child: IM!Component){
	
	to		
		xft : IM!ExternalFault (
			Source <- f,
			Component <- child,
			Name <- child.Name + '_Fault_Caused_By_' + parent.Name
		)
		
	do{
		child.Faults.add(xft);
		--store xsft in a variable - remember to clear that variable after AssignFge
		thisModule.TempXfts.add(xft);
	}
}

rule AssignFge(child: IM!Component, a: MARTE!Assign){
	
	using{
		comm : CHESS!Propgation = thisModule.PropComm->select(e | a.base_Comment = e.base_Comment)->first();
	}
	
	to
	
		d : IM!Deterministic(
			Value <- 0	
		),
		
		fge : IM!FaultsGenerateErrors(
			--Source <- handled in the do block
			--PropagationLogic <- handled in the do block
			Destination <- child.Errors->first()
		)
		
	do{
		thisModule.setFGEName(fge);
		
		fge.Source.addAll(thisModule.TempXfts);
		--handling propagation logic	
		for (f in fge.Source){
			thisModule.FaultExpr(f);
		}
		if (thisModule.TempFen->size() = 1){
			fge.PropagationLogic <- thisModule.TempFen->first();
		}else{
			for(fen in thisModule.TempFen){
				if (fen <> thisModule.TempFen->last()){
					thisModule.CreateFenOrExpr();
				}
			}
			thisModule.TempFen->addAll(thisModule.TempFenSeq);

			for(fen in thisModule.TempFen){
				if (fen.oclIsTypeOf(IM!FaultsExpressionOrNode)){
					fen.FaultsExpression1 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
					fen.FaultsExpression2 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
				}
			}
			fge.PropagationLogic <- thisModule.TempFen->last();

		}
		fge.PropagationLogicStringFormat <- fge.PropagationLogic.toString();
		thisModule.setFGEBackLinks(fge.PropagationLogic, fge);
		thisModule.TempFen.clear();
		thisModule.TempFenSeq.clear();
		thisModule.Counter <- 1;
		
		--handling stereotype Propagation
		if (thisModule.PropComm->exists(e | a.base_Comment = e.base_Comment)){
			d.Value <- comm.propDelay.NFPRealValue;
			fge.PropagationProbability <- comm.prob.NFPRealValue;
		} else{
			fge.PropagationProbability <- 1;
		}
		fge.ActivationDelay <- d;
		
		child.FaultsGeneratesErrors.add(fge);
	}
}

rule FaultExpr(f: IM!Fault){
	
	to
		fefn:IM!FaultsExpressionFaultNode(
			Fault <- f	
		)
	
	do{
		thisModule.TempFen.add(fefn);
	}
}

rule CreateFenOrExpr(){
	
	to
		feon : IM!FaultsExpressionOrNode
		
	do{
		thisModule.TempFenSeq.add(feon);
	}
		
}

rule Connectors(p : CHESS!Propagation, first : UML2!Slot, last : UML2!Slot){
	
	using{
		flowFirst : MARTE!FlowPort = thisModule.FlowPort->select(e | e.base_Port = first.definingFeature)->first();
		flowLast : MARTE!FlowPort = thisModule.FlowPort->select(e | e.base_Port = last.definingFeature)->first();
		csfirst : MARTE!ClientServerPort = thisModule.CSPort->select (e | e.base_Port = first.definingFeature)->first();
		cslast :  MARTE!ClientServerPort = thisModule.CSPort->select (e | e.base_Port = last.definingFeature)->first();
		firstComp : UML!Component = first.value->first().instance.classifier->first();
		lastComp : UML!Component = 	last.value->first().instance.classifier->first();
	}
	
	do{
		--case A: ports are stereotyped as FlowPort
		if(thisModule.FlowPort->exists(e | e.base_Port = first.definingFeature) and 
				thisModule.FlowPort->exists(e | e.base_Port = last.definingFeature)){
			--check directions and call Propagation rule correctly
				if (flowFirst.direction.toString() = 'out' and flowLast.direction.toString() = 'in'){
					--firstComp is server, lastComp is client
					thisModule.Propagation(p, firstComp, lastComp);
				}
				if (flowFirst.direction.toString() = 'in' and flowLast.direction.toString() = 'out'){
					--firstComp is client, lastComp is server
					thisModule.Propagation(p, lastComp, firstComp);
				}
				if (flowFirst.direction.toString() = 'inout' and flowLast.direction.toString() = 'inout'){
					--bidirectional propagation
					thisModule.Propagation(p, firstComp, lastComp);
					thisModule.Propagation(p, lastComp, firstComp);
				}
				--other combination are bad ones and are not considered
		}
		
		--case B: ports are stereotyped as ClientServerPort
		if(thisModule.CSPort->exists(e | e.base_Port = first.definingFeature) and 
				thisModule.CSPort->exists(e | e.base_Port = last.definingFeature)){
			--check directions and call Propagation rule correctly
				if (csfirst.kind.toString() = 'provided' and cslast.kind.toString() = 'required'){
					--firstComp is server, lastComp is client
					thisModule.Propagation(p, firstComp, lastComp);
				}
				if (csfirst.kind.toString() = 'required' and cslast.kind.toString() = 'provided'){
					--firstComp is client, lastComp is server
					thisModule.Propagation(p, lastComp, firstComp);
				}
				if (csfirst.kind.toString() = 'proreq' and cslast.kind.toString() = 'proreq'){
					--bidirectional propagation
					thisModule.Propagation(p, firstComp, lastComp);
					thisModule.Propagation(p, lastComp, firstComp);
				}
				--other combination are bad ones and are not considered
		}
	}
}


rule Propagation (p : CHESS!Propagation, server : UML2!Component, client : UML2!Component){
	
	do{
		for (fm in server.corrispondingComponent.FailureModes){
			thisModule.AssignXft(fm, server.corrispondingComponent, client.corrispondingComponent);
		}
		thisModule.AssignFge(client.corrispondingComponent, p);
		thisModule.TempXfts.clear();
	}
}

rule RepairActivity(r : IM!RepairActivity){
	
	to
		se : IM!ScheduleExpression
		(
			T <- si
		),
		si : IM!ScheduleExpressionImmediately
	do{
		r.When <- se;
		for (c in r.Target){
			for(fm in c.FailureModes) {
				thisModule.SchedCond(fm);
			}
		}
		if (thisModule.TempScen->size() = 1){
			se.EX <- thisModule.TempScen->first();
		}else{
			for(scen in thisModule.TempScen){
				if (scen <> thisModule.TempScen->last()){
					thisModule.CreateScenOrExpr();
				}
			}
			thisModule.TempScen->addAll(thisModule.TempScenSeq);

			for(scen in thisModule.TempScen){
				if (scen.oclIsTypeOf(IM!SchedulingConditionExpressionOrNode)){
					scen.SchedulingConditionExpression1 <- thisModule.TempScen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
					scen.SchedulingConditionExpression2 <- thisModule.TempScen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
				}
			}
			se.EX <- thisModule.TempScen->last();
		}

		thisModule.TempScen.clear();
		thisModule.TempScenSeq.clear();
		thisModule.Counter <- 1;
	}
}

rule SchedCond(fm : IM!FailureMode){
	
	to
		scefn : IM!ScheduleExpressionFailed (
			failureMode <- fm	
		)
		
	do{
		thisModule.TempScen.add(scefn);
	}	
}

rule CreateScenOrExpr(){
	
	to
		sceon : IM!SchedulingConditionExpressionOrNode
		
	do{
		thisModule.TempScenSeq.add(sceon);
	}
		
}

rule setFGEBackLinks(fen: IM!FaultsExpressionNode, fge: IM!FaultsGenerateErrors ) {
	do {
		fen.faultsGenerateErrors <- fge;
		if (fen.oclIsTypeOf(IM!FaultsExpressionOrNode)) {
			thisModule.setFGEBackLinks(fen.FaultsExpression1, fge);
			thisModule.setFGEBackLinks(fen.FaultsExpression2, fge);
		}
	}
}

rule setEPFBackLinks(een: IM!ErrorsExpressionNode, epf: IM!ErrorsProducesFailures ) {
	do {
		een.errorPropagation <- epf;
		if (een.oclIsTypeOf(IM!FaultsExpressionOrNode)) {
			thisModule.setEPFBackLinks(een.FaultsExpression1, epf);
			thisModule.setEPFBackLinks(een.FaultsExpression2, epf);
		}
	}
}

rule setFGEName(fge : IM!FaultsGenerateErrors) {
	do {
		fge.Name <- 'fge' + thisModule.fgeCounter.toString();
		thisModule.fgeCounter <- thisModule.fgeCounter + 1;
	}
}

rule setEPFName(epf : IM!ErrorsProducesFailures) {
	do {
		epf.Name <- 'epf' + thisModule.epfCounter.toString();
		thisModule.epfCounter <- thisModule.epfCounter + 1;
	}
}

rule Reliability(sba : CHESS!StateBasedAnalysis, time : Real){
	
	to
		re : IM!Reliability (
			Name <-	'Reliability_'
		),
		
		it : IM!InstantOfTime (
			timePoint <- time	
		)
	do{
		thisModule.IMSystem.measures.add(re);
		re.evaluations.add(it);

		if (sba.targetDepComponent <> OclUndefined){
			re.target <- sba.targetDepComponent->first().classifier->
				first().corrispondingComponent.FailureModes;
	
			re.Name <- re.Name + sba.targetDepComponent->first().classifier->
				first().toString().replaceAll('!', '_');
		}
	}
}

rule Availability(sba : CHESS!StateBasedAnalysis, time : Real){
	
	to
		re : IM!Availability (
			Name <-	'Availability_'
		),
		
		it : IM!IntervalOfTime (
			begin <- 0,
			end <- time	
		)
	do{
		thisModule.IMSystem.measures.add(re);
		re.evaluations.add(it);

		if (sba.targetDepComponent <> OclUndefined){
			re.target <- sba.targetDepComponent->first().classifier->
				first().corrispondingComponent.FailureModes;
	
			re.Name <- re.Name + sba.targetDepComponent->first().classifier->
				first().toString().replaceAll('!', '_');
		}
	}
}

--manages all the delayed actions
endpoint rule EndRule() {
	
	do{			
		
		--component transformation
		for (c in thisModule.DepComponent){
			if (c.oclIsTypeOf(CHESS!StatefulHardware))
				thisModule.StatefulHardware2Component(c);
			else if (c.oclIsTypeOf(CHESS!StatelessHardware))
				thisModule.StatelessHardware2Component(c);
			else if (c.oclIsTypeOf(CHESS!StatefulSoftware))
				thisModule.StatefulSoftware2Component(c);
			else if (c.oclIsTypeOf(CHESS!StatelessSoftware))
				thisModule.StatelessSoftware2Component(c);
		}
		
		--delayed actions for components
		thisModule.IMSystem.components.addAll(IM!Component.allInstances());
		IM!Component.allInstances()->collect(c| c.intermediateModel = thisModule.IMSystem);
		
		--delayed actions for activities
		thisModule.IMSystem.Activities.addAll(IM!Activity.allInstances());
		--handle repair activities
		thisModule.RepairActivities <- IM!RepairActivity.allInstances();
		for (r in thisModule.RepairActivities){
			thisModule.RepairActivity(r);
		}
		
		--fault propagation due to Assign (hw -> sw)
		for (a in MARTE!Assign.allInstances()){
			if (thisModule.Comments->exists(e | e = a.base_Comment)){
				for (f in a.from){
					thisModule.Allocation(a, a.to->first().classifier->first(), f.classifier->first());
				}
				
			}	
		}
		
		--fault propagation due to connectors (hw -> hw or sw -> sw)
		for (p in CHESS!Propagation.allInstances()->select(p | p.base_InstanceSpecification <> OclUndefined)){
			if (thisModule.Connectors->exists(e | e = p.base_InstanceSpecification)){
				thisModule.Connectors(p, p.base_InstanceSpecification.slot->first(), p.base_InstanceSpecification.slot->last());
			}
		}

		--dependability measure handling
		--temporary version
		if (thisModule.SBAnalysis.WhichMeasure = 'Reliability'){
			thisModule.Reliability(thisModule.SBAnalysis, thisModule.SBAnalysis.measure.getTime);
		}else if (thisModule.SBAnalysis.WhichMeasure = 'Availability'){
			thisModule.Availability(thisModule.SBAnalysis, thisModule.SBAnalysis.measure.getTime);
		}else{
			--TODO: Availability, Safety... (others?)
		}
		
	}
}

lazy rule newDeterministic {
	from
		r : Real
	to 
		d : IM!Deterministic (
			Value <- r
		)		
}
lazy rule newExponential {
	from
		r : Real
	to
		e : IM!Exponential (
			Rate <- r 
		)
}

--temporary parser to retrieve which dependability measure a SBAnalysis refers to
helper context CHESS!StateBasedAnalysis def: WhichMeasure : String =
	if self.measure.startsWith('Reliability') then 'Reliability'
	else if self.measure.startsWith('Availability') then 'Availability'
	else 'error'
	endif endif;

--temporary parser to retrieve the time value from a dependability measure
helper context String def: getTime : Real = 
	self.substring(self.indexOf('=')+2, self.size()-1).toReal();

helper def : DepComponent : Set(CHESS!DependableComponent) = Set{};
helper def : PropComm : Set(CHESS!Propagation) = Set{};
helper def : PropConn : Set(CHESS!Propagation) = Set{};
helper def : CSPort : Set(MARTE!ClientServerPort) = Set{};
helper def : FlowPort : Set(MARTE!FlowPort) = Set{};
helper def : FailureModes : Set(CHESS!FailureMode) = Set{};

helper def : StatefulHW : Set(CHESS!StatefulHardware) = Set {};
helper def : StatelessHW : Set(CHESS!StatelessHardware) = Set {};
helper def : StatefulSW : Set(CHESS!StatefulSoftware) = Set {};
helper def : StatelessSW : Set(CHESS!StatelessSoftware) = Set {};

helper def: RepairActivities : Set (IM!RepairActivity) = Set {};

--helpers for string parsing (stubs) 
--NFP are strings with a well-defined format. these helpers should get the Real value from the String

helper context String def: NFPRealValue : Real = self.toReal();

helper context String def: NFPFrequencyValue : Real = self.toReal();

helper context String def: NFPDurationValue : Real = self.toReal();

helper context String def: NFPDurationInvertedValue : Real = 1/self.toReal();

--other helpers
helper def: TempXfts : Sequence (IM!ExternalFault) = Sequence {};
helper def: TempFen : Sequence(IM!FaultsExpressionNode) = Sequence {};
helper def: TempFenSeq : Sequence(IM!FaultsExpressionNode) = Sequence {};
helper def: TempScen : Sequence(IM!SchedulingConditionExpressionNode) = Sequence {};
helper def: TempScenSeq : Sequence(IM!SchedulingConditionExpressionNode) = Sequence {};

helper context UML2!Component def: corrispondingComponent : IM!Component =
	thisModule.IMSystem.components->select(e| e.Name = self.name)->first();

helper context CHESS!DependableComponent def : getName : String = self.base_Component.name;

helper context CHESS!StateBasedAnalysis def : getName : String = self.base_StructuredClassifier.name;

helper context UML2!Package def : getConnectors : Set(UML2!InstanceSpecification) = self.packagedElement->select(p | p.oclIsTypeOf(UML2!InstanceSpecification))->
			select(p | p.classifier.isEmpty());

helper context UML2!Package def : getInstances : Set(UML2!InstanceSpecification) = self.packagedElement->select(p | p.oclIsTypeOf(UML2!InstanceSpecification))->
			select(p | p.classifier.notEmpty());

helper def : Components : Set(UML2!Component) = Set {};
helper def : Connectors : Set(UML2!InstanceSpecification) = Set {};
helper def : Comments : Set (UML2!Comment) = Set {};
helper def : Ports : Set (UML2!Port) = Set {};
helper def : States : Set(UML2!State) = Set{};

helper def : SBAnalysis : CHESS!StateBasedAnalysis = OclUndefined;
helper def : Resources : UML2!Package = OclUndefined;

helper def : IMSystem : IM!Sistema = OclUndefined;

--counters starts from 1, not 0
helper def: Counter : Integer = 1;
helper def: fgeCounter : Integer = 1;
helper def: epfCounter : Integer = 1;

helper context IM!FaultsExpressionFaultNode def: toString(): String = self.Fault.Name;
helper context IM!FaultsExpressionOrNode def: toString(): String = '(' + self.FaultsExpression1.toString() + ' OR ' + self.FaultsExpression2.toString() + ')';

helper context IM!ErrorsExpressionErrorNode def: toString(): String = self.Error.Name;
helper context IM!ErrorsExpressionOrNode def: toString(): String = '(' + self.ErrorsExpression1.toString() + ' OR ' + self.ErrorsExpression2.toString() + ')';



