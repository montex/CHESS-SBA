-- @path IM=/CHESSReviewDemo/metamodels/IM2.ecore
-- @path CHESS=/CHESSReviewDemo/metamodels/chessmlprofile.ecore 
-- @nsURI MARTE=http://www.eclipse.org/papyrus/MARTE/1

module CHESS2IM;
create OUT : IM from IN1 : CHESS, IN2 : MARTE, IN3 : UML2;


--entrypoint rule to call those rules who needs to be applied before anything else
entrypoint rule Entry(){
	
	using {
		--at the moment is it implied that there is only a StateBasedAnalysis in the model
		Analysis :  CHESS!StateBasedAnalysis = CHESS!StateBasedAnalysis.allInstances()->first();	
	}
	do{
		Analysis.base_StructuredClassifier;
		thisModule.System(Analysis);
		
	}
	
}

--rule to transform the CHESS!StateBasedAnalysis into an IM!Sistema
rule System(sba : CHESS!StateBasedAnalysis){
	
	to
		s : IM!Sistema (
			Name <- sba.base_StructuredClassifier.name
		)
		
	do{
		thisModule.SBAnalysis <- sba;
		thisModule.IMSystem <- s;
		thisModule.Platform(sba.platform->first().base_Package);
		thisModule.Activities();
	}
}

--rule to initate all the resources belonging or linked to the platform specified in the analysis
rule Platform(res : UML2!Package){
	
	do{
		--get connectors from the resources platform
		thisModule.Connectors.addAll(res.getConnectors);
		--get components from the resources platform
		thisModule.Components.addAll(res.getInstances->collect(p | p.classifier->first()));
		
		--get components that are interested by sw-hw allocation
		thisModule.Comments.addAll(res.getComments);

		--get resources platform Ports
		for (i in res.getInstances){
			thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
		}
		
		for (a in MARTE!Assign.allInstances()){
			if (thisModule.Comments->exists(e | e = a.base_Comment)){
				thisModule.Assign(a);
			}	
		}

		--get the States and transitions of the components
		for (c in thisModule.Components){
			for (m in c.ownedBehavior->select(s | s.oclIsTypeOf(UML2!StateMachine))){
				for (r in m.region){
					for (s in r.subvertex){
						thisModule.States.add(s);
					}
					for (t in r.transition){
						thisModule.Transitions.add(t);
					}
				}
			}
		}
	}
}

--rule to transform activities
rule Activities () {
	
	do {
		for(a in CHESS!Repair.allInstances()) {
			if(not a.targets.excludesAll(thisModule.Components)) {
				thisModule.RepairActivityGeneric(a);
			}
		}
	}

}
--rule for RepairActivity
rule RepairActivityGeneric {

	from
		r : CHESS!Repair
	to
		act : IM!RepairActivity
		(
			Name <- r.base_Activity.name,
			SuccessProbability <- r.probSuccess.NFPRealValue,
			Duration <- d,
			When <- timeexp
		),
		--For the moment the duration is assumed to be exponential
		d : IM!Exponential (
			Rate <- r.duration.NFPDurationInvertedValue
		),
		timeexp : IM!ScheduleExpression
		(
				T <- 
				if r.when.trim().startsWith('Periodic') then
					thisModule.newScheduleExpPeriodic(r.when)
				else
					if r.when.trim().startsWith('AtTime') then
						thisModule.newScheduleExpAtTime(r.when)
					else
						OclUndefined
					endif
				endif,
				EX <- timeexp_ex
		),
		timeexp_ex : IM!ScheduleExpressionTrue
	do {
		--r.targets handled as DELAYED ACTION in EndRule()
	}
}
rule ErrorDetectionActivity {
	from
		r : CHESS!ErrorDetection
	to
		act : IM!DetectionActivity
		(
			Name <- r.base_Activity.name,
			Coverage <- r.probSuccess,
			Duration <- d,
			When <- timeexp
		),
		--For the moment the duration is assumed to be exponential
		d : IM!Exponential (
			Rate <- r.duration.NFPDurationInvertedValue
		),
		timeexp : IM!ScheduleExpression
		(
				T <- 
				if r.when.trim().startsWith('Periodic') then
					thisModule.newScheduleExpPeriodic(r.when)
				else
					if r.when.trim().startsWith('AtTime') then
						thisModule.newScheduleExpAtTime(r.when)
					else
						OclUndefined
					endif
				endif,
				EX <- timeexp_ex
		),
		timeexp_ex : IM!ScheduleExpressionTrue
}

--get allocated HW/SW from Assign comments
rule Assign (a : MARTE!Assign){	
	
	do{
		--"from" and "to" are keywords in ATL... (works anyway, only issue: they are highlighted)
		thisModule.Components.addAll(a.from->collect(f | f.classifier->first()));
--		thisModule.Components.addAll(a.to->collect(f | f.classifier->first()));
		
		--get also connectors from the allocated HW/SW		
		for (f in a.from){
			thisModule.Connectors.addAll(f.owner.getConnectors);
		}
		for (t in a.to){
			thisModule.Connectors.addAll(t.owner.getConnectors);
		}
		
		--finally get ports from the allocated HW/SW
		for (f in a.from){
			for (i in f.owner.getInstances){
				thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
			}
		}
		for (t in a.to){
			for (i in t.owner.getInstances){
				thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
			}
		}
	}
}

--filter the ClientServerPort in the resources platform from the rest
rule ClientServerPort{
	
	from
		s : MARTE!ClientServerPort (
			thisModule.Ports->exists(c | c = s.base_Port)	
		)
	
	do{
		thisModule.CSPort.add(s);
	}
}

--filter the FlowPort in the resources platform from the rest
rule FlowPort{
	
	from
		s : MARTE!FlowPort (
			thisModule.Ports->exists(c | c = s.base_Port)	
		)
	
	do{
		thisModule.FlowPort.add(s);
	}
}

--filter the Propagation comments in the resources platform from the rest
rule PropagationComment{
	
	from
		p : CHESS!Propagation (
			thisModule.Comments->exists(c | c = p.base_Comment)	
		)
		
	do{
		thisModule.PropComm.add(p);
	}
}

--filter the Propagation connectors in the resources platform from the rest
rule PropagationConnector{
	
	from
		p : CHESS!Propagation (
			thisModule.Connectors->exists(c | c = p.base_Connector)	
		)
		
	do{
		thisModule.PropConn.add(p);
	}
}

--filter the Propagation connectors in the resources platform from the rest
rule PropagationTransition{

	from
		p : CHESS!Propagation (
			thisModule.Transitions->exists(t | t = p.base_Transition)	
		)
		
	do{
		thisModule.PropTran.add(p);
	}
}
	

--filter the Error states of the components in the resources platform from the rest
rule Error{
	
	from
		f : CHESS!Error(
			thisModule.States->exists(s | s = f.base_State)	
		)
	do{
		thisModule.Errors.add(f);
	}
}

--filter the FailureMode states of the components in the resources platform from the rest
rule FailureMode{
	
	from
		f : CHESS!FailureMode(
			thisModule.States->exists(s | s = f.base_State)	
		)
	do{
		thisModule.FailureModes.add(f);
	}
}

--filter the InternalFault transitions of the components in the resources platform from the rest
rule InternalFault{
	
	from
		f : CHESS!InternalFault(
			thisModule.Transitions->exists(s | s = f.base_Transition)	
		)
	do{
		thisModule.InternalFaults.add(f);
	}
}

--filter the ExternalFault transitions of the components in the resources platform from the rest
rule ExternalFault{
	
	from
		f : CHESS!ExternalFault(
			thisModule.Transitions->exists(s | s = f.base_Transition)	
		)
	do{
		thisModule.ExternalFaults.add(f);
	}
}

--filter the StatefulHardware components in the resources platform from the rest
rule StatefulHardware{

	from 
		sfh: CHESS!StatefulHardware (
			thisModule.Components->exists(c | c = sfh.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sfh);
	}
}

--filter the StatelessHardware components in the resources platform from the rest
rule StatelessHardware{

	from 
		slh: CHESS!StatelessHardware (
			thisModule.Components->exists(c | c = slh.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(slh);
	}
}

--filter the StatefulSoftware components in the resources platform from the rest
rule StatefulSoftware{

	from 
		sfs: CHESS!StatefulSoftware (
			thisModule.Components->exists(c | c = sfs.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sfs);
	}
}

--filter the StatelessSoftware components in the resources platform from the rest
rule StatelessSoftware{

	from 
		sls: CHESS!StatelessSoftware (
			thisModule.Components->exists(c | c = sls.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sls);
	}
}


--filter the DependableComponent components in the resources platform from the rest
rule DependableComponent{
	
	from
		dc: CHESS!DependableComponent (
			thisModule.Components->exists(c | c = dc.base_Component and dc.oclIsTypeOf(CHESS!DependableComponent))	
		)
		
	do{
		thisModule.DepComponent.add(dc);
	}
}

--WORK IN PROGRESS
rule DependableComponent2Component(dc: CHESS!DependableComponent){
--	
--	using{
--		dc : CHESS!DependableComponent = thisModule.DepComponent->select(d | d.base_Component = c)->first();
--	}
	
	do{
	
		if (dc.errorModel = OclUndefined){
			--check if the component is a statebased (atomic) component and transform it accordingly
			if (dc.oclIsTypeOf(CHESS!StatefulHardware)){
				thisModule.StatefulHardware2Component(dc);
			}
			else if (dc.oclIsTypeOf(CHESS!StatelessHardware)){
				thisModule.StatelessHardware2Component(dc);
			}
			else if (dc.oclIsTypeOf(CHESS!StatefulSoftware)){
				thisModule.StatefulSoftware2Component(dc);
			}
			else if (dc.oclIsTypeOf(CHESS!StatelessSoftware)){
				thisModule.StatelessSoftware2Component(dc);
			}
			else{
				--composed components won't have a representation in the IDM
				for(e in dc.base_Component.getOwnedElements()){
					if(e.oclIsTypeOf(UML2!Property)){
						thisModule.Transform <- false;
					}
				}
			
				if(thisModule.Transform = true){
					--if not, this component won't fail due to internal faults, but it could be interested by fault propagation
					thisModule.NoIntFaultComponent(dc);
				}
			}
		}else{
			thisModule.ComponentErrorModel(dc);
		}
	}
}

rule NoTransformation(dc: CHESS!DependableComponent){
	
	do{
		--do nothing
	}
}

rule NoIntFaultComponent(dc: CHESS!DependableComponent){
	
	to 
		c : IM!Component(
			Name <- dc.getName	
		),
		
		e : IM!Error(
			Component <- c,
			Name <- c.Name + '_Error'
		)
		
	do{
		thisModule.setFailureMode(c, 0.0, e); 
	}
}

rule ComponentErrorModel(dc: CHESS!DependableComponent){
	
	to 
		c : IM!Component(
			Name <- dc.getName	
		)
	
	do{
		for (r in dc.errorModel.base_StateMachine.region){
			for(s in r.subvertex){
				if (thisModule.Errors->exists(e | e.base_State = s)){
					thisModule.CreateAndAddError(s, c);
				}
				if (thisModule.FailureModes->exists(e | e.base_State = s)){
					--thisModule.setFailureMode(c, 0.0, e);
					thisModule.CreateAndAddFailureMode(s, c);
				}
			}
			for (t in r.transition){
				if (thisModule.InternalFaults->exists(e | e.base_Transition = t)){
					thisModule.CreateAndAddIntFault(t, t.getInternalFault, c);
				} else if (thisModule.ExternalFaults->exists(e | e.base_Transition = t)){
					--do nothing at the moment
				} else if(t.getTarget().getError <> OclUndefined){
					thisModule.ErrorTransition(t, c);
				}else if(t.getTarget().getFailureMode <> OclUndefined and t.getSource().getError <> OclUndefined){
					t.getSource().getError;
					thisModule.FailureModeTransition(t, c);
				}
			}
		}
		thisModule.Counter <- 1;
	}
}

rule ErrorTransition(t: UML2!Transition, c :  IM!Component){
	
	to
	
		d: IM!Deterministic(
			Value <- 0	
	   	),
		
		en : IM!ErrorsExpressionErrorNode(
			Error <- t.getSource().getCorrispondingError,
			errorPropagation <- ip
		),
	
		ip: IM!InternalPropagation(
			Component <- c,
			Source <- t.getSource().getCorrispondingError,
			Destination <- t.getTarget().getCorrispondingError,
			Weight <- 1,
			PropagationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- en,
			PropagationLogicStringFormat <- en.toString()
		)
		
	
	do{
		thisModule.setIPName(ip);
		if(thisModule.PropTran->exists(e | e.base_Transition = t)){
			thisModule.TransitionPropagation(thisModule.PropTran->select(s | s.base_Transition = t)->first(), d, ip);
		}
		
	}
}

rule FailureModeTransition(t: UML2!Transition, c :  IM!Component){
	
	using{
		fm : CHESS!FailureMode = t.getTarget().getFailureMode;
	}
	
	to 
	 	d: IM!Deterministic(
			Value <- 0	
	   	),
		
		en : IM!ErrorsExpressionErrorNode(
			Error <- t.getSource().getCorrispondingError,
			errorPropagation <- epf
		),
	
		epf : IM!ErrorsProducesFailures(
			Component <- c,
			Source <- t.getSource().getCorrispondingError,
			Destination <- t.getTarget().getCorrispondingFailureMode,
			Weight <- if fm.probability <> OclUndefined then fm.probability.toReal() else 1.0 endif,
			PropagationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- en,
			PropagationLogicStringFormat <- en.toString()
	   	)
	
	do{
		thisModule.setEPFName(epf);
		if(thisModule.PropTran->exists(e | e.base_Transition = t)){
			thisModule.TransitionPropagation(thisModule.PropTran->select(s | s.base_Transition = t)->first(), d, epf);
		}
		
	}
}

rule TransitionPropagation(pr : CHESS!Propagation, d : IM!Distribution, epf : IM!ErrorsProducesFailures){
	
	do{
		d.Value <- pr.propDelay.toReal();
		epf.PropagationProbability <- pr.prob.toReal();
	}
	
}

rule CreateAndAddError(s : UML2!State, c : IM!Component){
	
	using{
		vt : String = s.getError.vanishingTime;
	}
	
	to e : IM!Error(
		VanishingTime <- if vt <> OclUndefined then thisModule.newExponential(vt.toReal()) else OclUndefined endif,
		Name <- s.name 
	)
	
	do{
		c.Errors.add(e);
	}
}


rule CreateAndAddFailureMode(s : UML2!State, c : IM!Component){
	
	to fm : IM!FailureMode(
		--Domain, Detectability...?
		Name <- s.name	
	)
	
	do{
		c.FailureModes.add(fm);
	}
}

rule CreateAndAddIntFault(t : UML2!Transition, ift : CHESS!InternalFault, c : IM!Component){
	
	using{
		oc : String = t.getInternalFault.occurrence;
		td : String = t.getInternalFault.transientDuration;
	}
	
	to ft : IM!InternalFault(
			Occurrence <- if oc <> OclUndefined then thisModule.newExponential(oc.toReal()) else OclUndefined endif,
			PermanentProbability <- ift.permanentProb.toReal(),
			TransientDuration <- if td <> OclUndefined then thisModule.newExponential(td.toReal()) else OclUndefined endif,
			Name <- t.name
		),
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Component <- c,
			Source <- ft,
			Destination <- t.getTarget().getCorrispondingError,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- value?
			PropagationLogicStringFormat <- fn.toString()
		)		
	
	do{
		thisModule.setFGEName(fge);
		c.Faults.add(ft);
		thisModule.Counter <- thisModule.Counter + 1;
	}
}

rule StatefulHardware2Component(sfh : CHESS!StatefulHardware){
	
	to c : IM!Component(

			Name <- sfh.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sfh.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sfh.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- sfh.probPermFault.NFPRealValue,
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sfh.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- default value?
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- sfh.repairDelay.NFPDurationInvertedValue
		),
		
		ra : IM!RepairActivity(
			
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)
	do{
		thisModule.setFGEName(fge);
		thisModule.RepairActivities <- thisModule.RepairActivities->including(ra);
		-- this rule is called only if the component doesn't have an ErrorModel	
		thisModule.setFailureMode(c, sfh.errorLatency.NFPDurationInvertedValue, e);
		thisModule.Counter <- 1;
	}
}


-- same as StatefulHardware except for this: 
-- in ErrorsProducesFailures the PropagationDelay attribute is always set to Exponetial with Rate = 0
rule StatelessHardware2Component(slh: CHESS!StatelessHardware){
	
	to
		c : IM!Component (
			Name <- slh.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- slh.faultOcc.NFPFrequencyValue
		),
			
		ft : IM!InternalFault(
			Component <- c,
			Name <- slh.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- slh.probPermFault.NFPRealValue,
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- slh.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn  ,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- slh.repairDelay.NFPDurationInvertedValue
		),
		
		ra : IM!RepairActivity(
			--Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd
		)

	do{
		thisModule.setFGEName(fge);
		thisModule.RepairActivities <- thisModule.RepairActivities->including(ra);
		-- this rule is called only if the component doesn't have an ErrorModel	
		thisModule.setFailureMode(c, 0, e); --this is different from StatefulHardware
		thisModule.Counter <- 1;
	}
}

-- same as StatefulHardware except for this: 
-- in InternalFault the PermanentProbability attribute is always set to Exponential with Rate = 0
rule StatefulSoftware2Component(sfs : CHESS!StatefulSoftware) {

	to
		c : IM!Component (
			Name <- sfs.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sfs.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sfs.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- 0, --this is different from StatefulHardware
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sfs.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- sfs.repairDelay.NFPDurationInvertedValue
		),
		
		ra : IM!RepairActivity(
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)	
		
	do{
		thisModule.setFGEName(fge);
		thisModule.RepairActivities <- thisModule.RepairActivities->including(ra);
		-- this rule is called only if the component doesn't have an ErrorModel	
		thisModule.setFailureMode(c, sfs.errorLatency.NFPDurationInvertedValue, e);
		thisModule.Counter <- 1;
	}
}

-- same as StatefulHardware except for the followings: 
-- in ErrorsProducesFailures the PropagationDelay attribute is always set to Exponential with Rate = 0 (as for StatelessHardware)
-- in InternalFault the PermanentProbability attribute is always set to Exponential with Rate = 0 (as for StatefulSoftware)
-- in RepairActivity the Duration attribute is always set to Exponential with Rate = 0

rule StatelessSoftware2Component(sls : CHESS!StatelessSoftware){

	to
		c : IM!Component (
			Name <- sls.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sls.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sls.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- 0, --this is different from StatefulHardware
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sls.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Deterministic(
			Value <- 0	--this is different from StatefulHardware
		),
		
		ra : IM!RepairActivity(
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)	
		
	do{
		thisModule.setFGEName(fge);
		thisModule.RepairActivities <- thisModule.RepairActivities->including(ra);
		-- this rule is called only if the component doesn't have an ErrorModel	
		thisModule.setFailureMode(c, 0, e); --this is different from StatefulHardware
		thisModule.Counter <- 1;
	}
}

-- rule called from the Stateful/Stateless Hardware/Software rules
rule setFailureMode(c : IM!Component, elRate : Real, e : IM!Error){	
	to
		f: IM!FailureMode(		
			Component <- c,
			Name <- c.Name + '_FailureMode' + thisModule.Counter -- multiple failure modes of the same component should have different names
		),
		
		en : IM!ErrorsExpressionErrorNode(
			Error <- e,
			errorPropagation <- epf
		),
		
		epf: IM!ErrorsProducesFailures(
			Source <- e,
			Destination <- f,
			PropagationDelay <- if elRate = 0 then thisModule.newDeterministic(elRate) else thisModule.newExponential(elRate) endif,
			PropagationLogic <- en,
			PropagationLogicStringFormat <- en.toString()
		)
		
	do{
		thisModule.setEPFName(epf);
		
		c.ErrorsGeneratesFailures.add(epf);	
		thisModule.Counter <- thisModule.Counter + 1;
	}

}



rule Allocation(a : MARTE!Assign, parent : UML2!Component, child : UML2!Component){
	
	using{
		p : CHESS!Propagation = thisModule.PropComm->select(c | a.base_Comment = c.base_Comment)->first();	
	}
	
	do{

		thisModule.Propagation(p, parent, child);
		
--		for (fm in parent.corrispondingComponent.FailureModes){
--			thisModule.AssignXft(fm, parent.corrispondingComponent, child.corrispondingComponent);
--		}
--		thisModule.AssignFge(child.corrispondingComponent, a);
--		thisModule.TempXfts.clear();
	}
}

rule AssignXft(f : IM!FailureMode, parent: IM!Component, child: IM!Component){
	
	to		
		xft : IM!ExternalFault (
			Source <- f,
			Component <- child,
			Name <- --child.Name + 
					'_From_' + parent.Name + '_' + f.Name
		)
		
	do{
		child.Faults.add(xft);
		--store xsft in a variable - remember to clear that variable after AssignFge
		thisModule.TempXfts.add(xft);
	}
}

rule AssignFge(child: IM!Component, a: MARTE!Assign){
	
	using{
		comm : CHESS!Propgation = thisModule.PropComm->select(e | a.base_Comment = e.base_Comment)->first();
	}
	
	to
	
		d : IM!Deterministic(
			Value <- 0	
		),
		
		fge : IM!FaultsGenerateErrors(
			--Source <- handled in the do block
			--PropagationLogic <- handled in the do block
			Destination <- child.Errors->first()
		)
		
	do{
		thisModule.setFGEName(fge);
		
		fge.Source.addAll(thisModule.TempXfts);
		--handling propagation logic	
		for (f in fge.Source){
			thisModule.FaultExpr(f);
		}
		if (thisModule.TempFen->size() = 1){
			fge.PropagationLogic <- thisModule.TempFen->first();
		}else{
			for(fen in thisModule.TempFen){
				if (fen <> thisModule.TempFen->last()){
					thisModule.CreateFenOrExpr();
				}
			}
			thisModule.TempFen->addAll(thisModule.TempFenSeq);

			for(fen in thisModule.TempFen){
				if (fen.oclIsTypeOf(IM!FaultsExpressionOrNode)){
					fen.FaultsExpression1 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
					fen.FaultsExpression2 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
				}
			}
			fge.PropagationLogic <- thisModule.TempFen->last();

		}
		fge.PropagationLogicStringFormat <- fge.PropagationLogic.toString();
		thisModule.setFGEBackLinks(fge.PropagationLogic, fge);
		thisModule.TempFen.clear();
		thisModule.TempFenSeq.clear();
		thisModule.Counter <- 1;
		
		--handling stereotype Propagation
		if (thisModule.PropComm->exists(e | a.base_Comment = e.base_Comment)){
			d.Value <- comm.propDelay.NFPRealValue;
			fge.PropagationProbability <- comm.prob.NFPRealValue;
		} else{
			fge.PropagationProbability <- 1;
		}
		fge.ActivationDelay <- d;
		
		child.FaultsGeneratesErrors.add(fge);
	}
}

rule FaultExpr(f: IM!Fault){
	
	to
		fefn:IM!FaultsExpressionFaultNode(
			Fault <- f	
		)
	
	do{
		thisModule.TempFen.add(fefn);
	}
}

rule CreateFenOrExpr(){
	
	to
		feon : IM!FaultsExpressionOrNode
		
	do{
		thisModule.TempFenSeq.add(feon);
	}
		
}

rule CreateFenAndExpr(){
	
	to
		fean : IM!FaultsExpressionAndNode
		
	do{
		thisModule.TempFenSeq.add(fean);
	}
		
}

rule Connectors(p : CHESS!Propagation, first : UML2!Slot, last : UML2!Slot){
	
	using{
		flowFirst : MARTE!FlowPort = thisModule.FlowPort->select(e | e.base_Port = first.definingFeature)->first();
		flowLast : MARTE!FlowPort = thisModule.FlowPort->select(e | e.base_Port = last.definingFeature)->first();
		csfirst : MARTE!ClientServerPort = thisModule.CSPort->select (e | e.base_Port = first.definingFeature)->first();
		cslast :  MARTE!ClientServerPort = thisModule.CSPort->select (e | e.base_Port = last.definingFeature)->first();
		firstComp : UML!Component = first.value->first().instance.classifier->first();
		lastComp : UML!Component = 	last.value->first().instance.classifier->first();
	}
	
	do{
		--case A: ports are stereotyped as FlowPort
		if(thisModule.FlowPort->exists(e | e.base_Port = first.definingFeature) and 
				thisModule.FlowPort->exists(e | e.base_Port = last.definingFeature)){
			--check directions and call Propagation rule correctly
				if (flowFirst.direction.toString() = 'out' and flowLast.direction.toString() = 'in'){
					--firstComp is server, lastComp is client
					thisModule.Propagation(p, firstComp, lastComp, flowFirst.base_Port, flowLast.base_Port);
				}
				if (flowFirst.direction.toString() = 'in' and flowLast.direction.toString() = 'out'){
					--firstComp is client, lastComp is server
					thisModule.Propagation(p, lastComp, firstComp, flowLast.base_Port, flowFirst.base_Port);
				}
				if (flowFirst.direction.toString() = 'inout' and flowLast.direction.toString() = 'inout'){
					--bidirectional propagation
					thisModule.Propagation(p, firstComp, lastComp, flowFirst.base_Port, flowLast.base_Port);
					thisModule.Propagation(p, lastComp, firstComp, flowLast.base_Port, flowFirst.base_Port);
				}
				--other combination are bad ones and are not considered
		}
		
		--case B: ports are stereotyped as ClientServerPort
		if(thisModule.CSPort->exists(e | e.base_Port = first.definingFeature) and 
				thisModule.CSPort->exists(e | e.base_Port = last.definingFeature)){
			--check directions and call Propagation rule correctly
				if (csfirst.kind.toString() = 'provided' and cslast.kind.toString() = 'required'){
					--firstComp is server, lastComp is client
					thisModule.Propagation(p, firstComp, lastComp, csfirst.base_Port, cslast.base_Port);
				}
				if (csfirst.kind.toString() = 'required' and cslast.kind.toString() = 'provided'){
					--firstComp is client, lastComp is server
					thisModule.Propagation(p, lastComp, firstComp, cslast.base_Port, csfirst.base_Port);
				}
				if (csfirst.kind.toString() = 'proreq' and cslast.kind.toString() = 'proreq'){
					--bidirectional propagation
					thisModule.Propagation(p, firstComp, lastComp, csfirst.base_Port, cslast.base_Port);
					thisModule.Propagation(p, lastComp, firstComp, cslast.base_Port, csfirst.base_Port);
				}
				--other combination are bad ones and are not considered
		}
	}
}


rule Propagation (p : CHESS!Propagation, server : UML2!Component, client : UML2!Component, serverport : UML2!Port, clientport : UML2!Port){
	
	using{
		serverDepComp : CHESS!DependableComponent = thisModule.DepComponent->select(s | s.base_Component = server)->first();
		clientDepComp : CHESS!DependableComponent = thisModule.DepComponent->select(s | s.base_Component = client)->first();
	}
	
	do{	
		
		if(server.corrispondingComponent <> OclUndefined and client.corrispondingComponent <> OclUndefined){
			
			--1) both client and server have an ErrorModel
			if(serverDepComp.errorModel <> OclUndefined and clientDepComp.errorModel <> OclUndefined){
				
				--for each server's FailureMode that affect the port interested by the connection...
				for (r in serverDepComp.errorModel.base_StateMachine.region){
					for(s in r.subvertex){
						if (thisModule.FailureModes->exists(e | e.base_State = s)){
							
							if (thisModule.FailureModes->select(e | e.base_State = s)->
								first().affectedPorts->includes(serverport) or 
								thisModule.FailureModes->select(e | e.base_State = s)->
								first().affectedPorts->isEmpty())
							{
								--...create an IM!ExternalFault in client corrisponding im component
								thisModule.SetExternalFaultClient(client.corrispondingComponent, s.getCorrispondingFailureMode);
							}
						}
					}
				}
				
				--for each client's ExternalFault that originates from the port interested by the connection...
				for (r in clientDepComp.errorModel.base_StateMachine.region){
					for(t in r.transition){
						if (thisModule.ExternalFaults->exists(e | e.base_Transition = t)){
							if (thisModule.ExternalFaults->select(e | e.base_Transition = t)->
							first().fromPort->includes(clientport)){
								--...create an IM!FaultsGenerateErrors in client corrisponding im component
								thisModule.SetFgeClient(client.corrispondingComponent, t, p);

							}
						}
					}
				}
			 	
			} else if(serverDepComp.errorModel = OclUndefined and clientDepComp.errorModel <> OclUndefined) {
				--2) server has NOT error model, client has error model

				--for each client's ExternalFault that originates from the port interested by the connection...
				for(f in server.corrispondingComponent.FailureModes) {
					thisModule.SetExternalFaultClient(client.corrispondingComponent, f);
				}
				
				for (r in clientDepComp.errorModel.base_StateMachine.region){
					for(t in r.transition){
						if (thisModule.ExternalFaults->exists(e | e.base_Transition = t)){
							if (thisModule.ExternalFaults->select(e | e.base_Transition = t)->
							    first().fromPort->includes(clientport) or
								thisModule.ExternalFaults->select(e | e.base_Transition = t)->
							    first().fromPort->isEmpty())
							{
								--...create an IM!FaultsGenerateErrors in client corrisponding im component
								thisModule.SetFgeClient(client.corrispondingComponent, t, p);
							}
						}
					}
				}				
				
			} else if(serverDepComp.errorModel <> OclUndefined and clientDepComp.errorModel = OclUndefined) {
				--3) server has error model, client has NOT error model
				if (MARTE!Assign.allInstances()->exists(e | e.base_Comment = p.base_Comment)) {
					--Assign relation: server is a hardware component, client is a the sowftware allocated to it,
					--all the failure modes should be taken into account
					for(f in server.corrispondingComponent.FailureModes) {
						thisModule.SetExternalFaultAndFGEClient(client.corrispondingComponent, f, p);
					}
				}else {
					--Normal connector
					--for each server's FailureMode that affect the port interested by the connection...
					for (r in serverDepComp.errorModel.base_StateMachine.region){
						for(s in r.subvertex){
							if (thisModule.FailureModes->exists(e | e.base_State = s)){
								
								if (thisModule.FailureModes->select(e | e.base_State = s)->
									first().affectedPorts->includes(serverport) or 
									thisModule.FailureModes->select(e | e.base_State = s)->
									first().affectedPorts->isEmpty())
								{
									--...create an IM!ExternalFault in client corrisponding im component
									thisModule.SetExternalFaultAndFGEClient(client.corrispondingComponent, s.getCorrispondingFailureMode, p);
								}
							}
						}
					}
				}
			
			} else if(serverDepComp <> OclUndefined and clientDepComp <> OclUndefined){
				--4) BOTH server and client do NOT have the error model, propagate the only failuremode of the server to the client
				thisModule.SetExternalFaultAndFGEClient(client.corrispondingComponent, server.corrispondingComponent.FailureModes->first(), p);	
			}
		
		}
		else{
			--composed component
			--one of client-server could not have a corrisponding component cause it's a composed component
			--the connected port is delegated to a child port
			--call propagation with the correct ports and components
			
			
			--case A: server is composed
			if(server.corrispondingComponent = OclUndefined){
				for (c in server.getOwnedConnectors()){
					if(c.getEnds()->first().getRole() = serverport){						
						thisModule.Propagation(p, c.getEnds()->last().getPartWithPort().getType(), client, c.getEnds()->last().getRole(), clientport);
					}
					if(c.getEnds()->last().getRole() = serverport){						
						thisModule.Propagation(p, c.getEnds()->first().getPartWithPort().getType(), client, c.getEnds()->first().getRole(), clientport);
					}
				}
			}
			
			--case B: client is composed
			if (client.corrispondingComponent = OclUndefined){
				for (c in client.getOwnedConnectors()){
					if(c.getEnds()->first().getRole() = clientport){						
						thisModule.Propagation(p, server, c.getEnds()->last().getPartWithPort().getType(), server, c.getEnds()->last().getRole());
					}
					if(c.getEnds()->last().getRole() = clientport){						
						thisModule.Propagation(p, server, c.getEnds()->first().getPartWithPort().getType(), server, c.getEnds()->first().getRole());
					}
				}
			}
		}
	}
}

rule SetExternalFaultAndFGEClient(client : IM!Component, fm : IM!FailureMode, p : CHESS!Propagation){
	
	to
		xft : IM!ExternalFault(
			Name <- 'ExternalFault_' + fm.Name,
			Source <- fm,
			Component <- client
		),
		
		fen : IM!FaultsExpressionFaultNode(
			Fault <- xft,
			faultsGenerateErrors <- fge	
		),
		
		fge : IM!FaultsGenerateErrors(
			Component <- client,
			Source <- xft,
			Weight <- 1,
			Destination <- client.Errors->first(),
			ActivationDelay <- if p.propDelay <> OclUndefined then thisModule.newDeterministic(p.propDelay.toReal()) else thisModule.newDeterministic(0) endif,
			PropagationProbability <- if p.prob <> OclUndefined then p.prob.toReal() else 1 endif,
			PropagationLogic <- fen,
			PropagationLogicStringFormat <- fen.toString()
		)
		
	do{
		thisModule.setFGEName(fge);
		thisModule.setFGEBackLinks(fge);
		client.Faults.add(xft);
	}
}
	
	
rule SetExternalFaultClient(client : IM!Component, fm : IM!FailureMode){
	
	
	to
		xft : IM!ExternalFault(
			Name <- 'ExternalFault_' + fm.Name,
			Source <- fm,
			Component <- client
		)
		
	do{
		client.Faults.add(xft);
	}
}


rule SetFgeClient(client : IM!Component, t : UML!Transition, p : CHESS!Propagation){
	
	using{
	
		propCond : String = t.getExternalFault.propagationCondition;
	}
	
	to
		fge : IM!FaultsGenerateErrors(
			Component <- client,
			Weight <- 1,
			Destination <- t.getTarget().getCorrispondingError,
			ActivationDelay <- if p.propDelay <> OclUndefined then thisModule.newDeterministic(p.propDelay.toReal()) else thisModule.newDeterministic(0) endif,
			PropagationProbability <- if p.prob <> OclUndefined then p.prob.toReal() else 1 endif
		)
	
	do{
		thisModule.setFGEName(fge);
		
		for (ft in client.Faults){
			if(ft.oclIsTypeOf(IM!ExternalFault)){
				fge.Source.add(ft);
			}
		}
		
		--handling propagation logic	
		for (f in fge.Source){
			thisModule.FaultExpr(f);
		}
		if (thisModule.TempFen->size() = 1){
			fge.PropagationLogic <- thisModule.TempFen->first();
		}else{
			for(fen in thisModule.TempFen){
				if (fen <> thisModule.TempFen->last()){
					if(propCond = 'OR'){
						thisModule.CreateFenOrExpr();
					}else if (propCond = 'AND'){
						thisModule.CreateFenAndExpr();
					}
				}
			}
			thisModule.TempFen->addAll(thisModule.TempFenSeq);

			for(fen in thisModule.TempFen){
				if (fen.oclIsTypeOf(IM!FaultsExpressionOrNode)){
					fen.FaultsExpression1 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
					fen.FaultsExpression2 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
				}
				else if (fen.oclIsTypeOf(IM!FaultsExpressionAndNode)){
					fen.FaultsExpression1 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
					fen.FaultsExpression2 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
				}
			}
				
			fge.PropagationLogic <- thisModule.TempFen->last();
			fge.PropagationLogicStringFormat <- fge.PropagationLogic.toString();
			
			thisModule.setFGEBackLinks(fge.PropagationLogic, fge);
			thisModule.TempFen.clear();
			thisModule.TempFenSeq.clear();
			thisModule.Counter <- 1;
		}
		
	}
}

rule RepairActivity(r : IM!RepairActivity){
	
	to
		se : IM!ScheduleExpression
		(
			T <- si
		),
		si : IM!ScheduleExpressionImmediately
	do{
		r.When <- se;
		for (c in r.Target){
			for(fm in c.FailureModes) {
				thisModule.SchedCond(fm);
			}
		}
		if (thisModule.TempScen->size() = 1){
			se.EX <- thisModule.TempScen->first();
		}else{
			for(scen in thisModule.TempScen){
				if (scen <> thisModule.TempScen->last()){
					thisModule.CreateScenOrExpr();
				}
			}
			thisModule.TempScen->addAll(thisModule.TempScenSeq);

			for(scen in thisModule.TempScen){
				if (scen.oclIsTypeOf(IM!ScheduleExpressionOr)){
					scen.e1 <- thisModule.TempScen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
					scen.e2 <- thisModule.TempScen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
				}
			}
			se.EX <- thisModule.TempScen->last();
		}

		thisModule.TempScen.clear();
		thisModule.TempScenSeq.clear();
		thisModule.Counter <- 1;
	}
}

rule SchedCond(fm : IM!FailureMode){
	
	to
		scefn : IM!ScheduleExpressionFailed (
			failureMode <- fm	
		)
		
	do{
		thisModule.TempScen.add(scefn);
	}	
}

rule CreateScenOrExpr(){
	
	to
		sceon : IM!ScheduleExpressionOr
		
	do{
		thisModule.TempScenSeq.add(sceon);
	}
		
}

rule setFGEBackLinks(fen: IM!FaultsExpressionNode, fge: IM!FaultsGenerateErrors ) {
	do {
		fen.faultsGenerateErrors <- fge;
		if (fen.oclIsTypeOf(IM!FaultsExpressionOrNode)) {
			thisModule.setFGEBackLinks(fen.FaultsExpression1, fge);
			thisModule.setFGEBackLinks(fen.FaultsExpression2, fge);
		}else if (fen.oclIsTypeOf(IM!FaultsExpressionAndNode)){
			thisModule.setFGEBackLinks(fen.FaultsExpression1, fge);
			thisModule.setFGEBackLinks(fen.FaultsExpression2, fge);
		}
	}
}

rule setEPFBackLinks(een: IM!ErrorsExpressionNode, epf: IM!ErrorsProducesFailures ) {
	do {
		een.errorPropagation <- epf;
		if (een.oclIsTypeOf(IM!FaultsExpressionOrNode)) {
			thisModule.setEPFBackLinks(een.FaultsExpression1, epf);
			thisModule.setEPFBackLinks(een.FaultsExpression2, epf);
		} else if (een.oclIsTypeOf(IM!FaultsExpressionAndNode)) {
			thisModule.setEPFBackLinks(een.FaultsExpression1, epf);
			thisModule.setEPFBackLinks(een.FaultsExpression2, epf);
		}
	}
}

rule setFGEName(fge : IM!FaultsGenerateErrors) {
	do {
		fge.Name <- 'fge' + thisModule.fgeCounter.toString();
		thisModule.fgeCounter <- thisModule.fgeCounter + 1;
	}
}

rule setEPFName(epf : IM!ErrorsProducesFailures) {
	do {
		epf.Name <- 'epf' + thisModule.epfCounter.toString();
		thisModule.epfCounter <- thisModule.epfCounter + 1;
	}
}

rule setIPName(ip : IM!InternalPropagation) {
	do {
		ip.Name <- 'ip' + thisModule.ipCounter.toString();
		thisModule.ipCounter <- thisModule.ipCounter + 1;
	}
}

rule Reliability(sba : CHESS!StateBasedAnalysis, time : Real){
	
	using {
		strClean : String = sba.measure.clean;
		iInstant : Integer = strClean.indexOf('instantOfTime');
	}	
	to
		re : IM!Reliability (
			Name <-	'Reliability_'
		)
		
	do{
		thisModule.IMSystem.measures.add(re);
		if (iInstant > 0) {
			re.evaluations.add(
				thisModule.newEvalInstantOfTime(
					strClean.substring(iInstant + 1 + 'instantOfTime'.size(), strClean.size()).toReal()
				)
			);			
		}
		else{ 
			--Should not happen!
		}

		for (c in sba.targetDepComponent) {
			re.target <- re.target.union(c.classifier->first().corrispondingComponent.FailureModes);
			re.Name <- re.Name + c.classifier->first().toString().replaceAll('!', '_');
		}
		for (fm in sba.targetFailureMode) {
			re.target <- re.target.union(fm);
			re.Name <- re.Name + fm.toString();
		}
	}
}

rule Availability(sba : CHESS!StateBasedAnalysis, time : Real){
	
	using {
		strClean : String = sba.measure.clean;
		iInterval : Integer = strClean.indexOf('intervalEnd');
		iInstant : Integer = strClean.indexOf('instantOfTime');
	}	
	to
		re : IM!Availability (
			Name <-	'Availability_'
		)
	do{
		thisModule.IMSystem.measures.add(re);

		if (iInterval > 0)
		{
			re.evaluations.add(
				thisModule.newEvalIntervalOfTime(
					strClean.substring(iInterval + 1 + 'intervalEnd'.size(), strClean.size()).toReal()
				)
			);
		}
		else if (iInstant > 0) {
			re.evaluations.add(
				thisModule.newEvalInstantOfTime(
					strClean.substring(iInstant + 1 + 'instantOfTime'.size(), strClean.size()).toReal()
				)
			);			
		}
		else{ 
			--Should not happen!
		}
		
		for (c in sba.targetDepComponent) {
			re.target <- re.target.union(c.classifier->first().corrispondingComponent.FailureModes);
			re.Name <- re.Name + c.classifier->first().toString().replaceAll('!', '_');
		}
		for (fm in sba.targetFailureMode) {
			re.target <- re.target.union(fm);
			re.Name <- re.Name + fm.toString();
		}
	}
}

--manages all the delayed actions
endpoint rule EndRule() {
	
	do{			
		--component transformation
		for (c in thisModule.Components){
			if(thisModule.DepComponent->select(d | d.base_Component = c)->first() <> OclUndefined){
				thisModule.DependableComponent2Component(thisModule.DepComponent->select(d | d.base_Component = c)->first());
			}
		}
		
		--delayed actions for components
		thisModule.IMSystem.components.addAll(IM!Component.allInstances());
		IM!Component.allInstances()->collect(c| c.intermediateModel = thisModule.IMSystem);
		
		--delayed actions for activities
		thisModule.IMSystem.Activities.addAll(IM!Activity.allInstances());
		--handle repair activities
		--thisModule.RepairActivities <- IM!RepairActivity.allInstances();
		--RepairActitivity elements generated fom RD
		for (r in thisModule.RepairActivities){
			thisModule.RepairActivity(r);
		}
		--Other RepairActivity elements
		for (rep in IM!RepairActivity.allInstances().asSet() - thisModule.RepairActivities) {
			for ( t in CHESS!Repair.allInstances()->select( act | act.base_Activity.name = rep.Name )->first().targets ) {
				rep.Target <- rep.Target->including(t.getType().corrispondingComponent);
			}
		}
	
		
		--fault propagation due to Assign (hw -> sw)
		for (a in MARTE!Assign.allInstances()){
			if (thisModule.Comments->exists(e | e = a.base_Comment)){
				for (f in a.from){
					thisModule.Allocation(a, a.to->first().classifier->first(), f.classifier->first());
				}
			}	
		}
		
		--fault propagation due to connectors (hw -> hw or sw -> sw)
		for (p in CHESS!Propagation.allInstances()->select(p | p.base_InstanceSpecification <> OclUndefined)){
			if (thisModule.Connectors->exists(e | e = p.base_InstanceSpecification)){
				thisModule.Connectors(p, p.base_InstanceSpecification.slot->first(), p.base_InstanceSpecification.slot->last());
			}
		}

		--dependability measure handling
		--temporary version
		if (thisModule.SBAnalysis.WhichMeasure = 'Reliability'){
			thisModule.Reliability(thisModule.SBAnalysis, thisModule.SBAnalysis.measure.getTime);
		}else if (thisModule.SBAnalysis.WhichMeasure = 'Availability'){
			thisModule.Availability(thisModule.SBAnalysis, thisModule.SBAnalysis.measure.getTime);
		}else{
			--TODO: Availability, Safety... (others?)
		}
		
	}
}

lazy rule newScheduleExpPeriodic {
	from
		s : String
	using {
		sClean : String = s.clean;
	}
	to
		p : IM!ScheduleExpressionPeriodic
		(
			PeriodDuration <- d
		),
		d : IM!Deterministic
		(
			Value <- sClean.substring('Periodic'.size()+1, sClean.size()).toReal()
		)
}
lazy rule newScheduleExpAtTime {
	from
		s : String
	using {
		sClean : String = s.clean;
	}
	to
		p : IM!ScheduleExpressionAtTime
		(
			t <- sClean.substring('AtTime'.size()+1, sClean.size()).toReal()
		)
}

lazy rule newDeterministic {
	from
		r : Real
	to 
		d : IM!Deterministic (
			Value <- r
		)		
}
lazy rule newExponential {
	from
		r : Real
	to
		e : IM!Exponential (
			Rate <- r 
		)
}
lazy rule newEvalIntervalOfTime {
	from
		t : Real
	to
		iot : IM!IntervalOfTimeAveraged
		(
			begin <- 0,
			end <- t
		)
}
lazy rule newEvalInstantOfTime {
	from
		t : Real
	to
		instant : IM!InstantOfTime ( timePoint <- t )
}

--temporary parser to retrieve which dependability measure a SBAnalysis refers to
helper context CHESS!StateBasedAnalysis def: WhichMeasure : String =
	if self.measure.startsWith('Reliability') then 'Reliability'
	else if self.measure.startsWith('Availability') then 'Availability'
	else 'error'
	endif endif;

--temporary parser to retrieve the time value from a dependability measure
helper context String def: getTime : Real = 
	self.substring(self.indexOf('=')+2, self.size()-1).toReal();

helper def : DepComponent : Sequence(CHESS!DependableComponent) = Sequence{};
helper def : PropComm : Set(CHESS!Propagation) = Set{};
helper def : PropConn : Set(CHESS!Propagation) = Set{};
helper def : PropTran : Set(CHESS!Propagation) = Set{};
helper def : CSPort : Set(MARTE!ClientServerPort) = Set{};
helper def : FlowPort : Set(MARTE!FlowPort) = Set{};
helper def : Errors : Set(CHESS!Errores) = Set{};
helper def : FailureModes : Set(CHESS!FailureMode) = Set{};
helper def : InternalFaults : Set(CHESS!InternalFault) = Set{};
helper def : ExternalFaults : Set(CHESS!InternalFault) = Set{};

helper def : StatefulHW : Set(CHESS!StatefulHardware) = Set {};
helper def : StatelessHW : Set(CHESS!StatelessHardware) = Set {};
helper def : StatefulSW : Set(CHESS!StatefulSoftware) = Set {};
helper def : StatelessSW : Set(CHESS!StatelessSoftware) = Set {};

helper def: RepairActivities : Set (IM!RepairActivity) = Set {};

--helpers for string parsing (stubs) 
--NFP are strings with a well-defined format. these helpers should get the Real value from the String

helper context String def: NFPRealValue : Real = self.toReal();

helper context String def: NFPFrequencyValue : Real = self.toReal();

helper context String def: NFPDurationValue : Real = self.toReal();

helper context String def: NFPDurationInvertedValue : Real = 1/self.toReal();

--other helpers
helper def: TempXfts : Sequence (IM!ExternalFault) = Sequence {};
helper def: TempFen : Sequence(IM!FaultsExpressionNode) = Sequence {};
helper def: TempFenSeq : Sequence(IM!FaultsExpressionNode) = Sequence {};
helper def: TempScen : Sequence(IM!SchedulingConditionExpressionNode) = Sequence {};
helper def: TempScenSeq : Sequence(IM!SchedulingConditionExpressionNode) = Sequence {};

helper context UML2!Component def: corrispondingComponent : IM!Component =
	thisModule.IMSystem.components->select(e| e.Name = self.name)->first();
helper context UML2!Property def: corrispondingComponent : IM!Component =
	thisModule.IMSystem.components->select(e| e.Name = self.name)->first();

helper context CHESS!DependableComponent def : getName : String = self.base_Component.name;

helper context CHESS!StateBasedAnalysis def : getName : String = self.base_StructuredClassifier.name;

helper context UML2!Package def : getConnectors : Set(UML2!InstanceSpecification) = self.packagedElement->select(p | p.oclIsTypeOf(UML2!InstanceSpecification))->
			select(p | p.classifier.isEmpty());

helper context UML2!Package def : getInstances : Set(UML2!InstanceSpecification) = self.packagedElement->select(p | p.oclIsTypeOf(UML2!InstanceSpecification))->
			select(p | p.classifier.notEmpty());

helper context UML2!Package def : getComments : Set(UML2!InstanceSpecification) = self.getInstances->collect(p | p.classifier->first())->
			collect(p | p.ownedComment)->flatten();

helper context UML2!State def : getError : CHESS!Error =
			thisModule.Errors->select(e | e.base_State = self)->first();

helper context UML2!State def : getFailureMode : CHESS!FailureMode =
			thisModule.FailureModes->select(e | e.base_State = self)->first();

helper context UML2!Transition def : getInternalFault : CHESS!InternalFault =
			thisModule.InternalFaults->select(ift | ift.base_Transition = self)->first();

helper context UML2!Transition def : getExternalFault : CHESS!ExternalFault =
			thisModule.ExternalFaults->select(ift | ift.base_Transition = self)->first();

helper context UML2!State def : getCorrispondingError :  IM!Error =
			IM!Error.allInstances()->select(e | e.Name = self.name)->first();

helper context UML2!State def : getCorrispondingFailureMode :  IM!FailureMode =
			IM!FailureMode.allInstances()->select(e | e.Name = self.name)->first();

--Trim whitespaces, remove brackets, remove the equal symbol
helper context String def: clean : String = self.regexReplaceAll('[={}]', ' ').trim();

helper def : Components : Sequence(UML2!Component) = Sequence {};
helper def : Connectors : Set(UML2!InstanceSpecification) = Set {};
helper def : Comments : Set (UML2!Comment) = Set {};
helper def : Ports : Set (UML2!Port) = Set {};
helper def : States : Set(UML2!State) = Set{};
helper def : Transitions : Set(UML2!Tansition) = Set{};

helper def : SBAnalysis : CHESS!StateBasedAnalysis = OclUndefined;
helper def : Resources : UML2!Package = OclUndefined;

helper def : IMSystem : IM!Sistema = OclUndefined;

--counters starts from 1, not 0
helper def: Counter : Integer = 1;
helper def: CounterTwo : Integer = 1;
helper def: fgeCounter : Integer = 1;
helper def: epfCounter : Integer = 1;
helper def: ipCounter : Integer = 1;

helper def: Transform : Boolean = true;

helper context IM!FaultsExpressionFaultNode def: toString(): String = self.Fault.Name;
helper context IM!FaultsExpressionOrNode def: toString(): String = '(' + self.FaultsExpression1.toString() + ' OR ' + self.FaultsExpression2.toString() + ')';
helper context IM!FaultsExpressionAndNode def: toString() : String = '(' + self.FaultsExpression1.toString() + ' AND ' + self.FaultsExpression2.toString() + ')';


helper context IM!ErrorsExpressionErrorNode def: toString(): String = self.Error.Name;
helper context IM!ErrorsExpressionOrNode def: toString(): String = '(' + self.ErrorsExpression1.toString() + ' OR ' + self.ErrorsExpression2.toString() + ')';
