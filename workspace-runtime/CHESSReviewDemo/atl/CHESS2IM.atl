-- @path IM=/CHESSReviewDemo/metamodels/IM2.ecore
-- @path CHESS=http://schemas/CHESS/_PfAJsMe6Ed-7etIj5eTw0Q/19
-- @nsURI MARTE=http://www.eclipse.org/papyrus/MARTE/1

module CHESS2IM;
create OUT : IM from IN1 : CHESS, IN2 : MARTE, IN3 : UML2;

--FUFFA
rule Prop{
	
	from
		p : UML2!Property
		
	do{
		p.owner.debug('own');
	}
}


--END FUFFa


--entrypoint rule to call those rules who needs to be applied before anything else
entrypoint rule Entry(){
	
	using {
		--at the moment is it implied that there is only a StateBasedAnalysis in the model
		Analysis :  CHESS!StateBasedAnalysis = CHESS!StateBasedAnalysis.allInstances()->first();	
	}
	do{
		Analysis.base_StructuredClassifier;
		thisModule.System(Analysis);
		
	}
	
}

--rule to transform the CHESS!StateBasedAnalysis into an IM!Sistema
rule System(sba : CHESS!StateBasedAnalysis){
	
	to
		s : IM!Sistema (
			Name <- sba.base_StructuredClassifier.name
		)
		
	do{
		thisModule.SBAnalysis <- sba;
		thisModule.IMSystem <- s;
		thisModule.Platform(sba.platform->first().base_Package);
		thisModule.Activities();
	}
}

--rule to initate all the resources belonging or linked to the platform specified in the analysis
rule Platform(res : UML2!Package){
	
	do{
		--get connectors from the resources platform
		thisModule.Connectors.addAll(res.getConnectors);
		--get components from the resources platform
		thisModule.Components.addAll(res.getInstances->collect(p | p.classifier->first()));
		
		--get components that are interested by sw-hw allocation
		thisModule.Comments.addAll(res.getComments);

		--get resources platform Ports
		for (i in res.getInstances){
			thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
		}
		
		for (a in MARTE!Assign.allInstances()){
			if (thisModule.Comments->exists(e | e = a.base_Comment)){
				thisModule.Assign(a);
			}	
		}
		--get the States and transitions of the components
		for (c in thisModule.Components){
			for (m in c.ownedBehavior->select(s | s.oclIsTypeOf(UML2!StateMachine))){
				for (r in m.region){
					for (s in r.subvertex){
						thisModule.States.add(s);
					}
					for (t in r.transition){
						thisModule.Transitions.add(t);
					}
				}
			}
		}
	}
}

--rule to transform activities
rule Activities () {
	
	do {
		for(a in CHESS!Repair.allInstances()) {
			if(not a.targets.excludesAll(thisModule.Components)) {
				thisModule.RepairActivityGeneric(a);
			}
		}
	}

}
--rule for RepairActivity
rule RepairActivityGeneric {

	
	from
		r : CHESS!Repair
	to
		act : IM!RepairActivity
		(
			Name <- r.base_Activity.name,
			SuccessProbability <- r.probSuccess.NFPRealValue,
			Duration <- d,
			When <- timeexp
		),
		--For the moment the duration is assumed to be exponential
		d : IM!Exponential (
			Rate <- r.duration.NFPDurationInvertedValue
		),
		--temporary
		timeexp : IM!ScheduleExpression
		(
				T <- timeexp_t,
				EX <- timeexp_ex
		),
		timeexp_ex : IM!ScheduleExpressionTrue,
		timeexp_t : IM!ScheduleExpressionPeriodic
		(
				PeriodDuration <- period
		),
		period : IM!Deterministic ( Value <- 1000 )
	do {
		--r.targets handled as DELAYED ACTION in EndRule()
	}
}

--get allocated HW/SW from Assign comments
rule Assign (a : MARTE!Assign){	
	
	do{
		--"from" and "to" are keywords in ATL... (works anyway, only issue: they are highlighted)
		thisModule.Components.addAll(a.from->collect(f | f.classifier->first()));
		thisModule.Components.addAll(a.to->collect(f | f.classifier->first()));
		
		--get also connectors from the allocated HW/SW		
		for (f in a.from){
			thisModule.Connectors.addAll(f.owner.getConnectors);
		}
		for (t in a.to){
			thisModule.Connectors.addAll(t.owner.getConnectors);
		}
		
		--finally get pors from the allocated HW/SW
		for (f in a.from){
			for (i in f.owner.getInstances){
				thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
			}
		}
		for (t in a.to){
			for (i in t.owner.getInstances){
				thisModule.Ports.addAll(i.slot->collect(d | d.definingFeature));
			}
		}
	}
}

----filter the ErrorModel in the resources platform from the rest
--rule ErrorModel{
--	
--	from 
--		em : CHESS!ErrorModel(
--			
--		)
--	
--	do{
--	}
--		
--}


--filter the ClientServerPort in the resources platform from the rest
rule ClientServerPort{
	
	from
		s : MARTE!ClientServerPort (
			thisModule.Ports->exists(c | c = s.base_Port)	
		)
	
	do{
		thisModule.CSPort.add(s);
	}
}

--filter the FlowPort in the resources platform from the rest
rule FlowPort{
	
	from
		s : MARTE!FlowPort (
			thisModule.Ports->exists(c | c = s.base_Port)	
		)
	
	do{
		thisModule.FlowPort.add(s);
	}
}

--filter the Propagation comments in the resources platform from the rest
rule PropagationComment{
	
	from
		p : CHESS!Propagation (
			thisModule.Comments->exists(c | c = p.base_Comment)	
		)
		
	do{
		thisModule.PropComm.add(p);
	}
}

--filter the Propagation connectors in the resources platform from the rest
rule PropagationConnector{
	
	from
		p : CHESS!Propagation (
			thisModule.Connectors->exists(c | c = p.base_Connector)	
		)
		
	do{
		thisModule.PropConn.add(p);
	}
}

--filter the Propagation connectors in the resources platform from the rest
rule PropagationTransition{

	from
		p : CHESS!Propagation (
			thisModule.Transitions->exists(t | t = p.base_Transition)	
		)
		
	do{
		thisModule.PropTran.add(p);
	}
}
	

--filter the Error states of the components in the resources platform from the rest
rule Error{
	
	from
		f : CHESS!Error(
			thisModule.States->exists(s | s = f.base_State)	
		)
	do{
		thisModule.Errors.add(f);
	}
}

--filter the FailureMode states of the components in the resources platform from the rest
rule FailureMode{
	
	from
		f : CHESS!FailureMode(
			thisModule.States->exists(s | s = f.base_State)	
		)
	do{
		thisModule.FailureModes.add(f);
	}
}

--filter the InternalFault transitions of the components in the resources platform from the rest
rule InternalFault{
	
	from
		f : CHESS!InternalFault(
			thisModule.Transitions->exists(s | s = f.base_Transition)	
		)
	do{
		thisModule.InternalFaults.add(f);
	}
}

--filter the StatefulHardware components in the resources platform from the rest
rule StatefulHardware{

	from 
		sfh: CHESS!StatefulHardware (
			thisModule.Components->exists(c | c = sfh.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sfh);
	}
}

--filter the StatelessHardware components in the resources platform from the rest
rule StatelessHardware{

	from 
		slh: CHESS!StatelessHardware (
			thisModule.Components->exists(c | c = slh.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(slh);
	}
}

--filter the StatefulSoftware components in the resources platform from the rest
rule StatefulSoftware{

	from 
		sfs: CHESS!StatefulSoftware (
			thisModule.Components->exists(c | c = sfs.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sfs);
	}
}

--filter the StatelessSoftware components in the resources platform from the rest
rule StatelessSoftware{

	from 
		sls: CHESS!StatelessSoftware (
			thisModule.Components->exists(c | c = sls.base_Component)
		)
		
	do{
		thisModule.DepComponent.add(sls);
	}
}


--filter the DependableComponent components in the resources platform from the rest
rule DependableComponent{
	
	from
		dc: CHESS!DependableComponent (
			thisModule.Components->exists(c | c = dc.base_Component and dc.oclIsTypeOf(CHESS!DependableComponent))	
		)
		
	do{
		thisModule.DepComponent.add(dc);
	}
}

--WORK IN PROGRESS
rule DependableComponent2Component(dc: CHESS!DependableComponent){
	
	do{
	
		if (dc.errorModel = OclUndefined){
			--check if the component is a statebased (atomic) component and transform it accordingly
			if (dc.oclIsTypeOf(CHESS!StatefulHardware)){
				thisModule.StatefulHardware2Component(dc);
			}
			else if (dc.oclIsTypeOf(CHESS!StatelessHardware)){
				thisModule.StatelessHardware2Component(dc);
			}
			else if (dc.oclIsTypeOf(CHESS!StatefulSoftware)){
				thisModule.StatefulSoftware2Component(dc);
			}
			else if (dc.oclIsTypeOf(CHESS!StatelessSoftware)){
				thisModule.StatelessSoftware2Component(dc);
			}
			else{
				--if not, this component won't fail due to internal faults, but it could be interested by fault propagation
				thisModule.NoIntFaultComponent(dc);
			}
		}else{
			thisModule.ComponentErrorModel(dc);
		}
	}
}

rule NoIntFaultComponent(dc: CHESS!DependableComponent){
	
	to 
		c : IM!Component(
			Name <- dc.getName	
		),
		
		e : IM!Error(
			Component <- c,
			Name <- c.Name + '_Error'
		)
		
	do{
		thisModule.setFailureMode(c, 0.0, e); --probably needs review
	}
}

rule ComponentErrorModel(dc: CHESS!DependableComponent){
	
	to 
		c : IM!Component(
			Name <- dc.getName	
		)
	
	do{
		for (r in dc.errorModel.base_StateMachine.region){
			for(s in r.subvertex){
				if (thisModule.Errors->exists(e | e.base_State = s)){
					thisModule.CreateAndAddError(s, c);
				}
				if (thisModule.FailureModes->exists(e | e.base_State = s)){
					--thisModule.setFailureMode(c, 0.0, e);
					thisModule.CreateAndAddFailureMode(s, c);
				}
			}
			for (t in r.transition){
				if (thisModule.InternalFaults->exists(e | e.base_Transition = t)){
					thisModule.CreateAndAddIntFault(t, t.getInternalFault, c);
				}else{
					if(t.getTarget().getError <> OclUndefined){
						thisModule.ErrorTransition(t, c);
					}else if(t.getTarget().getFailureMode <> OclUndefined and t.getSource().getError <> OclUndefined){
						t.getSource().getError;
						thisModule.FailureModeTransition(t, c);
					}
				}
			}
		}
	}
}

rule ErrorTransition(t: UML2!Transition, c :  IM!Component){
	
	to
	
		d: IM!Deterministic(
			Value <- 0	
	   	),
		
		en : IM!ErrorsExpressionErrorNode(
			Error <- t.getSource().getCorrispondingError,
			errorPropagation <- ip
		),
	
		ip: IM!InternalPropagation(
			Component <- c,
			Source <- t.getSource().getCorrispondingError,
			Destination <- t.getTarget().getCorrispondingError,
			Weight <- 1,
			PropagationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- en,
			PropagationLogicStringFormat <- en.toString()
		)
		
	
	do{
		thisModule.setIPName(ip);
		if(thisModule.PropTran->exists(e | e.base_Transition = t)){
			thisModule.TransitionPropagation(thisModule.PropTran->select(s | s.base_Transition = t)->first(), d, ip);
		}
		
	}
}

rule FailureModeTransition(t: UML2!Transition, c :  IM!Component){
	
	using{
		fm : CHESS!FailureMode = t.getTarget().getFailureMode;
	}
	
	to 
	 	d: IM!Deterministic(
			Value <- 0	
	   	),
		
		en : IM!ErrorsExpressionErrorNode(
			Error <- t.getSource().getCorrispondingError,
			errorPropagation <- epf
		),
	
		epf : IM!ErrorsProducesFailures(
			Component <- c,
			Source <- t.getSource().getCorrispondingError,
			Destination <- t.getTarget().getCorrispondingFailureMode,
			Weight <- if fm.probability <> OclUndefined then fm.probability.toReal() else 1.0 endif,
			PropagationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- en,
			PropagationLogicStringFormat <- en.toString()
	   	)
	
	do{
		thisModule.setEPFName(epf);
		if(thisModule.PropTran->exists(e | e.base_Transition = t)){
			thisModule.TransitionPropagation(thisModule.PropTran->select(s | s.base_Transition = t)->first(), d, epf);
		}
		
	}
}

rule TransitionPropagation(pr : CHESS!Propagation, d : IM!Distribution, epf : IM!ErrorsProducesFailures){
	
	do{
		d.Value <- pr.propDelay.toReal();
		epf.PropagationProbability <- pr.prob.toReal();
	}
	
}

rule CreateAndAddError(s : UML2!State, c : IM!Component){
	
	to e : IM!Error(
		--VanishingTime <- to be added in the profile
		Name <- s.name 
	)
	
	do{
		c.Errors.add(e);
	}
}


rule CreateAndAddFailureMode(s : UML2!State, c : IM!Component){
	
	to fm : IM!FailureMode(
		--??
		Name <- s.name	
	)
	
	do{
		c.FailureModes.add(fm);
	}
}

rule CreateAndAddIntFault(t : UML2!Transition, ift : CHESS!InternalFault, c : IM!Component){
	
	to ft : IM!InternalFault(
			--Occurence <- to be added in the profile
			PermanentProbability <- ift.permanentProb.toReal(),
			--TransientDuration <- to be added in the profile
			Name <- t.name
		),
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Component <- c,
			Source <- ft,
			Destination <- t.getTarget().getCorrispondingError,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- value?
			PropagationLogicStringFormat <- fn.toString()
		)		
	
	do{
		thisModule.setFGEName(fge);
		c.Faults.add(ft);
		thisModule.Counter <- thisModule.Counter + 1;
	}
}

rule StatefulHardware2Component(sfh : CHESS!StatefulHardware){
	
	to c : IM!Component(

			Name <- sfh.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sfh.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sfh.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- sfh.probPermFault.NFPRealValue,
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sfh.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- default value?
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- sfh.repairDelay.NFPDurationInvertedValue
		),
		
		ra : IM!RepairActivity(
			
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)
	do{
		thisModule.setFGEName(fge);
		thisModule.RepairActivities <- thisModule.RepairActivities->including(ra);
		-- this rule is called only if the component doesn't have an ErrorModel	
		thisModule.setFailureMode(c, sfh.errorLatency.NFPDurationInvertedValue, e);
		thisModule.Counter <- 1;
	}
}


-- same as StatefulHardware except for this: 
-- in ErrorsProducesFailures the PropagationDelay attribute is always set to Exponetial with Rate = 0
rule StatelessHardware2Component(slh: CHESS!StatelessHardware){
	
	to
		c : IM!Component (
			Name <- slh.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- slh.faultOcc.NFPFrequencyValue
		),
			
		ft : IM!InternalFault(
			Component <- c,
			Name <- slh.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- slh.probPermFault.NFPRealValue,
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- slh.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn  ,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- slh.repairDelay.NFPDurationValue	
		),
		
		ra : IM!RepairActivity(
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd
		)

	do{
		thisModule.setFGEName(fge);
		thisModule.RepairActivities <- thisModule.RepairActivities->including(ra);
		-- this rule is called only if the component doesn't have an ErrorModel	
		thisModule.setFailureMode(c, 0, e); --this is different from StatefulHardware
		thisModule.Counter <- 1;
	}
}

-- same as StatefulHardware except for this: 
-- in InternalFault the PermanentProbability attribute is always set to Exponential with Rate = 0
rule StatefulSoftware2Component(sfs : CHESS!StatefulSoftware) {

	to
		c : IM!Component (
			Name <- sfs.getName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sfs.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sfs.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- 0, --this is different from StatefulHardware
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sfs.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString()
		),
		
		rd : IM!Exponential(
			Rate <- sfs.repairDelay.NFPDurationValue
		),
		
		ra : IM!RepairActivity(
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)	
		
	do{
		thisModule.setFGEName(fge);
		thisModule.RepairActivities <- thisModule.RepairActivities->including(ra);
		-- this rule is called only if the component doesn't have an ErrorModel	
		thisModule.setFailureMode(c, sfs.errorLatency.NFPDurationInvertedValue, e);
		thisModule.Counter <- 1;
	}
}

-- same as StatefulHardware except for the followings: 
-- in ErrorsProducesFailures the PropagationDelay attribute is always set to Exponential with Rate = 0 (as for StatelessHardware)
-- in InternalFault the PermanentProbability attribute is always set to Exponential with Rate = 0 (as for StatefulSoftware)
-- in RepairActivity the Duration attribute is always set to Exponential with Rate = 0

rule StatelessSoftware2Component(sls : CHESS!StatelessSoftware){

	to
		c : IM!Component (
			Name <- sls.geyName,
			--intermediateModel <- delayed action
			Errors <- e,
			Faults <- ft,
			FaultsGeneratesErrors <- fge
		),
		
		fo : IM!Exponential(
			Rate <- sls.faultOcc.NFPFrequencyValue
		),
		
		ft : IM!InternalFault(
			Component <- c,
			Name <- sls.getName + '_Fault',
			Occurrence <- fo,
			PermanentProbability <- 0, --this is different from StatefulHardware
			TransientDuration <- td
		),
		
		td : IM!Deterministic( Value <- 0 ),
		
		e : IM!Error(
			Component <- c,
			Name <- sls.getName + '_Error'
		),
		
		
		d: IM!Deterministic(
			Value <- 0	
		),
		
		fn : IM!FaultsExpressionFaultNode(
			Fault <- ft,
			faultsGenerateErrors <- fge
		),
		
		fge : IM!FaultsGenerateErrors(
			Source <- ft,
			Destination <- e,
			ActivationDelay <- d,
			PropagationProbability <- 1,
			PropagationLogic <- fn,
			--Weight <- ??
			PropagationLogicStringFormat <- fn.toString(),
			Name <- thisModule.getFGEName()
		),
		
		rd : IM!Deterministic(
			Value <- 0	--this is different from StatefulHardware
		),
		
		ra : IM!RepairActivity(
--			Component <- c,
			Name <- c.Name + '_RD',
			Target <- Sequence{c},
			SuccessProbability <- 1,
			Duration <- rd --,
			--When <- ... handled as a DELAYED ACTION
		)	
		
	do{
		thisModule.setFGEName(fge);
		thisModule.RepairActivities <- thisModule.RepairActivities->including(ra);
		-- this rule is called only if the component doesn't have an ErrorModel	
		thisModule.setFailureMode(c, 0, e); --this is different from StatefulHardware
		thisModule.Counter <- 1;
	}
}

-- rule called from the Stateful/Stateless Hardware/Software rules
rule setFailureMode(c : IM!Component, elRate : Real, e : IM!Error){	
	to
		f: IM!FailureMode(		
			Component <- c,
			Name <- c.Name + '_FailureMode' + thisModule.Counter -- multiple failure modes of the same component should have different names
		),
		
		en : IM!ErrorsExpressionErrorNode(
			Error <- e,
			errorPropagation <- epf
		),
		
		epf: IM!ErrorsProducesFailures(
			Source <- e,
			Destination <- f,
			PropagationDelay <- if elRate = 0 then thisModule.newDeterministic(elRate) else thisModule.newExponential(elRate) endif,
			PropagationLogic <- en,
			PropagationLogicStringFormat <- en.toString()
		)
		
	do{
		thisModule.setEPFName(epf);
		
		c.ErrorsGeneratesFailures.add(epf);	
		thisModule.Counter <- thisModule.Counter + 1;
	}

}

rule Allocation(a : MARTE!Assign, parent : UML2!Component, child : UML2!Component){
	
	do{
		for (fm in parent.corrispondingComponent.FailureModes){
			thisModule.AssignXft(fm, parent.corrispondingComponent.debug('parent'), child.corrispondingComponent.debug('child'));
		}
		thisModule.AssignFge(child.corrispondingComponent, a);
		thisModule.TempXfts.clear();
	}
}

rule AssignXft(f : IM!FailureMode, parent: IM!Component, child: IM!Component){
	
	to		
		xft : IM!ExternalFault (
			Source <- f,
			Component <- child,
			Name <- child.Name + '_Fault_Caused_By_' + parent.Name
		)
		
	do{
		child.Faults.add(xft);
		--store xsft in a variable - remember to clear that variable after AssignFge
		thisModule.TempXfts.add(xft);
	}
}

rule AssignFge(child: IM!Component, a: MARTE!Assign){
	
	using{
		comm : CHESS!Propgation = thisModule.PropComm->select(e | a.base_Comment = e.base_Comment)->first();
	}
	
	to
	
		d : IM!Deterministic(
			Value <- 0	
		),
		
		fge : IM!FaultsGenerateErrors(
			--Source <- handled in the do block
			--PropagationLogic <- handled in the do block
			Destination <- child.Errors->first()
		)
		
	do{
		thisModule.setFGEName(fge);
		
		fge.Source.addAll(thisModule.TempXfts);
		--handling propagation logic	
		for (f in fge.Source){
			thisModule.FaultExpr(f);
		}
		if (thisModule.TempFen->size() = 1){
			fge.PropagationLogic <- thisModule.TempFen->first();
		}else{
			for(fen in thisModule.TempFen){
				if (fen <> thisModule.TempFen->last()){
					thisModule.CreateFenOrExpr();
				}
			}
			thisModule.TempFen->addAll(thisModule.TempFenSeq);

			for(fen in thisModule.TempFen){
				if (fen.oclIsTypeOf(IM!FaultsExpressionOrNode)){
					fen.FaultsExpression1 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
					fen.FaultsExpression2 <- thisModule.TempFen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
				}
			}
			fge.PropagationLogic <- thisModule.TempFen->last();

		}
		fge.PropagationLogicStringFormat <- fge.PropagationLogic.toString();
		thisModule.setFGEBackLinks(fge.PropagationLogic, fge);
		thisModule.TempFen.clear();
		thisModule.TempFenSeq.clear();
		thisModule.Counter <- 1;
		
		--handling stereotype Propagation
		if (thisModule.PropComm->exists(e | a.base_Comment = e.base_Comment)){
			d.Value <- comm.propDelay.NFPRealValue;
			fge.PropagationProbability <- comm.prob.NFPRealValue;
		} else{
			fge.PropagationProbability <- 1;
		}
		fge.ActivationDelay <- d;
		
		child.FaultsGeneratesErrors.add(fge);
	}
}

rule FaultExpr(f: IM!Fault){
	
	to
		fefn:IM!FaultsExpressionFaultNode(
			Fault <- f	
		)
	
	do{
		thisModule.TempFen.add(fefn);
	}
}

rule CreateFenOrExpr(){
	
	to
		feon : IM!FaultsExpressionOrNode
		
	do{
		thisModule.TempFenSeq.add(feon);
	}
		
}

rule Connectors(p : CHESS!Propagation, first : UML2!Slot, last : UML2!Slot){
	
	using{
		flowFirst : MARTE!FlowPort = thisModule.FlowPort->select(e | e.base_Port = first.definingFeature)->first();
		flowLast : MARTE!FlowPort = thisModule.FlowPort->select(e | e.base_Port = last.definingFeature)->first();
		csfirst : MARTE!ClientServerPort = thisModule.CSPort->select (e | e.base_Port = first.definingFeature)->first();
		cslast :  MARTE!ClientServerPort = thisModule.CSPort->select (e | e.base_Port = last.definingFeature)->first();
		firstComp : UML!Component = first.value->first().instance.classifier->first();
		lastComp : UML!Component = 	last.value->first().instance.classifier->first();
	}
	
	do{
		--case A: ports are stereotyped as FlowPort
		if(thisModule.FlowPort->exists(e | e.base_Port = first.definingFeature) and 
				thisModule.FlowPort->exists(e | e.base_Port = last.definingFeature)){
			--check directions and call Propagation rule correctly
				if (flowFirst.direction.toString() = 'out' and flowLast.direction.toString() = 'in'){
					--firstComp is server, lastComp is client
					thisModule.Propagation(p, firstComp, lastComp);
				}
				if (flowFirst.direction.toString() = 'in' and flowLast.direction.toString() = 'out'){
					--firstComp is client, lastComp is server
					thisModule.Propagation(p, lastComp, firstComp);
				}
				if (flowFirst.direction.toString() = 'inout' and flowLast.direction.toString() = 'inout'){
					--bidirectional propagation
					thisModule.Propagation(p, firstComp, lastComp);
					thisModule.Propagation(p, lastComp, firstComp);
				}
				--other combination are bad ones and are not considered
		}
		
		--case B: ports are stereotyped as ClientServerPort
		if(thisModule.CSPort->exists(e | e.base_Port = first.definingFeature) and 
				thisModule.CSPort->exists(e | e.base_Port = last.definingFeature)){
			--check directions and call Propagation rule correctly
				if (csfirst.kind.toString() = 'provided' and cslast.kind.toString() = 'required'){
					--firstComp is server, lastComp is client
					thisModule.Propagation(p, firstComp, lastComp);
				}
				if (csfirst.kind.toString() = 'required' and cslast.kind.toString() = 'provided'){
					--firstComp is client, lastComp is server
					thisModule.Propagation(p, lastComp, firstComp);
				}
				if (csfirst.kind.toString() = 'proreq' and cslast.kind.toString() = 'proreq'){
					--bidirectional propagation
					thisModule.Propagation(p, firstComp, lastComp);
					thisModule.Propagation(p, lastComp, firstComp);
				}
				--other combination are bad ones and are not considered
		}
	}
}


rule Propagation (p : CHESS!Propagation, server : UML2!Component, client : UML2!Component){
	
	do{
		--TODO: not every fm in server, just those that affect the port - how??
		for (fm in server.corrispondingComponent.FailureModes){
			thisModule.AssignXft(fm, server.corrispondingComponent, client.corrispondingComponent);
		}
		thisModule.AssignFge(client.corrispondingComponent, p);
		thisModule.TempXfts.clear();
	}
}

rule RepairActivity(r : IM!RepairActivity){
	
	to
		se : IM!ScheduleExpression
		(
			T <- si
		),
		si : IM!ScheduleExpressionImmediately
	do{
		r.When <- se;
		for (c in r.Target){
			for(fm in c.FailureModes) {
				thisModule.SchedCond(fm);
			}
		}
		if (thisModule.TempScen->size() = 1){
			se.EX <- thisModule.TempScen->first();
		}else{
			for(scen in thisModule.TempScen){
				if (scen <> thisModule.TempScen->last()){
					thisModule.CreateScenOrExpr();
				}
			}
			thisModule.TempScen->addAll(thisModule.TempScenSeq);

			for(scen in thisModule.TempScen){
				if (scen.oclIsTypeOf(IM!ScheduleExpressionOr)){
					scen.e1 <- thisModule.TempScen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
					scen.e2 <- thisModule.TempScen.at(thisModule.Counter);
					thisModule.Counter <- thisModule.Counter+1;
				}
			}
			se.EX <- thisModule.TempScen->last();
		}

		thisModule.TempScen.clear();
		thisModule.TempScenSeq.clear();
		thisModule.Counter <- 1;
	}
}

rule SchedCond(fm : IM!FailureMode){
	
	to
		scefn : IM!ScheduleExpressionFailed (
			failureMode <- fm	
		)
		
	do{
		thisModule.TempScen.add(scefn);
	}	
}

rule CreateScenOrExpr(){
	
	to
		sceon : IM!ScheduleExpressionOr
		
	do{
		thisModule.TempScenSeq.add(sceon);
	}
		
}

rule setFGEBackLinks(fen: IM!FaultsExpressionNode, fge: IM!FaultsGenerateErrors ) {
	do {
		fen.faultsGenerateErrors <- fge;
		if (fen.oclIsTypeOf(IM!FaultsExpressionOrNode)) {
			thisModule.setFGEBackLinks(fen.FaultsExpression1, fge);
			thisModule.setFGEBackLinks(fen.FaultsExpression2, fge);
		}
	}
}

rule setEPFBackLinks(een: IM!ErrorsExpressionNode, epf: IM!ErrorsProducesFailures ) {
	do {
		een.errorPropagation <- epf;
		if (een.oclIsTypeOf(IM!FaultsExpressionOrNode)) {
			thisModule.setEPFBackLinks(een.FaultsExpression1, epf);
			thisModule.setEPFBackLinks(een.FaultsExpression2, epf);
		}
	}
}

rule setFGEName(fge : IM!FaultsGenerateErrors) {
	do {
		fge.Name <- 'fge' + thisModule.fgeCounter.toString();
		thisModule.fgeCounter <- thisModule.fgeCounter + 1;
	}
}

rule setEPFName(epf : IM!ErrorsProducesFailures) {
	do {
		epf.Name <- 'epf' + thisModule.epfCounter.toString();
		thisModule.epfCounter <- thisModule.epfCounter + 1;
	}
}

rule setIPName(ip : IM!InternalPropagation) {
	do {
		ip.Name <- 'ip' + thisModule.ipCounter.toString();
		thisModule.ipCounter <- thisModule.ipCounter + 1;
	}
}

rule Reliability(sba : CHESS!StateBasedAnalysis, time : Real){
	
	to
		re : IM!Reliability (
			Name <-	'Reliability_'
		),
		
		it : IM!InstantOfTime (
			timePoint <- time	
		)
	do{
		thisModule.IMSystem.measures.add(re);
		re.evaluations.add(it);

		if (sba.targetDepComponent <> OclUndefined){
			re.target <- sba.targetDepComponent->first().classifier->
				first().corrispondingComponent.FailureModes;
	
			re.Name <- re.Name + sba.targetDepComponent->first().classifier->
				first().toString().replaceAll('!', '_');
		}
	}
}

rule Availability(sba : CHESS!StateBasedAnalysis, time : Real){
	
	to
		re : IM!Availability (
			Name <-	'Availability_'
		),
		
		it : IM!IntervalOfTime (
			begin <- 0,
			end <- time	
		)
	do{
		thisModule.IMSystem.measures.add(re);
		re.evaluations.add(it);

		if (sba.targetDepComponent <> OclUndefined){
			re.target <- sba.targetDepComponent->first().classifier->
				first().corrispondingComponent.FailureModes;
	
			re.Name <- re.Name + sba.targetDepComponent->first().classifier->
				first().toString().replaceAll('!', '_');
		}
	}
}

--manages all the delayed actions
endpoint rule EndRule() {
	
	do{			
		
		--component transformation
		for (c in thisModule.DepComponent.debug('comp')){
			thisModule.DependableComponent2Component(c);
		}
		
		--delayed actions for components
		thisModule.IMSystem.components.addAll(IM!Component.allInstances());
		IM!Component.allInstances()->collect(c| c.intermediateModel = thisModule.IMSystem);
		
		--delayed actions for activities
		thisModule.IMSystem.Activities.addAll(IM!Activity.allInstances());
		--handle repair activities
		--thisModule.RepairActivities <- IM!RepairActivity.allInstances();
		--RepairActitivity elements generated fom RD
		for (r in thisModule.RepairActivities){
			thisModule.RepairActivity(r);
		}
		--Other RepairActivity elements
		for (rep in IM!RepairActivity.allInstances().asSet() - thisModule.RepairActivities) {
			for ( t in CHESS!Repair.allInstances()->select( act | act.base_Activity.name = rep.Name )->first().targets ) {
				rep.Target <- rep.Target->including(t.getType().corrispondingComponent);
			}
		}
	
		
		--fault propagation due to Assign (hw -> sw)
		for (a in MARTE!Assign.allInstances()){
			if (thisModule.Comments->exists(e | e = a.base_Comment)){
				for (f in a.from){
					thisModule.Allocation(a, a.to->first().classifier->first().debug('to'), f.classifier->first().debug('from'));
				}
				
			}	
		}
		
		--fault propagation due to connectors (hw -> hw or sw -> sw)
		for (p in CHESS!Propagation.allInstances()->select(p | p.base_InstanceSpecification <> OclUndefined)){
			if (thisModule.Connectors->exists(e | e = p.base_InstanceSpecification)){
				thisModule.Connectors(p, p.base_InstanceSpecification.slot->first(), p.base_InstanceSpecification.slot->last());
			}
		}

		--dependability measure handling
		--temporary version
		if (thisModule.SBAnalysis.WhichMeasure = 'Reliability'){
			thisModule.Reliability(thisModule.SBAnalysis, thisModule.SBAnalysis.measure.getTime);
		}else if (thisModule.SBAnalysis.WhichMeasure = 'Availability'){
			thisModule.Availability(thisModule.SBAnalysis, thisModule.SBAnalysis.measure.getTime);
		}else{
			--TODO: Availability, Safety... (others?)
		}
		
	}
}

lazy rule newDeterministic {
	from
		r : Real
	to 
		d : IM!Deterministic (
			Value <- r
		)		
}
lazy rule newExponential {
	from
		r : Real
	to
		e : IM!Exponential (
			Rate <- r 
		)
}

--temporary parser to retrieve which dependability measure a SBAnalysis refers to
helper context CHESS!StateBasedAnalysis def: WhichMeasure : String =
	if self.measure.startsWith('Reliability') then 'Reliability'
	else if self.measure.startsWith('Availability') then 'Availability'
	else 'error'
	endif endif;

--temporary parser to retrieve the time value from a dependability measure
helper context String def: getTime : Real = 
	self.substring(self.indexOf('=')+2, self.size()-1).toReal();

helper def : DepComponent : Set(CHESS!DependableComponent) = Set{};
helper def : PropComm : Set(CHESS!Propagation) = Set{};
helper def : PropConn : Set(CHESS!Propagation) = Set{};
helper def : PropTran : Set(CHESS!Propagation) = Set{};
helper def : CSPort : Set(MARTE!ClientServerPort) = Set{};
helper def : FlowPort : Set(MARTE!FlowPort) = Set{};
helper def : Errors : Set(CHESS!Errores) = Set{};
helper def : FailureModes : Set(CHESS!FailureMode) = Set{};
helper def : InternalFaults : Set(CHESS!InternalFault) = Set{};

helper def : StatefulHW : Set(CHESS!StatefulHardware) = Set {};
helper def : StatelessHW : Set(CHESS!StatelessHardware) = Set {};
helper def : StatefulSW : Set(CHESS!StatefulSoftware) = Set {};
helper def : StatelessSW : Set(CHESS!StatelessSoftware) = Set {};

helper def: RepairActivities : Set (IM!RepairActivity) = Set {};

--helpers for string parsing (stubs) 
--NFP are strings with a well-defined format. these helpers should get the Real value from the String

helper context String def: NFPRealValue : Real = self.toReal();

helper context String def: NFPFrequencyValue : Real = self.toReal();

helper context String def: NFPDurationValue : Real = self.toReal();

helper context String def: NFPDurationInvertedValue : Real = 1/self.toReal();

--other helpers
helper def: TempXfts : Sequence (IM!ExternalFault) = Sequence {};
helper def: TempFen : Sequence(IM!FaultsExpressionNode) = Sequence {};
helper def: TempFenSeq : Sequence(IM!FaultsExpressionNode) = Sequence {};
helper def: TempScen : Sequence(IM!SchedulingConditionExpressionNode) = Sequence {};
helper def: TempScenSeq : Sequence(IM!SchedulingConditionExpressionNode) = Sequence {};

helper context UML2!Component def: corrispondingComponent : IM!Component =
	thisModule.IMSystem.components->select(e| e.Name = self.name)->first();
helper context UML2!Property def: corrispondingComponent : IM!Component =
	thisModule.IMSystem.components->select(e| e.Name = self.name)->first();

helper context CHESS!DependableComponent def : getName : String = self.base_Component.name;

helper context CHESS!StateBasedAnalysis def : getName : String = self.base_StructuredClassifier.name;

helper context UML2!Package def : getConnectors : Set(UML2!InstanceSpecification) = self.packagedElement->select(p | p.oclIsTypeOf(UML2!InstanceSpecification))->
			select(p | p.classifier.isEmpty());

helper context UML2!Package def : getInstances : Set(UML2!InstanceSpecification) = self.packagedElement->select(p | p.oclIsTypeOf(UML2!InstanceSpecification))->
			select(p | p.classifier.notEmpty());

helper context UML2!Package def : getComments : Set(UML2!InstanceSpecification) = self.getInstances->collect(p | p.classifier->first())->
			collect(p | p.ownedComment)->flatten();

helper context UML2!State def : getError : CHESS!Error =
			thisModule.Errors->select(e | e.base_State = self)->first();

helper context UML2!State def : getFailureMode : CHESS!FailureMode =
			thisModule.FailureModes->select(e | e.base_State = self)->first();

helper context UML2!Transition def : getInternalFault : CHESS!InternalFault =
			thisModule.InternalFaults->select(ift | ift.base_Transition = self)->first();

helper context UML2!State def : getCorrispondingError :  IM!Error =
			IM!Error.allInstances()->select(e | e.Name = self.name)->first();

helper context UML2!State def : getCorrispondingFailureMode :  IM!FailureMode =
			IM!FailureMode.allInstances()->select(e | e.Name = self.name)->first();

helper def : Components : Set(UML2!Component) = Set {};
helper def : Connectors : Set(UML2!InstanceSpecification) = Set {};
helper def : Comments : Set (UML2!Comment) = Set {};
helper def : Ports : Set (UML2!Port) = Set {};
helper def : States : Set(UML2!State) = Set{};
helper def : Transitions : Set(UML2!Tansition) = Set{};

helper def : SBAnalysis : CHESS!StateBasedAnalysis = OclUndefined;
helper def : Resources : UML2!Package = OclUndefined;

helper def : IMSystem : IM!Sistema = OclUndefined;

--counters starts from 1, not 0
helper def: Counter : Integer = 1;
helper def: CounterTwo : Integer = 1;
helper def: fgeCounter : Integer = 1;
helper def: epfCounter : Integer = 1;
helper def: ipCounter : Integer = 1;

helper context IM!FaultsExpressionFaultNode def: toString(): String = self.Fault.Name;
helper context IM!FaultsExpressionOrNode def: toString(): String = '(' + self.FaultsExpression1.toString() + ' OR ' + self.FaultsExpression2.toString() + ')';

helper context IM!ErrorsExpressionErrorNode def: toString(): String = self.Error.Name;
helper context IM!ErrorsExpressionOrNode def: toString(): String = '(' + self.ErrorsExpression1.toString() + ' OR ' + self.ErrorsExpression2.toString() + ')';



