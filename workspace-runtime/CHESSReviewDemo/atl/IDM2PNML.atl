-- @path IDM=/CHESSReviewDemo/metamodels/IM2.ecore
-- @path PNML=/CHESSReviewDemo/metamodels/placeTransition.ecore

module IDM2PNML;
create OUT : PNML from IN : IDM;

helper def: trCount : Integer = 1;
helper def: placeCount : Integer = 1;
helper def: arcCount : Integer = 1;
helper def: otherCount : Integer = 1;
helper def: timePoints : OrderedSet(Real) = OrderedSet{};

helper def: getPage : PNML!Page = IDM!Sistema.allInstances()->first();

helper def: tmpErrors : Sequence(IDM!Error) = Sequence{};
helper def: tmpLogicExp : PNML!LogicalExpression = OclUndefined;

helper context IDM!Error def: toString() : String = self.Name;
helper context IDM!FailureMode def: toString() : String = self.Name;

rule Sistema {
	from
		s : IDM!Sistema
	to
		pp: PNML!Page (
			id <- s.Name,
			objects <- Sequence{}
		),
		net: PNML!PetriNet (
			id <-  s.Name,
			pages <- Sequence{pp},
			type <- #GSPN
		),
		doc: PNML!PetriNetDoc (
			nets <- Sequence{net}
		),
		
		var : PNML!Variable (
			name <- 'Time'
		),
		varvals : PNML!VariableValues (
			variable <- var,
			values <- OrderedSet{}
		),
		study: PNML!Study (
			name <- 'DefaultStudy',
			vars <- Sequence{varvals}
		),
		evalList: PNML!EvaluationList (
			studies <- Sequence{study},
			measures <- PNML!Measure.allInstances()
		)
	do {
		for(i in IDM!InstantOfTime.allInstances()) {
			varvals.values <- varvals.values.append(i.timePoint);
		}
	}
}

-- Crea le distribuzioni
rule Exponential { from e : IDM!Exponential to ee : PNML!Exponential ( Rate <- e.Rate ) }
rule Deterministic { from d : IDM!Deterministic to dd : PNML!Deterministic ( Value <- d.Value ) }
rule Uniform { from u : IDM!Uniform to uu : PNML!Uniform ( Lower <- u.Lower, Upper <- u.Upper ) }
rule Gaussian { from g : IDM!Gaussian to gg : PNML!Gaussian ( Mean <- g.Mean, Variance <- g.Variance ) }
rule Gamma { from g : IDM!Gamma to gg : PNML!Gamma ( Alpha <- g.Alpha, Beta <- g.Beta ) }
rule Weibull { from w : IDM!Weibull to ww : PNML!Weibull ( Alpha <- w.Alpha, Beta <- w.Beta ) }

-- Regole per InternalFault
abstract rule InternalFault {
	from 
		ft : IDM!InternalFault
	to
		--Place
		faulty : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0),
			id <- ft.Name
		),
		transient : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0),
			id <- ft.Name + '_transient'	
		),
		tmpfaulty : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0),
			id <- ft.Name + '_tmp'			
		),
		
		e1 : PNML!OpEqual ( expression1 <- e2, expression2 <- e3 ),
		e2 : PNML!MarkingExpression ( place <- faulty ),
		e3 : PNML!ValueExpression ( value <- 0 ),
		
		--Transizioni (quelle per FO e TD vengono create dalle regole che estendono questa)
		casepermanent : PNML!GSPNImmediateTransition (
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_caseperm',
			Priority <- 1,
			Weight <- ft.PermanentProbability
		),
		casetransient : PNML!GSPNImmediateTransition (
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_casetrans',
			Priority <- 1,
			Weight <- (1 - ft.PermanentProbability)
		),		
		
		--Archi
		totmp : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			target <- tmpfaulty,
			id <- ft.Name + '_totmp'
		),
			--Permanent Fault
		tmp_to_permcase : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- tmpfaulty,
			target <- casepermanent,
			id <- ft.Name + '_tmp_to_permcase'	
		),
		permcase_to_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casepermanent,
			target <- faulty,
			id <- ft.Name + '_permcase_to_faulty'
		),
			--Transient Fault
		tmp_to_transcase : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- tmpfaulty,
			target <- casetransient,
			id <- ft.Name + '_tmp_to_transcase'	
		),
		transcase_to_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casetransient,
			target <- faulty,
			id <- ft.Name + '_transcase_to_faulty'				
		),
		transcase_to_transient : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casetransient,
			target <- transient,
			id <- ft.Name + '_transcase_to_transient'				
		),
		removetrans_trans : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- transient,
			id <- ft.Name + '_removetrans_trans'
		),
		removetrans_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- faulty,
			id <- ft.Name + '_removetrans_faulty'
		)		
	do {
		thisModule.makeUniqueID(faulty);
		thisModule.makeUniqueID(transient);
		thisModule.makeUniqueID(tmpfaulty);
		
		thisModule.makeUniqueID(casepermanent);
		thisModule.makeUniqueID(casetransient);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(tmp_to_permcase);
		thisModule.makeUniqueID(permcase_to_faulty);
		thisModule.makeUniqueID(tmp_to_transcase);
		thisModule.makeUniqueID(transcase_to_faulty);
		thisModule.makeUniqueID(transcase_to_transient);
		thisModule.makeUniqueID(removetrans_trans);
		thisModule.makeUniqueID(removetrans_faulty);
	}
}
rule InternalFaultTT extends InternalFault { --FO timed, TD timed
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occurrence.Value > 0 and ft.TransientDuration.Value > 0
				else
					ft.Occurrence.Value > 0
				endif
			else
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.TransientDuration.Value > 0
				else
					true
				endif
			endif
		)
	to
		e1 : PNML!OpEqual ( expression1 <- e2, expression2 <- e3 ),
		fo : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.Occurrence,
			id <- ft.Name + '_FO',
			Guard <- e1
		),
		td : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.TransientDuration,
			id <- ft.Name + '_TD'
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultII extends InternalFault { --FO immediate, TD immediate
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) and ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
				ft.Occurrence.Value = 0 and ft.TransientDuration.Value = 0
			else
				false
			endif
		)
	to
		fo : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_FO',
			Priority <- 1,
			Weight <- 1,
			Guard <- e1
		),
		td : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_TD',
			Priority <- 1,
			Weight <- 1
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultTI extends InternalFault { --FO timed, TD immediate
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occcurence.Value > 0 and ft.TransientDuration.Value = 0
				else
					false
				endif
			else
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.TransientDuration.Value = 0
				else
					false
				endif
			endif
		)
	to
		e1 : PNML!OpEqual ( expression1 <- e2, expression2 <- e3 ),
		fo : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.TransientDuration,
			id <- ft.Name + '_FO',
			Guard <- e1
		),
		td : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_TD',
			Priority <- 1,
			Weight <- 1
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultIT extends InternalFault { --FO immediate, TD timed
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occurrence.Value = 0 and ft.TransientDuration.Value > 0
				else
					ft.Occurrence.Value = 0
				endif
			else
				false
			endif
		)
	to
		e1 : PNML!OpEqual ( expression1 <- e2, expression2 <- e3 ),
		fo : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_FO',
			Priority <- 1,
			Weight <- 1,
			Guard <- e1
		),
		td : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.TransientDuration,
			id <- ft.Name + '_TD'
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}

rule Error { --manca l'implementazione di VanishingTime 
	from 
		e : IDM!Error
	to
		err : PNML!Place (
			id <- e.Name,
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0)
		)
	do {
		thisModule.makeUniqueID(err);
	}
}

rule FailureMode {
	from
		fm : IDM!FailureMode
	to
		fmode : PNML!Place (
			id <- fm.Name,
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0)			
		)
	do {
		thisModule.makeUniqueID(fmode);
	}
}

--FaultsExpression elements
rule FaultsExpressionFaultNode {
	from
		n : IDM!FaultsExpressionFaultNode
	to
		nn : PNML!OpGreater ( expression1 <- e1, expression2 <- e2 ),
		e1 : PNML!MarkingExpression (
			place <- 
			if n.Fault.oclIsTypeOf(IDM!InternalFault) then
				n.Fault
			else
				n.Fault.Source
			endif
		),
		e2 : PNML!ValueExpression ( value <- 0 )
}
rule FaultsExpressionNotNode {
	from
		n : IDM!FaultsExpressionNotNode
	to
		nn : PNML!OpNot ( expression <- n.FaultsExpression )
}
rule FaultsExpressionAndNode {
	from
		n : IDM!FaultsExpressionAndNode
	to
		nn : PNML!OpAnd ( e1 <- n.FaultsExpression1, e2 <- n.FaultsExpression2 )
}
rule FaultsExpressionOrNode {
	from
		n : IDM!FaultsExpressionOrNode
	to
		nn : PNML!OpOr ( e1 <- n.FaultsExpression1, e2 <- n.FaultsExpression2 )
}

rule FGETimed {
	from
		fge : IDM!FaultsGenerateErrors
		(
			if fge.ActivationDelay.oclIsTypeOf(IDM!Deterministic) then
				fge.ActivationDelay.Value > 0
			else
				true
			endif
		)
	to
		trfge : PNML!GSPNTimedTransition
		(
			id <- fge.Name,
			Distribution <- fge.ActivationDelay,
			containerPage <- thisModule.getPage
		),
		tmp : PNML!Place
		(
			id <- fge.Name + '_tmp',
			initialMarking <- thisModule.newPTMarking(0),
			containerPage <- thisModule.getPage
		),
		casepropagate : PNML!GSPNImmediateTransition
		(
			id <- fge.Name + '_caseprop',
			Weight <- fge.PropagationProbability,
			containerPage <- thisModule.getPage
		),
		caseskip : PNML!GSPNImmediateTransition
		(
			id <- fge.Name + '_caseskip',
			Weight <- ( 1 - fge.PropagationProbability ),
			containerPage <- thisModule.getPage
		),
		--Archi
		totmp : PNML!GSPNArc
		(
			id <- fge.Name + '_totmp',
			source <- trfge,
			target <- tmp,
			containerPage <- thisModule.getPage
		),
		topropagate : PNML!GSPNArc
		(
			id <- fge.Name + '_toprop',
			containerPage <- thisModule.getPage,
			source <- tmp,
			target <- casepropagate
		),
		toskip : PNML!GSPNArc
		(
			id <- fge.Name + '_toskip',
			containerPage <- thisModule.getPage,
			source <- tmp,
			target <- caseskip
		)
	do {
		thisModule.makeUniqueID(trfge);
		thisModule.makeUniqueID(tmp);
		thisModule.makeUniqueID(casepropagate);
		thisModule.makeUniqueID(caseskip);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(topropagate);
		thisModule.makeUniqueID(toskip);
		
		thisModule.tmpErrors = Sequence{};
		for(e in fge.Destination) {
			thisModule.newOutputArc(casepropagate, e);
			thisModule.tmpErrors <-	thisModule.tmpErrors.append(e);
		}
		for(e in thisModule.tmpErrors.) {
			
		}

		trfge.Guard = fge.PropagationLogic;
	}
}

--Crea un ID unico per Place, sTransizioni e Archi, aggiungendo un numero progressivo all'ID attuale
rule makeUniqueID(obj : PNML!PnObject) {
	do {
		if(obj.oclIsKindOf(PNML!Transition)) {
			obj.id <- 'T' + thisModule.trCount.toString() + '_' + obj.id;
			thisModule.trCount <- thisModule.trCount + 1;
		}
		else if(obj.oclIsKindOf(PNML!Place)) {
			obj.id <- 'P' + thisModule.placeCount.toString() + '_' + obj.id;
			thisModule.placeCount <- thisModule.placeCount + 1;
		}
		else if(obj.oclIsKindOf(PNML!Arc)) {
			obj.id <- 'A' + thisModule.arcCount.toString() + '_' + obj.id;
			thisModule.arcCount <- thisModule.arcCount + 1;
		}
		else {
			obj.id <- 'O' + thisModule.otherCount.toString() + '_' + obj.id;
			thisModule.otherCount <- thisModule.otherCount + 1;
		}		
	}
}

--Crea un oggeto PTMarking a partire da un numero intero
lazy rule newPTMarking {
	from
		v : Integer
	to
		m : PNML!PTMarking (
			text <- v
		)
}

--Evaluation types
rule InstantOfTime {
	from
		idm_instant : IDM!InstantOfTime
	to
		evaltype : PNML!InstantOfTime 
		(
			instant <- thisModule.newVariableExpression(PNML!Variable.allInstances()->select(v | v.name = 'Time').first())
		)
}
rule IntervalOfTime {
	from
		idm_interval : IDM!IntervalOfTime
	to
		evaltype : PNML!IntervalOfTimeCumulated
		(
			intervalBegin <- thisModule.newValueExpression(idm_interval.begin),
			intervalEnd <- thisModule.newVariableExpression(PNML!Variable.allInstances()->select(v | v.name = 'Time').first())
		)
}
--Measures of interest
rule MeasureToRewardFunction {
	from 
		idm_measure : IDM!DependabilityMeasure
	using {
		mexp : OrderedSet(PNML!MarkingExpression) = OrderedSet{};
		tmp : PNML!OpSum = OclUndefined; 
	}
	to
		measure : PNML!Measure
		(
			name <- idm_measure.Name,
			evaluationType <- idm_measure.evaluations.asSequence().first(),
			rewardFunction <- ite
		),
		ite : PNML!IfThenElse
		(
			condition <- cond,
			ifTrue <- thisModule.newValueExpression(1),
			ifFalse <- thisModule.newValueExpression(0)
		),
		cond : PNML!OpEqual
		(
			expression2 <- thisModule.newValueExpression(0)
			
		)
	do {
		if(idm_measure.target->size() = 1)
		{
			cond.expression1 <- thisModule.newMarkingExpressionFromFailureMode(idm_measure.target.asSequence().first());
		}
		else
		{
		--	cond.expression1 <- thisModule.newOpSum();
			for(i in idm_measure.target) {
				mexp = mexp->including(thisModule.newMarkingExpressionFromFailureMode(i));
			}
			tmp <- thisModule.newOpSum(mexp->at(1),mexp->at(2));
			cond.expression1 <- tmp;
			--cond.expression1 <- thisModule.newOpSum(thisModule.newMarkingExpression(idm_measure.target.asSequence().first()), OclUndefined);
			--tmp = cond.expression1;
			--TODO
		}
	}
}

lazy rule newVariableExpression {
	from 
		var : PNML!Variable
	to
		vexp : PNML!VariableExpression
		(
			variable <- var
		)
}
lazy rule newValueExpression {
	from
		v : Real
	to
		vexpr : PNML!ValueExpression ( value <- v )
}
lazy rule newMarkingExpressionFromFailureMode {
	from 
		f : IDM!FailureMode
	to
		m : PNML!MarkingExpression
		(
			place <- f
		)
}
lazy rule newMarkingExpressionFromError {
	from 
		e : IDM!Error
	to
		m : PNML!MarkingExpression
		(
			place <- e
		)
}
rule newOpSum( e1 : PNML!ArithmeticExpression, e2 : PNML!ArithmeticExpression) { 
	to
		sum : PNML!OpSum
		(
			expression1 <- e1,
			expression2 <- e2
		)
}
rule newOpAnd( ex1 : PNML!LogicalExpression, ex2 : PNML!LogicalExpression) { 
	to
		opand : PNML!OpAnd
		(
			e1 <- ex1,
			e2 <- ex2
		)
}
rule newOpOr( ex1 : PNML!LogicalExpression, ex2 : PNML!LogicalExpression) { 
	to
		opor : PNML!OpOr
		(
			e1 <- ex1,
			e2 <- ex2
		)
}

rule newOutputArc( t : PNML!GSPNTransition, p : PNML!Place ) { 
	to
		arc : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			source <- t,
			target <- p,
			id <- t.id + '_to_' + p.toString()
		)
}





