-- @path IDM=/CHESSReviewDemo/metamodels/IM2.ecore
-- @path PNML=/CHESSReviewDemo/metamodels/placeTransition.ecore

module IDM2PNML;
create OUT : PNML from IN : IDM;

helper def: trCount : Integer = 1;
helper def: placeCount : Integer = 1;
helper def: arcCount : Integer = 1;
helper def: otherCount : Integer = 1;
helper def: timePoints : OrderedSet(Real) = OrderedSet{};

helper def: getPage : PNML!Page = IDM!Sistema.allInstances()->first();
	
rule Sistema {
	from
		s : IDM!Sistema
	to
		pp: PNML!Page (
			id <- s.Name,
			objects <- Sequence{}
		),
		net: PNML!PetriNet (
			id <-  s.Name,
			pages <- Sequence{pp},
			type <- #GSPN
		),
		doc: PNML!PetriNetDoc (
			nets <- Sequence{net}
		),
		
		var : PNML!Variable (
			name <- 'Time'
		),
		varvals : PNML!VariableValues (
			variable <- var,
			values <- OrderedSet{}
		),
		study: PNML!Study (
			name <- 'DefaultStudy',
			vars <- Sequence{varvals}
		),
		evalList: PNML!EvaluationList (
			studies <- Sequence{study},
			measures <- PNML!Measure.allInstances()
		)
	do {
		for(i in IDM!InstantOfTime.allInstances()) {
			varvals.values <- varvals.values.append(i.timePoint);
		}
	}
}

-- Crea le transizioni basandomi sulle distribuzioni utilizzate
rule ImmediateTransition {
	from
		dist : IDM!Deterministic
		(
			dist.Value = 0
		)
	to
		tr : PNML!GSPNImmediateTransition (
			Priority <- 1,
			containerPage <- thisModule.getPage
		)
	do { 
		tr.id <- 'T' + thisModule.trCount + 'Immediate';
		thisModule.trCount <- thisModule.trCount + 1;
	}
}
rule DeterministicTransition {
	from
		dist : IDM!Deterministic
		(
			dist.Value > 0
		)
	to
		tr : PNML!GSPNTimedTransition (
			Distribution <- d,
			containerPage <- thisModule.getPage
		),
		d : PNML!Deterministic (
			Value <- dist.Value
		)
	do { 
		tr.id <- 'T' + thisModule.trCount + 'Deterministic';
		thisModule.trCount <- thisModule.trCount + 1;
	}
}
abstract rule TimedTransition {
	from
		dist : IDM!Distribution
		(
			not dist.oclIsTypeOf(IDM!Deterministic)	
		)
	to
		tr : PNML!GSPNTimedTransition (
			containerPage <- thisModule.getPage,
			id <- 'T' + thisModule.trCount + 'Timed'
		)
	do { 
		thisModule.trCount <- thisModule.trCount + 1;
	}
}
rule ExponentialTransition extends TimedTransition {
	from
		dist: IDM!Exponential
	to
		tr : PNML!GSPNTimedTransition (
			Distribution <- ee
		),
		ee : PNML!Exponential (
			Rate <- dist.Rate 
		)
}
rule GaussianTransition extends TimedTransition {
	from
		dist : IDM!Gaussian
	to
		tr : PNML!GSPNTimedTransition (
			Distribution <- gg
		),
		gg : PNML!Gaussian (
			Mean <- dist.Mean,
			Variance <- dist.Variance
		)
}
rule UniformTransition extends TimedTransition {
	from
		dist : IDM!Uniform
	to
		tr : PNML!GSPNTimedTransition (
			Distribution <- uu
		),
		uu : PNML!Uniform (
			Lower <- dist.Lower,
			Upper <- dist.Upper
		)
}
rule GammaTransition extends TimedTransition {
	from
		dist : IDM!Gamma
	to
		tr : PNML!GSPNTimedTransition (
			Distribution <- gg
		),
		gg : PNML!Gamma (
			Alpha <- dist.Alpha,
			Beta <- dist.Beta
		)
}
rule WeibullTransition extends TimedTransition {
	from
		dist : IDM!Weibull
	to
		tr : PNML!GSPNTimedTransition (
			Distribution <- ww
		),
		ww : PNML!Weibull (
			Alpha <- dist.Alpha,
			Beta <- dist.Beta
		)
}

rule InternalFault {
	from 
		ft : IDM!InternalFault
	using {
		fo : PNML!Transition = ft.Occurrence;
		td : PNML!Transition = ft.TransientDuration;
	}
	to
		--Place
		faulty : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.getPTMarking(0),
			id <- ft.Name
		),
		transient : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.getPTMarking(0),
			id <- ft.Name + '_transient'	
		),
		tmpfaulty : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.getPTMarking(0),
			id <- ft.Name + '_tmp'			
		),
		
		--Transizioni (in aggiunta a quelle create automaticamente per FO e TD)
		casepermanent : PNML!GSPNImmediateTransition (
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_caseperm',
			Priority <- 1,
			Weight <- ft.PermanentProbability
		),
		casetransient : PNML!GSPNImmediateTransition (
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_casetrans',
			Priority <- 1,
			Weight <- (1 - ft.PermanentProbability)
		),		
		
		--Archi
		totmp : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- fo,
			target <- tmpfaulty,
			id <- ft.Name + '_totmp'
		),
			--Permanent Fault
		tmp_to_permcase : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- tmpfaulty,
			target <- casepermanent,
			id <- ft.Name + '_tmp_to_permcase'	
		),
		permcase_to_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casepermanent,
			target <- faulty,
			id <- ft.Name + '_permcase_to_faulty'
		),
			--Transient Fault
		tmp_to_transcase : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- tmpfaulty,
			target <- casetransient,
			id <- ft.Name + '_tmp_to_transcase'	
		),
		transcase_to_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casetransient,
			target <- faulty,
			id <- ft.Name + '_transcase_to_faulty'				
		),
		transcase_to_transient : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casetransient,
			target <- transient,
			id <- ft.Name + '_transcase_to_transient'				
		)
	do {
		thisModule.makeUniqueID(faulty);
		thisModule.makeUniqueID(transient);
		thisModule.makeUniqueID(tmpfaulty);
		
		thisModule.makeUniqueID(casepermanent);
		thisModule.makeUniqueID(casetransient);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(tmp_to_permcase);
		thisModule.makeUniqueID(permcase_to_faulty);
		thisModule.makeUniqueID(tmp_to_transcase);
		thisModule.makeUniqueID(transcase_to_faulty);
		thisModule.makeUniqueID(transcase_to_transient);
	}
}

--Crea un ID unico per Place, Transizioni e Archi, aggiungendo un numero progressivo all'ID attuale
rule makeUniqueID(obj : PNML!PnObject) {
	do {
		if(obj.oclIsKindOf(PNML!Transition)) {
			obj.id <- 'T' + thisModule.trCount.toString() + '_' + obj.id;
			thisModule.trCount <- thisModule.trCount + 1;
		}
		else if(obj.oclIsKindOf(PNML!Place)) {
			obj.id <- 'P' + thisModule.placeCount.toString() + '_' + obj.id;
			thisModule.placeCount <- thisModule.placeCount + 1;
		}
		else if(obj.oclIsKindOf(PNML!Arc)) {
			obj.id <- 'A' + thisModule.arcCount.toString() + '_' + obj.id;
			thisModule.arcCount <- thisModule.arcCount + 1;
		}
		else {
			obj.id <- 'O' + thisModule.otherCount.toString() + '_' + obj.id;
			thisModule.otherCount <- thisModule.otherCount + 1;
		}		
	}
}

--Crea un oggeto PTMarking a partire da un numero intero
lazy rule getPTMarking {
	from
		v : Integer
	to
		m : PNML!PTMarking (
			text <- v
		)
}

