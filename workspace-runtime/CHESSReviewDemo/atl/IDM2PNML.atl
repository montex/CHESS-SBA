-- @path IDM=/CHESSReviewDemo/metamodels/IM2.ecore
-- @path PNML=/CHESSReviewDemo/metamodels/placeTransition.ecore

module IDM2PNML;
create OUT : PNML from IN : IDM;

helper def: trCount : Integer = 1;
helper def: placeCount : Integer = 1;
helper def: arcCount : Integer = 1;
helper def: otherCount : Integer = 1;
helper def: timePoints : OrderedSet(Real) = OrderedSet{};

helper def: getPage : PNML!Page = IDM!Sistema.allInstances()->first();
	
rule Sistema {
	from
		s : IDM!Sistema
	to
		pp: PNML!Page (
			id <- s.Name,
			objects <- Sequence{}
		),
		net: PNML!PetriNet (
			id <-  s.Name,
			pages <- Sequence{pp},
			type <- #GSPN
		),
		doc: PNML!PetriNetDoc (
			nets <- Sequence{net}
		),
		
		var : PNML!Variable (
			name <- 'Time'
		),
		varvals : PNML!VariableValues (
			variable <- var,
			values <- OrderedSet{}
		),
		study: PNML!Study (
			name <- 'DefaultStudy',
			vars <- Sequence{varvals}
		),
		evalList: PNML!EvaluationList (
			studies <- Sequence{study},
			measures <- PNML!Measure.allInstances()
		)
	do {
		for(i in IDM!InstantOfTime.allInstances()) {
			varvals.values <- varvals.values.append(i.timePoint);
		}
	}
}

-- Crea le distribuzioni
rule Exponential { from e : IDM!Exponential to ee : PNML!Exponential ( Rate <- e.Rate ) }
rule Deterministic { from d : IDM!Deterministic to dd : PNML!Deterministic ( Value <- d.Value ) }
rule Uniform { from u : IDM!Uniform to uu : PNML!Uniform ( Lower <- u.Lower, Upper <- u.Upper ) }
rule Gaussian { from g : IDM!Gaussian to gg : PNML!Gaussian ( Mean <- g.Mean, Variance <- g.Variance ) }
rule Gamma { from g : IDM!Gamma to gg : PNML!Gamma ( Alpha <- g.Alpha, Beta <- g.Beta ) }
rule Weibull { from w : IDM!Weibull to ww : PNML!Weibull ( Alpha <- w.Alpha, Beta <- w.Beta ) }

-- Regole per InternalFault
abstract rule InternalFault {
	from 
		ft : IDM!InternalFault
	to
		--Place
		faulty : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.getPTMarking(0),
			id <- ft.Name
		),
		transient : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.getPTMarking(0),
			id <- ft.Name + '_transient'	
		),
		tmpfaulty : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.getPTMarking(0),
			id <- ft.Name + '_tmp'			
		),
		
		--Transizioni (in aggiunta a quelle create automaticamente per FO e TD)
		casepermanent : PNML!GSPNImmediateTransition (
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_caseperm',
			Priority <- 1,
			Weight <- ft.PermanentProbability
		),
		casetransient : PNML!GSPNImmediateTransition (
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_casetrans',
			Priority <- 1,
			Weight <- (1 - ft.PermanentProbability)
		),		
		
		--Archi
		totmp : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			target <- tmpfaulty,
			id <- ft.Name + '_totmp'
		),
			--Permanent Fault
		tmp_to_permcase : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- tmpfaulty,
			target <- casepermanent,
			id <- ft.Name + '_tmp_to_permcase'	
		),
		permcase_to_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casepermanent,
			target <- faulty,
			id <- ft.Name + '_permcase_to_faulty'
		),
			--Transient Fault
		tmp_to_transcase : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- tmpfaulty,
			target <- casetransient,
			id <- ft.Name + '_tmp_to_transcase'	
		),
		transcase_to_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casetransient,
			target <- faulty,
			id <- ft.Name + '_transcase_to_faulty'				
		),
		transcase_to_transient : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casetransient,
			target <- transient,
			id <- ft.Name + '_transcase_to_transient'				
		),
		removetrans_trans : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- transient,
			id <- ft.Name + '_removetrans_trans'
		),
		removetrans_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- faulty,
			id <- ft.Name + '_removetrans_faulty'
		)		
	do {
		thisModule.makeUniqueID(faulty);
		thisModule.makeUniqueID(transient);
		thisModule.makeUniqueID(tmpfaulty);
		
		thisModule.makeUniqueID(casepermanent);
		thisModule.makeUniqueID(casetransient);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(tmp_to_permcase);
		thisModule.makeUniqueID(permcase_to_faulty);
		thisModule.makeUniqueID(tmp_to_transcase);
		thisModule.makeUniqueID(transcase_to_faulty);
		thisModule.makeUniqueID(transcase_to_transient);
		thisModule.makeUniqueID(removetrans_trans);
		thisModule.makeUniqueID(removetrans_faulty);
	}
}
rule InternalFaultTT extends InternalFault { --FO timed, TD timed
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occurrence.Value > 0 and ft.TransientDuration.Value > 0
				else
					ft.Occurrence.Value > 0
				endif
			else
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.TransientDuration.Value > 0
				else
					true
				endif
			endif
		)
	to
		fo : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.Occurrence,
			id <- ft.Name + '_FO'
		),
		td : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.TransientDuration,
			id <- ft.Name + '_TD'
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultII extends InternalFault { --FO immediate, TD immediate
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) and ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
				ft.Occurrence.Value = 0 and ft.TransientDuration.Value = 0
			else
				false
			endif
		)
	to
		fo : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_FO',
			Priority <- 1,
			Weight <- 1
		),
		td : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_TD',
			Priority <- 1,
			Weight <- 1
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultTI extends InternalFault { --FO timed, TD immediate
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occcurence.Value > 0 and ft.TransientDuration.Value = 0
				else
					false
				endif
			else
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.TransientDuration.Value = 0
				else
					false
				endif
			endif
		)
	to
		fo : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.TransientDuration,
			id <- ft.Name + '_FO'
		),
		td : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_TD',
			Priority <- 1,
			Weight <- 1
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultIT extends InternalFault { --FO immediate, TD timed
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occurrence.Value = 0 and ft.TransientDuration.Value > 0
				else
					ft.Occurrence.Value = 0
				endif
			else
				false
			endif
		)
	to
		fo : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_FO',
			Priority <- 1,
			Weight <- 1
		),
		td : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.TransientDuration,
			id <- ft.Name + '_TD'
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}

--Crea un ID unico per Place, Transizioni e Archi, aggiungendo un numero progressivo all'ID attuale
rule makeUniqueID(obj : PNML!PnObject) {
	do {
		if(obj.oclIsKindOf(PNML!Transition)) {
			obj.id <- 'T' + thisModule.trCount.toString() + '_' + obj.id;
			thisModule.trCount <- thisModule.trCount + 1;
		}
		else if(obj.oclIsKindOf(PNML!Place)) {
			obj.id <- 'P' + thisModule.placeCount.toString() + '_' + obj.id;
			thisModule.placeCount <- thisModule.placeCount + 1;
		}
		else if(obj.oclIsKindOf(PNML!Arc)) {
			obj.id <- 'A' + thisModule.arcCount.toString() + '_' + obj.id;
			thisModule.arcCount <- thisModule.arcCount + 1;
		}
		else {
			obj.id <- 'O' + thisModule.otherCount.toString() + '_' + obj.id;
			thisModule.otherCount <- thisModule.otherCount + 1;
		}		
	}
}

--Crea un oggeto PTMarking a partire da un numero intero
lazy rule getPTMarking {
	from
		v : Integer
	to
		m : PNML!PTMarking (
			text <- v
		)
}

