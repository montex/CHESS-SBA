-- @path PNML=CHESSReviewDemo/metamodels/placeTransition.ecore
-- @path IM2=CHESSReviewDemo/metamodels/IM2.ecore

module IDM2PNML;

create out1: PNML from in1: IM2;

helper def: myid : Integer = 0;
helper def: timePoints : OrderedSet(Real) = OrderedSet{};

helper def: faultPropagationLogic : Map(String, PNML!Place) = Map{};
helper def: faultPropagationManager : Map(String, IM2!FaultsGenerateError) = Map{};

helper def: errorPropagationLogic : Map(String, PNML!Place) = Map{};
helper def: errorPropagationManager : Map(String, IM2!ErrorPropagation) = Map{};

helper def: registerFaultPropagationLogic(s: String, p:PNML!Place) : Boolean = 
	let map : Map(String, PNML!Place) = Map{(s, p)} in
		thisModule.faultPropagationLogic = thisModule.faultPropagationLogic.including(map);
helper def: registerFaultPropagationManager(s: String, m:IM2!FaultsGenerateError) : Boolean = 
	let map : Map(String, IM2!FaultsGenerateError) = Map{(s, m)} in
		thisModule.faultPropagationLogic = thisModule.faultPropagationManager.including(map);
helper def: getFaultPropagationLogic(m: IM2!FaultsGenerateError): PNML!Place =
	let place : PNML!Place = thisModule.faultPropagationLogic.get(m.PropagationLogicStringFormat) in
		if (place=OclUndefined) then
			let manager : IM2!FaultsGenerateError =  thisModule.faultPropagationManager.get(m.PropagationLogicStringFormat) in
				if (manager=OclUndefined) then
					m.PropagationLogic
				else
					manager.PropagationLogic
				endif
		else 
			place
		endif;
	
helper def: registerErrorPropagationLogic(s: String, p:PNML!Place) : Boolean = 
	let map : Map(String, PNML!Place)  = Map{(s,p)} in
		thisModule.errorPropagationLogic = thisModule.errorPropagationLogic.including(map);
helper def: registerErrorPropagationManager(s: String, m:IM2!ErrorPropagation) : Boolean = 
	let map : Map(String, IM2!ErrorPropagation) = Map{(s, m)} in
		thisModule.errorPropagationManager = thisModule.errorPropagationManager.including(map);
helper def: getErrorPropagationLogic(m: IM2!ErrorPropagation): PNML!Place =
	let place : PNML!Place = thisModule.errorPropagationLogic.get(m.PropagationLogicStringFormat) in
		if (place=OclUndefined) then
			let manager : IM2!ErrorPropagation =  thisModule.errorPropagationManager.get(m.PropagationLogicStringFormat) in
				if (manager=OclUndefined) then
					m.PropagationLogic
				else
					manager.PropagationLogic
				endif
		else 
			place
		endif;

helper def: page : PNML!Page = OclUndefined;

helper def: getPage(s:IM2!Sistema) : PNML!Page = s; 
--	if (thisModule.page = OclUndefined) then
--		thisModule.Sistema(s)
--	else
--		thisModule.page
--	endif;
	
-- IM2!FaultsExpressionNode helper context
helper context IM2!FaultsExpressionFaultNode def: toString() : String =
	'Fault('+self.Fault.name+')';

helper context IM2!FaultsExpressionAndNode def: toString() : String =
	'('+self.FaultsExpression1.toString()+') AND ('+self.FaultsExpression2.toString()+')';

helper context IM2!FaultsExpressionOrNode def: toString() : String =
	'('+self.FaultsExpression1.toString()+') OR ('+self.FaultsExpression2.toString()+')';

helper context IM2!FaultsExpressionNotNode def: toString() : String =
	'NOT ('+self.FaultsExpression.toString()+')';

-- IM2!ErrorsExpressionNode helper context
helper context IM2!ErrorsExpressionErrorNode def: toString() : String =
	'Error('+self.Error.name+')';

helper context IM2!ErrorsExpressionNotNode def: toString() : String =
	'NOT ('+self.ErrorsExpression.toString()+')';

helper context IM2!ErrorsExpressionAndNode def: toString() : String =
	'('+self.ErrorsExpression1.toString()+') AND ('+self.ErrorsExpression2.toString()+')';

helper context IM2!ErrorsExpressionOrNode def: toString() : String =
	'('+self.ErrorsExpression1.toString()+') OR ('+self.ErrorsExpression2.toString()+')';

helper context IM2!Distribution def: getComponent():IM2!Component =
	let OwnerInternalFault:IM2!InternalFault = IM2!InternalFault.allInstances()->select(s | s.Occurrence=self)->asSequence()->first() in
	if (OwnerInternalFault <> OclUndefined) then
		OwnerInternalFault.Component
	else
		let OwnerInternalFault2:IM2!InternalFault = IM2!InternalFault.allInstances()->select(s | s.TransientDuration=self)->asSequence()->first() in
		if (OwnerInternalFault2 <> OclUndefined) then
			OwnerInternalFault2.Component
		else
			let Errore:IM2!Error = IM2!Error.allInstances()->select(s | s.VanishingTime=self)->asSequence()->first() in
			if (Errore <> OclUndefined) then
				Errore.Component
			else
				let InternalProp:IM2!InternalPropagation = IM2!InternalPropagation.allInstances()->select(s | s.PropagationDelay=self)->asSequence()->first() in
				if (InternalProp <> OclUndefined) then
					InternalProp.Component
				else
					let ErrorsProducesFailure:IM2!ErrorsProducesFailures = IM2!ErrorsProducesFailures.allInstances()->select(s | s.PropagationDelay=self)->asSequence()->first() in
					if (ErrorsProducesFailure <> OclUndefined) then
						ErrorsProducesFailure.Component
					else
						let FaultsGenerateErrors:IM2!FaultsGenerateErrors = IM2!FaultsGenerateErrors.allInstances()->select(s | s.ActivationDelay=self)->asSequence()->first() in
						if (FaultsGenerateErrors <> OclUndefined) then
							FaultsGenerateErrors.Component
						else
							OclUndefined
						endif
					endif
				endif
			endif
		endif
	endif;

					
helper context IM2!Distribution def: getComponentsRule():String =
	let OwnerInternalFault:IM2!InternalFault = IM2!InternalFault.allInstances()->select(s | s.Occurrence=self)->asSequence()->first() in
	if (OwnerInternalFault <> OclUndefined) then
		'internal_fault_'+OwnerInternalFault.Component.Name+'_'+OwnerInternalFault.Name+'_occurrence'
	else
		let OwnerInternalFault2:IM2!InternalFault = IM2!InternalFault.allInstances()->select(s | s.TransientDuration=self)->asSequence()->first() in
		if (OwnerInternalFault2 <> OclUndefined) then
			'internal_fault_'+OwnerInternalFault2.Component.Name+'_'+OwnerInternalFault2.Name+'_transient_duration_time'
		else
			let Errore:IM2!Error = IM2!Error.allInstances()->select(s | s.VanishingTime=self)->asSequence()->first() in
			if (Errore <> OclUndefined) then
				'internal_fault_'+Errore.Component.Name+'_'+Errore.Name+'_vanishing_time'
			else
				let InternalProp:IM2!InternalPropagation = IM2!InternalPropagation.allInstances()->select(s | s.PropagationDelay=self)->asSequence()->first() in
				if (InternalProp <> OclUndefined) then
					'internal_propagation_'+InternalProp.Component.Name+'_'+InternalProp.Name+'_propagation_delay'
				else
					let ErrorsProducesFailure:IM2!ErrorsProducesFailures = IM2!ErrorsProducesFailures.allInstances()->select(s | s.PropagationDelay=self)->asSequence()->first() in
					if (ErrorsProducesFailure <> OclUndefined) then
						'errors_produces_failure_'+ErrorsProducesFailure.Component.Name+'_'+ErrorsProducesFailure.Name+'_propagation_delay'
					else
						let FaultsGenerateErrors:IM2!FaultsGenerateErrors = IM2!FaultsGenerateErrors.allInstances()->select(s | s.ActivationDelay=self)->asSequence()->first() in
						if (FaultsGenerateErrors <> OclUndefined) then
							'faults_generate_errors_'+FaultsGenerateErrors.Component.Name+'_'+FaultsGenerateErrors.Name+'_activation_delay'
						else
							OclUndefined
						endif
					endif
				endif
			endif
		endif
	endif;

helper context IM2!Distribution def: getActivitysRule():String = 
	let OwnerActivity:IM2!Activity = IM2!Activity.allInstances()->select(s | s.Duration=self)->asSequence()->first() in
	if (OwnerActivity<> OclUndefined) then
		'activity_'+OwnerActivity.Name+'_duration'
	else
		let OwnerSchedulePeriodic:IM2!SchedulePeriodic = IM2!SchedulePeriodic.allInstances()->select(s | s.Distribution=self)->asSequence()->first() in
		if (OwnerActivity<> OclUndefined) then
			'schedule_periodic_'+OwnerSchedulePeriodic.Activity.Name+'_'+OwnerSchedulePeriodic.Name+'_distribution'
		else
			OclUndefined
		endif
	endif;
					
helper context IM2!Distribution def: getSistema():IM2!Sistema =
	let OwnerComponent:IM2!Component = self.getComponent() in
	if (OwnerComponent <> OclUndefined) then
		OwnerComponent.intermediateModel
	else
--		let OwnerActivity:IM2!Activity = self.getActivity() in
--		if (OwnerActivity<> OclUndefined) then
--			OwnerActivity.Sistema
--		else
			OclUndefined
--		endif
	endif;

helper context IM2!Distribution def: getRule():String =
	let ComponentRule:String = self.getComponentsRule() in
	if (ComponentRule <> OclUndefined) then
		ComponentRule
	else
--		let ActivityRule:String = self.getActivitysRule() in
--		if (ActivityRule<> OclUndefined) then
--			ActivityRule
--		else
			OclUndefined
--		endif
	endif;

	
	
rule Sistema {
	from
		sistema : IM2!Sistema
	to
		gspnpage: PNML!Page (
			containerPetriNet<-gspnnet
		),
		gspndoc: PNML!PetriNetDoc (
			nets<-gspnnet
		),
		gspnnet: PNML!PetriNet(
			id<-sistema.Name,
			type<-#PTNET,
			pages<-gspnpage,
			containerPetriNetDoc<-gspndoc
		),
		
		var : PNML!Variable (
			name <- 'Time'
		),
		varvals : PNML!VariableValues (
			variable <- var,
			values <- OrderedSet{}
		),
		study: PNML!Study (
			name <- 'DefaultStudy',
			vars <- Sequence{varvals}
		),
		evalList: PNML!EvaluationList (
			studies <- Sequence{study},
			measures <- PNML!Measure.allInstances()
		)
	do {
		thisModule.page = gspnpage;
		
		for(i in IM2!InstantOfTime.allInstances()) {
			varvals.values <- varvals.values.append(i.timePoint);
		}
	}
}

-- Componenti con rimpiazzo devono essere gestiti in modo speciale, le transizioni esterne cui fanno riferimento dovrebbero non essere a conoscenza
-- del componente attuale che fornisce il servizio
rule ComponentWithOutReplace {
	from
		componente : IM2!Component
	to
		failed_place : PNML!Place (
				id <- 'failed_'+componente.Name,
				name <- failed_place_name,
				initialMarking <- failed_place_markup,
				containerPage <- componente.intermediateModel
		),
		failed_place_markup : PNML!PTMarking (
				text <- 0
		),
		failed_place_name : PNML!Name (
				text <- 'failed_'+componente.Name
		)
}

---------------------------------------------------------------------------------------------------
-- Crea le transizioni basandomi sulle distribuzioni utilizzate
---------------------------------------------------------------------------------------------------
rule ImmediateTransition {
	from
		distribuzione : IM2!Deterministic
		(
			distribuzione.Value = 0
		)
	to
		transizione : PNML!GSPNImmediateTransition (
			id <- distribuzione.getRule(),
			Priority <- 1,
			containerPage<-distribuzione.getSistema()
		)
}
rule DeterministicTransition {
	from
		distribuzione : IM2!Deterministic
		(
			distribuzione.Value > 0
		)
	to
		transizione : PNML!GSPNTimedTransition (
			id <- distribuzione.getRule(),
			Distribution <- distribuzione_gspn,
			containerPage<-distribuzione.getSistema()
		),
		distribuzione_gspn : PNML!Deterministic (
			Value <- distribuzione.Value
		)
}
rule ExponentialTransition {
	from
		distribuzione : IM2!Exponential
	to
		transizione : PNML!GSPNTimedTransition (
			id <- distribuzione.getRule(),
			Distribution <- distribuzione_gspn,
			containerPage<- distribuzione.getSistema()
		),
		distribuzione_gspn : PNML!Exponential (
			Rate <- distribuzione.Rate
		)
}
rule GaussianTransition {
	from
		distribuzione : IM2!Gaussian
	to
		transizione : PNML!GSPNTimedTransition (
			id <- distribuzione.getRule(),
			Distribution <- distribuzione_gspn,
			containerPage<- distribuzione.getSistema()
		),
		distribuzione_gspn : PNML!Gaussian (
			Mean <- distribuzione.Mean,
			Variance <- distribuzione.Variance
		)
}
rule UniformTransition {
	from
		distribuzione : IM2!Uniform
	to
		transizione : PNML!GSPNTimedTransition (
			id <- distribuzione.getRule(),
			Distribution <- distribuzione_gspn,
			containerPage<- distribuzione.getSistema()
		),
		distribuzione_gspn : PNML!Uniform (
			Lower <- distribuzione.Lower,
			Upper <- distribuzione.Upper
		)
}
rule GammaTransition {
	from
		distribuzione : IM2!Gamma
	to
		transizione : PNML!GSPNTimedTransition (
			id <- distribuzione.getRule(),
			Distribution <- distribuzione_gspn,
			containerPage<- distribuzione.getSistema()
		),
		distribuzione_gspn : PNML!Gamma (
			Alpha <- distribuzione.Alpha,
			Beta <- distribuzione.Beta
		)
}
rule WeibullTransition {
	from
		distribuzione : IM2!Weibull
	to
		transizione : PNML!GSPNTimedTransition (
			id <- distribuzione.getRule(),
			Distribution <- distribuzione_gspn,
			containerPage<- distribuzione.getSistema()
		),
		distribuzione_gspn : PNML!Weibull (
			Alpha <- distribuzione.Alpha,
			Beta <- distribuzione.Beta
		)
}

-- Connette la transizione per rappresentare un fallimento con probabilita' di guasto permanente 
rule ComponentInternalFault {
	from
		fault : IM2!InternalFault
	using {
			componente : IM2!Component = fault.Component;
			sistema : IM2!Sistema = componente.intermediateModel;
			page : PNML!Page = sistema;
	}
	to
-- Crea il place per rappresentare il fallimento corrente del componente
		faulty_place : PNML!Place (
			id <- 'faultyPlace_'+componente.Name+'_'+fault.Name,
			name <- faulty_place_name,
			initialMarking <- faulty_place_markup,
			containerPage<- thisModule.getPage(sistema)
		),
		faulty_place_markup : PNML!PTMarking (
				text <- 0
		),
		faulty_place_name : PNML!Name (
				text <- 'faultyPlace_'+componente.Name+'_'+fault.Name
		),

-- Crea il place che conteggia il numero di fault transienti
		numberOfTransientFault_place_markup : PNML!PTMarking (
				text <- 0
		),
		numberOfTransientFault_place_name : PNML!Name (
				text <- 'numberOfTransientFaultyPlace_'+componente.Name+'_'+fault.Name
		),
		numberOfTransientFault_place : PNML!Place (
				id <- 'numberOfTransientFaultyPlace_'+componente.Name+'_'+fault.Name,
				name <- numberOfTransientFault_place_name,
				initialMarking <- numberOfTransientFault_place_markup,
				containerPage <- thisModule.getPage(sistema)
		),


-- Creo l'arco che va' dallo stato failed alla transizione per il fallimento, se il componente
-- non è fallito, si possono generare fallimenti
		transaction_to_fault_from_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_fault_from_arc: PNML!GSPNArc (
				id<-'faultyPlace_'+componente.Name+'_'+fault.Name+'_from_healtyPlace',
				source<-componente,
				target<-fault.Occurrence,
				type<-#inhibitor,
				inscription<-transaction_to_fault_from_arc_annotation,
				containerPage<-thisModule.getPage(sistema)
		),

-- Crea un place d'appoggio che contiene un token se si verfica un fault
		tmp_occurred_place : PNML!Place (
			id <- 'internal_fault_occurred_'+componente.Name+'_'+fault.Name,
			name <- tmp_occurred_place_name,
			initialMarking <- tmp_occurred_place_markup,
			containerPage<- thisModule.getPage(sistema)
		),
		tmp_occurred_place_markup : PNML!PTMarking (
				text <- 0
		),
		tmp_occurred_place_name : PNML!Name (
				text <- 'internal_fault_occurred_'+componente.Name+'_'+fault.Name
		),
		
-- Creo l'arco che va' dallo stato failed alla transizione per il fallimento, se il componente
-- non � fallito, si possono generare fallimenti
		from_occurrence_to_tmp_occurred_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		from_occurrence_to_tmp_occurred_place_arc: PNML!GSPNArc (
				id<-'internal_fault_'+componente.Name+'_'+fault.Name+'_from_occurrence_to_tmp_occurred_place',
				source<-fault.Occurrence,
				target<-tmp_occurred_place,
				type<-#normal,
				inscription<-from_occurrence_to_tmp_occurred_place_arc_annotation,
				containerPage<-thisModule.getPage(sistema)
		),


		
-- Crea case per un fault permanente
		permanent_fault_case : PNML!GSPNImmediateTransition (
			id <- 'internal_fault_'+componente.Name+'_'+fault.Name+'_permanent_fault',
			Priority <- 1,
			Weight <-fault.PermanentProbability,
			containerPage<-thisModule.getPage(sistema)
		),

-- Creo l'arco che va' dal place tmp_occurred_fault alla transizione che attiva il fault permanente
		from_tmp_occurred_place_to_permanent_fault_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		from_tmp_occurred_place_to_permanent_fault_arc: PNML!GSPNArc (
				id<-'internal_fault_'+componente.Name+'_'+fault.Name+'_from_tmp_occurred_place_to_permanent_fault',
				source<-tmp_occurred_place,
				target<-permanent_fault_case,
				type<-#normal,
				inscription<-from_tmp_occurred_place_to_permanent_fault_arc_annotation,
				containerPage<-thisModule.getPage(sistema)
		),
		
-- Crea case per un fault transiente
		transient_fault_case : PNML!GSPNImmediateTransition (
			id <- 'internal_fault_'+componente.Name+'_'+fault.Name+'_transient_fault',
			Priority <- 1,
			Weight <- 1-fault.PermanentProbability,
			containerPage<-thisModule.getPage(sistema)
		),

-- Creo l'arco che va' dal place tmp_occurred_fault alla transizione che attiva il fault permanente
		from_tmp_occurred_place_to_transient_fault_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		from_tmp_occurred_place_to_transient_fault_arc: PNML!GSPNArc (
				id<-'internal_fault_'+componente.Name+'_'+fault.Name+'_from_tmp_occurred_place_to_transient_fault',
				source<-tmp_occurred_place,
				target<-transient_fault_case,
				type<-#normal,
				inscription<-from_tmp_occurred_place_to_transient_fault_arc_annotation,
				containerPage<-thisModule.getPage(sistema)
		),
		
		
-- Crea l'arco uscente dal case permanente
		transaction_to_permanent_fault_to_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_permanent_fault_to_arc: PNML!GSPNArc (
				id<-'permanent_faultyPlace_'+componente.Name+'_'+fault.Name+'_to_tmp_faultyPlace',
				source<-permanent_fault_case,
				target<-faulty_place,
				type<-#normal,
				inscription <- transaction_to_permanent_fault_to_arc_annotation,
				containerPage <- thisModule.getPage(sistema)
		),

-- Crea l'arco uscente del case transiente che mette un place in fualt
		transaction_to_transient_fault_to_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_transient_fault_to_arc: PNML!GSPNArc (
				id<-'transient_faultyPlace_'+componente.Name+'_'+fault.Name+'_to_tmp_faultyPlace',
				source<-transient_fault_case,
				target<-faulty_place,
				type<-#normal,
				inscription <- transaction_to_transient_fault_to_arc_annotation,
				containerPage <- thisModule.getPage(sistema)
		),
	
-- Creo l'arcuo uscnte dal case transiente che mette un token in numberOfTransientFault_place
		transaction_to_transient_fault_to_numberOfFaults_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_transient_fault_to_numberOfFaults_arc: PNML!GSPNArc (
				id<-'transient_faultyPlace_'+componente.Name+'_'+fault.Name+'_to_numberOfFaults',
				source<-transient_fault_case,
				target<-numberOfTransientFault_place,
				type<-#normal,
				inscription <- transaction_to_transient_fault_to_numberOfFaults_arc_annotation,
				containerPage <- thisModule.getPage(sistema)
		),


-- Crea gli archi in entrata per la transizione che elimina gli errori transitori
-- Creo arco numberOfTransientFault_place->transaction_remove_transient_fault
transaction_remove_transient_fault_from_numberOfTransientFault_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_remove_transient_fault_from_numberOfTransientFault_arc: PNML!GSPNArc (
				id<-'remove_transient_fault_'+componente.Name+'_'+fault.Name+'_arc_from_numberOfTransientFault',
				source<-numberOfTransientFault_place,
				target<-fault.TransientDuration,
				type<-#normal,
				inscription <- transaction_remove_transient_fault_from_numberOfTransientFault_arc_annotation,
				containerPage <- thisModule.getPage(sistema)
		),
-- Creo arco faulty_place->transaction_remove_transient_fault
		transaction_remove_transient_fault_from_faulty_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_remove_transient_fault_from_faulty_arc: PNML!GSPNArc (
				id<-'remove_transient_fault_'+componente.Name+'_'+fault.Name+'_arc_from_faulty',
				source<-faulty_place,
				target<-fault.TransientDuration,
				type<-#normal,
				inscription<-transaction_remove_transient_fault_from_faulty_arc_annotation,
				containerPage <- thisModule.getPage(sistema)
		)
		
		
	do {
		thisModule.removeTokenOnFailed(componente, faulty_place, fault.Name, componente);
		thisModule.removeTokenOnFailed(componente, numberOfTransientFault_place, fault.Name, componente);
	}
}
rule ComponentExternalFault {
	from
		fault : IM2!ExternalFault
	using {
		componente : IM2!Component = fault.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
		}
	to
-- Crea il place per rappresentare il fault esterno del componente
		faulty_place : PNML!Place (
--				id <- 'faultyPlace_'+componente.Name+'_'+fault.Name,
				name <- faulty_place_name,
				initialMarking <- faulty_place_markup,
				containerPage <- sistema
		),
		faulty_place_markup : PNML!PTMarking (
				text <- 0
		),
		faulty_place_name : PNML!Name (
				text <- 'faultyPlace_'+componente.Name+'_'+fault.Name
		),
-- Creo la transizione che fa' scattare il fault
		transaction_to_fault : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che va' dallo stato healty alla transizione per il fallimento
		transaction_to_fault_from_healty_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_fault_from_healty_arc: PNML!GSPNArc (
	--			id<-'faultyPlace_'+componente.Name+'_'+fault.Name+'_from_failedPlace',
				source<-componente,
				target<-transaction_to_fault,
				type<-#inhibitor,
				inscription<-transaction_to_fault_from_healty_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che va' dal failureMode alla transizione per il fallimento
		transaction_to_fault_from_failureMode_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_fault_from_failureMode_arc: PNML!GSPNArc (
	--			id<-'faultyPlace_'+componente.Name+'_'+fault.Name+'_from_failureModePlace_'+fault.Source.Name,
				source<-fault.Source,
				target<-transaction_to_fault,
				type<-#normal,
				inscription<-transaction_to_fault_from_failureMode_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che rimette il token in failureMode
		transaction_to_fault_to_failureMode_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_fault_to_failureMode_arc: PNML!GSPNArc (
	--			id<-'faultyPlace_'+componente.Name+'_'+fault.Name+'_to_failureModePlace',
				source<-transaction_to_fault,
				target<-fault.Source,
				type<-#normal,
				inscription<-transaction_to_fault_to_failureMode_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco uscente che mette un token su faultyPlace
		transaction_to_fault_to_faultyPlace_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_fault_to_faultyPlace_arc: PNML!GSPNArc (
	--			id<-'faultyPlace_'+componente.Name+'_'+fault.Name+'_to_faultyPlace',
				source<-transaction_to_fault,
				target<-faulty_place,
				type<-#normal,
				inscription<-transaction_to_fault_to_faultyPlace_arc_annotation,
				containerPage <- sistema
		),
-- Creo un arco inibitore entrante che non permette di accumulare token su faultyPlace
		transaction_to_fault_from_faultyPlace_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_fault_from_faultyPlace_arc: PNML!GSPNArc (
	--			id<-'faultyPlace_'+componente.Name+'_'+fault.Name+'_to_faultyPlace',
				source<-faulty_place,
				target<-transaction_to_fault,
				type<-#inhibitor,
				inscription<-transaction_to_fault_from_faultyPlace_arc_annotation,
				containerPage <- sistema
		)
		
		do {
			for(n in PNML!PnObject.allInstances()->select(i | i.id.oclIsUndefined())) {
				thisModule.myid <- thisModule.myid + 1;
				n.id <- 'ComponentExternalFault_'+thisModule.myid.toString();
			}
			
			thisModule.removeTokenOnFailed(componente, faulty_place, fault.Name, thisModule.resolveTemp(componente, 'failed_place'));
		}
}
rule ComponentErrorWithVanishingTime {
	from
		error : IM2!Error
		(
			not error.VanishingTime.oclIsUndefined()
		)	
	using
	{
		componente : IM2!Component = error.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
		vanisishing_transition : PNML!GSPNTimedTransition = thisModule.resolveTemp(error.VanishingTime, 'transizione');
	}
	to
-- Creo il place che rappresenta l'errore latente nel componente
		erroneus_place : PNML!Place (
			id <- 'erroneusPlace_'+componente.Name+'_'+error.Name,
			name <- erroneus_place_name,
			initialMarking <- erroneus_place_markup,
			containerPage <- componente.intermediateModel
		),
erroneus_place_markup : PNML!PTMarking (
			text <- 0
		),
		erroneus_place_name : PNML!Name (
			text <- 'erroneusPlace_'+componente.Name+'_'+error.Name
		),
-- Creo l'arco che consente di eliminare il token dal erroneus_place se sono presenti dei meccanismi di compezzazione
		vanishing_transition_from_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		vanishing_transition_from_arc: PNML!GSPNArc (
			id<-'erroneusPlace_'+componente.Name+'_'+error.Name+'_to_vanishing_transition',
			source<-erroneus_place,
			target<-vanisishing_transition,
			type<-#normal,
			inscription<-vanishing_transition_from_arc_annotation,
			containerPage <- sistema
		),
		detect_error_place : PNML!Place (
			id <- 'detect_error_Place_'+componente.Name+'_'+error.Name,
			name <- detect_error_place_name,
			initialMarking <- detect_error_place_markup,
			containerPage <- componente.intermediateModel
		),
		detect_error_place_markup : PNML!PTMarking (
			text <- 0
		),
		detect_error_place_name : PNML!Name (
			text <- 'detect_error_Place_'+componente.Name+'_'+error.Name
		)
	do
	{
		thisModule.removeTokenOnFailed(componente, erroneus_place, error.name, thisModule.resolveTemp(componente, 'failed_place'));
	}
}
rule ComponentErrorWithOutVanishingTime {
	from
		error : IM2!Error
		(
			error.VanishingTime.oclIsUndefined()
		)
	using
	{
		componente : IM2!Component = error.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
	}
	to
-- Creo il place che rappresenta l'errore latente nel componente
		erroneus_place : PNML!Place (
			id <- 'erroneusPlace_'+componente.Name+'_'+error.Name,
			name <- erroneus_place_name,
			initialMarking <- erroneus_place_markup,
			containerPage <- componente.intermediateModel
		),
		erroneus_place_markup : PNML!PTMarking (
			text <- 0
		),
		erroneus_place_name : PNML!Name (
			text <- 'erroneusPlace_'+componente.Name+'_'+error.Name
		),
		detect_error_place : PNML!Place (
			id <- 'detect_error_Place_'+componente.Name+'_'+error.Name,
			name <- detect_error_place_name,
			initialMarking <- detect_error_place_markup,
			containerPage <- componente.intermediateModel
		),
		detect_error_place_markup : PNML!PTMarking (
			text <- 0
		),
		detect_error_place_name : PNML!Name (
			text <- 'detect_error_Place_'+componente.Name+'_'+error.Name
		)
		
	do {
		thisModule.removeTokenOnFailed(componente, erroneus_place, error.Name, thisModule.resolveTemp(componente, 'failed_place'));
	}
}
rule ComponentFailureMode {
	from
		failureMode : IM2!FailureMode
	using
	{
		componente : IM2!Component = failureMode.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
	}
	to
		failureMode_place : PNML!Place (
				id <- 'failureMode_'+componente.Name+'_'+failureMode.Name,
				name <- failureMode_place_name,
				initialMarking <- failureMode_place_markup,
				containerPage <- componente.intermediateModel
		),
		failureMode_place_markup : PNML!PTMarking (
				text <- 0
		),
		failureMode_place_name : PNML!Name (
				text <- 'failureModePlace_'+componente.Name+'_'+failureMode.Name
		)
}


abstract rule FaultsExpressionNodeToPN {
	from
		faultsExpressionNode : IM2!FaultsExpressionNode
		(
			(thisModule.faultPropagationManager.get(faultsExpressionNode.faultsGenerateErrors.PropagationLogicStringFormat)=faultsExpressionNode.faultsGenerateErrors) or
			(thisModule.faultPropagationManager.get(faultsExpressionNode.faultsGenerateErrors.PropagationLogicStringFormat)=OclUndefined)
		)
	using {
		faultsGenerateErrors : IM2!FaultsGenerateErrors = faultsExpressionNode.faultsGenerateErrors;
		componente : IM2!Component = faultsGenerateErrors.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
	}
	to
-- Crea il place per rappresentare il fault esterno del componente
		logicResult_place : PNML!Place (
				name <- logicResult_place_name,
				initialMarking <- logicResult_place_markup,
				containerPage <- sistema--,
				--id <- 'logicResult_'+componente.Name+'_logic_'+faultsGenerateErrors.Name+thisModule.myid
		),
		logicResult_place_markup : PNML!PTMarking (
				text <- 0
		),
		logicResult_place_name : PNML!Name (
				text <- 'logicResult_'+componente.Name+'_logic_'+faultsGenerateErrors.Name+thisModule.myid
		)
	do {
		thisModule.myid = thisModule.myid + 1;
	}
}
rule FaultsExpressionAndNodeToPN extends FaultsExpressionNodeToPN {
	from
		faultsExpressionNode : IM2!FaultsExpressionAndNode
--		faultsGenerateErrors : IM2!FaultsGenerateErrors
--		(
--			faultsGenerateErrors = faultsExpressionNode.faultsGenerateErrors
--		)
	to
	logicResult_place : PNML!Place (),

-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di mettere uno ed un solo token quando la condizione logica � verifica
-- e di rimuoverlo quando non � pi� verificata
-- riferirsi alla figura logica_propagazione_and_from_uml_to_idm
-- la riga della tabella di verit� � sempre della forma gate1 & gate2 = result
-------------------------------------------------------------------------------
-- Creo la transizione per la condizione 1 & 0 = 0
		transaction_T0 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_T0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_logic_result_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T0_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T0,
				type<-#normal,
				inscription<-transaction_T0_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T0_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T0_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultsExpression1,
				target<-transaction_T0,
				type<-#normal,
				inscription<-transaction_T0_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T0_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_gate2_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T0_from_gate2_place_arc',
				source<-faultsExpressionNode.FaultsExpression2,
				target<-transaction_T0,
				type<-#inhibitor,
				inscription<-transaction_T0_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T0_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_to_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T0_to_gate1_place_arc',
				source<-transaction_T0,
				target<-faultsExpressionNode.FaultsExpression1,
				type<-#normal,
				inscription<-transaction_T0_to_gate1_place_arc_annotation,
				containerPage <- sistema
		),

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 1 & 1 = 1
----------------------------------------------------------------------------------------
		transaction_T1 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione logica
-- possa essere presente pi� di un token
		transaction_T1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_logic_result_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T1_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T1,
				type<-#inhibitor,
				inscription<-transaction_T1_from_logic_result_arc_annotation,
				containerPage <- sistema
		),

-- Creo l'arco che aggiunge un token nel place del risultato di questa espressione logica
		transaction_T1_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_to_logic_result_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T1_to_logic_result_arc',
				source<-transaction_T1,
				target<-logicResult_place,
				type<-#normal,
				inscription<-transaction_T1_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T1_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T1_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultsExpression1,
				target<-transaction_T1,
				type<-#normal,
				inscription<-transaction_T1_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T1_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_gate2_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T1_from_gate2_place_arc',
				source<-faultsExpressionNode.FaultsExpression2,
				target<-transaction_T1,
				type<-#normal,
				inscription<-transaction_T1_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T1_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_to_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T1_to_gate1_place_arc',
				source<-transaction_T1,
				target<-faultsExpressionNode.FaultsExpression1,
				type<-#normal,
				inscription<-transaction_T1_to_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate2  
		transaction_T1_to_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_to_gate2_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T1_to_gate2_place_arc',
				source<-transaction_T1,
				target<-faultsExpressionNode.FaultsExpression2,
				type<-#normal,
				inscription<-transaction_T1_to_gate2_place_arc_annotation,
				containerPage <- sistema
		),
		

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 0 & 1 = 0
----------------------------------------------------------------------------------------
		transaction_T2 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_T2_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_from_logic_result_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T2_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T2,
				type<-#normal,
				inscription<-transaction_T2_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T2_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_from_gate2_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T2_from_gate2_place_arc',
				source<-faultsExpressionNode.FaultsExpression2,
				target<-transaction_T2,
				type<-#normal,
				inscription<-transaction_T2_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T2_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_from_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T2_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultsExpression1,
				target<-transaction_T2,
				type<-#inhibitor,
				inscription<-transaction_T2_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T2_to_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_to_gate2_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T2_to_gate2_place_arc',
				source<-transaction_T2,
				target<-faultsExpressionNode.FaultsExpression2,
				type<-#normal,
				inscription<-transaction_T2_to_gate2_place_arc_annotation,
				containerPage <- sistema
		),
		
----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 0 & 0 = 0
----------------------------------------------------------------------------------------
		transaction_T3 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_T3_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T3_from_logic_result_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T3_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T3,
				type<-#normal,
				inscription<-transaction_T3_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T3_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T3_from_gate2_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T3_from_gate2_place_arc',
				source<-faultsExpressionNode.FaultsExpression2,
				target<-transaction_T3,
				type<-#inhibitor,
				inscription<-transaction_T3_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T3_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T3_from_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_andnode_transaction_T3_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultsExpression1,
				target<-transaction_T3,
				type<-#inhibitor,
				inscription<-transaction_T3_from_gate1_place_arc_annotation,
				containerPage <- sistema
		)
	do {
		thisModule.myid <- thisModule.myid + 1;
		transaction_T0_from_gate1_place_arc.id <- transaction_T0_from_gate1_place_arc.id + thisModule.myid.toString();		 		
		transaction_T0_from_gate2_place_arc.id <- transaction_T0_from_gate2_place_arc.id + thisModule.myid.toString(); 	
		transaction_T0_from_logic_result_arc.id <- transaction_T0_from_logic_result_arc.id + thisModule.myid.toString(); 	
		transaction_T0_to_gate1_place_arc.id <- transaction_T0_to_gate1_place_arc.id + thisModule.myid.toString(); 		
		
		transaction_T1_from_gate1_place_arc.id <- transaction_T1_from_gate1_place_arc.id + thisModule.myid.toString(); 	
		transaction_T1_from_gate2_place_arc.id <- transaction_T1_from_gate2_place_arc.id + thisModule.myid.toString(); 	
		transaction_T1_from_logic_result_arc.id <- transaction_T1_from_logic_result_arc.id + thisModule.myid.toString(); 	
		transaction_T1_to_gate1_place_arc.id <- transaction_T1_to_gate1_place_arc.id + thisModule.myid.toString(); 		
		transaction_T1_to_gate2_place_arc.id <- transaction_T1_to_gate2_place_arc.id + thisModule.myid.toString(); 		
		
		transaction_T2_from_gate1_place_arc.id <- transaction_T2_from_gate1_place_arc.id + thisModule.myid.toString();	
		transaction_T2_from_gate2_place_arc.id <- transaction_T2_from_gate2_place_arc.id + thisModule.myid.toString(); 	
		transaction_T2_from_logic_result_arc.id <- transaction_T2_from_logic_result_arc.id + thisModule.myid.toString(); 	
		transaction_T2_to_gate2_place_arc.id <- transaction_T2_to_gate2_place_arc.id + thisModule.myid.toString(); 		 

		transaction_T3_from_gate1_place_arc.id <- transaction_T3_from_gate1_place_arc.id + thisModule.myid.toString(); 	
		transaction_T3_from_gate2_place_arc.id <- transaction_T3_from_gate2_place_arc.id + thisModule.myid.toString(); 	
		transaction_T3_from_logic_result_arc.id <- transaction_T3_from_logic_result_arc.id + thisModule.myid.toString(); 	
		transaction_T3_from_gate1_place_arc.id <- transaction_T3_from_gate1_place_arc.id + thisModule.myid.toString(); 	
		
		thisModule.registerFaultPropagationManager(faultsGenerateErrors.PropagationLogicStringFormat, faultsGenerateErrors);
		thisModule.registerFaultPropagationLogic(faultsGenerateErrors.PropagationLogicStringFormat, thisModule.resolveTemp(faultsGenerateErrors.PropagationLogic, 'logicResult_place'));
	}
}
rule FaultsExpressionOrNodeToPN extends FaultsExpressionNodeToPN {
	from
		faultsExpressionNode : IM2!FaultsExpressionOrNode
--		faultsGenerateErrors : IM2!FaultsGenerateErrors
--		(
--			faultsGenerateErrors = faultsExpressionNode.faultsGenerateErrors
--		)
	to
	logicResult_place : PNML!Place ( name <- logicResult_place_name_or ),
			logicResult_place_name_or : PNML!Name (
				text <- 'logicResult_or_'+componente.Name+'_logic_'+faultsGenerateErrors.Name+thisModule.myid
		),
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di mettere uno ed un solo token quando la condizione logica � verifica
-- e di rimuoverlo quando non � pi� verificata
-- riferirsi alla figura logica_propagazione_or_from_uml_to_idm
-- la riga della tabella di verit� � sempre della forma gate1 | gate2 = result
-------------------------------------------------------------------------------
-- Creo la transizione per la condizione 1 | 0 = 1
		transaction_T0 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione
-- possa essere presente pi� di un token
		transaction_T0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_logic_result_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T0_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T0,
				type<-#inhibitor,
				inscription<-transaction_T0_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che aggiunge un token nel risultato di questa espressione
		transaction_T0_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_to_logic_result_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T0_to_logic_result_arc',
				source<-transaction_T0,
				target<-logicResult_place,
				type<-#normal,
				inscription<-transaction_T0_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T0_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_gate1_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T0_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultsExpression1,
				target<-transaction_T0,
				type<-#normal,
				inscription<-transaction_T0_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T0_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_gate2_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T0_from_gate2_place_arc',
				source<-faultsExpressionNode.FaultsExpression2,
				target<-transaction_T0,
				type<-#inhibitor,
				inscription<-transaction_T0_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T0_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_to_gate1_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T0_to_gate1_place_arc',
				source<-transaction_T0,
				target<-faultsExpressionNode.FaultsExpression1,
				type<-#normal,
				inscription<-transaction_T0_to_gate1_place_arc_annotation,
				containerPage <- sistema
		),

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 1 | 1 = 1
----------------------------------------------------------------------------------------
		transaction_T1 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione logica
-- possa essere presente pi� di un token
		transaction_T1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_logic_result_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T1_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T1,
				type<-#inhibitor,
				inscription<-transaction_T1_from_logic_result_arc_annotation,
				containerPage <- sistema
		),

-- Creo l'arco che aggiunge un token nel place del risultato di questa espressione logica
		transaction_T1_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_to_logic_result_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T1_to_logic_result_arc',
				source<-transaction_T1,
				target<-logicResult_place,
				type<-#normal,
				inscription<-transaction_T1_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T1_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_gate1_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T1_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultsExpression1,
				target<-transaction_T1,
				type<-#normal,
				inscription<-transaction_T1_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T1_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_gate2_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T1_from_gate2_place_arc',
				source<-faultsExpressionNode.FaultsExpression2,
				target<-transaction_T1,
				type<-#normal,
				inscription<-transaction_T1_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T1_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_to_gate1_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T1_to_gate1_place_arc',
				source<-transaction_T1,
				target<-faultsExpressionNode.FaultsExpression1,
				type<-#normal,
				inscription<-transaction_T1_to_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate2  
		transaction_T1_to_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_to_gate2_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T1_to_gate2_place_arc',
				source<-transaction_T1,
				target<-faultsExpressionNode.FaultsExpression2,
				type<-#normal,
				inscription<-transaction_T1_to_gate2_place_arc_annotation,
				containerPage <- sistema
		),
		

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 0 | 1 = 1
----------------------------------------------------------------------------------------
		transaction_T2 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione
-- possa essere presente pi� di un token
		transaction_T2_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_from_logic_result_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T2_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T2,
				type<-#inhibitor,
				inscription<-transaction_T2_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che aggiunge un token nel risultato di questa espressione
		transaction_T2_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_to_logic_result_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T2_to_logic_result_arc',
				source<-transaction_T2,
				target<-logicResult_place,
				type<-#normal,
				inscription<-transaction_T2_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T2_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_from_gate2_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T2_from_gate2_place_arc',
				source<-faultsExpressionNode.FaultsExpression2,
				target<-transaction_T2,
				type<-#normal,
				inscription<-transaction_T2_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T2_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_from_gate1_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T2_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultsExpression1,
				target<-transaction_T2,
				type<-#inhibitor,
				inscription<-transaction_T2_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T2_to_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T2_to_gate2_place_arc: PNML!GSPNArc (
	--			id<-'faults_ornode_transaction_T2_to_gate2_place_arc',
				source<-transaction_T2,
				target<-faultsExpressionNode.FaultsExpression2,
				type<-#normal,
				inscription<-transaction_T2_to_gate2_place_arc_annotation,
				containerPage <- sistema
		),
		
----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 0 | 0 = 0
----------------------------------------------------------------------------------------
		transaction_T3 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_T3_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T3_from_logic_result_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T3_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T3,
				type<-#normal,
				inscription<-transaction_T3_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T3_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T3_from_gate2_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T3_from_gate2_place_arc',
				source<-faultsExpressionNode.FaultsExpression2,
				target<-transaction_T3,
				type<-#inhibitor,
				inscription<-transaction_T3_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T3_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T3_from_gate1_place_arc: PNML!GSPNArc (
--				id<-'faults_ornode_transaction_T3_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultsExpression1,
				target<-transaction_T3,
				type<-#inhibitor,
				inscription<-transaction_T3_from_gate1_place_arc_annotation,
				containerPage <- sistema
		)
	do {
		for(n in PNML!PnObject.allInstances()->select(i | i.id.oclIsUndefined())) {
			thisModule.myid <- thisModule.myid + 1;
			n.id <- 'FaultsExpressionNotNodeToPN_'+thisModule.myid.toString();
		}

		thisModule.registerFaultPropagationManager(faultsGenerateErrors.PropagationLogicStringFormat, faultsGenerateErrors);
		thisModule.registerFaultPropagationLogic(faultsGenerateErrors.PropagationLogicStringFormat, faultsGenerateErrors.PropagationLogic);
	}
}
rule FaultsExpressionNotNodeToPN extends FaultsExpressionNodeToPN {
	from
		faultsExpressionNode : IM2!FaultsExpressionNotNode
--		faultsGenerateErrors : IM2!FaultsGenerateErrors
--		(
--			faultsGenerateErrors = faultsExpressionNode.faultsGenerateErrors
--		)
	to
		logicResult_place : PNML!Place (),
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di mettere uno ed un solo token quando la condizione logica � verifica
-- e di rimuoverlo quando non � pi� verificata
-- riferirsi alla figura logica_propagazione_or_from_uml_to_idm
-- la riga della tabella di verit� � sempre della forma ~ gate1  = result
-------------------------------------------------------------------------------
-- Creo la transizione per la condizione ~ 0 = 1
		transaction_T0 : PNML!GSPNImmediateTransition (
			id <- 'faults_notnode_transaction',
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione
-- possa essere presente pi� di un token
		transaction_T0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_logic_result_arc: PNML!GSPNArc (
				id<-'faults_notnode_transaction_T0_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T0,
				type<-#inhibitor,
				inscription<-transaction_T0_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che aggiunge un token nel risultato di questa espressione
		transaction_T0_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_to_logic_result_arc: PNML!GSPNArc (
				id<-'faults_notnode_transaction_T0_to_logic_result_arc',
				source<-transaction_T0,
				target<-logicResult_place,
				type<-#normal,
				inscription<-transaction_T0_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T0_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_notnode_transaction_T0_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultExpression,
				target<-transaction_T0,
				type<-#inhibitor,
				inscription<-transaction_T0_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione ~ 1 = 0
----------------------------------------------------------------------------------------
		transaction_T1 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token dal place che rappresenta il risultato dell'espressione
		transaction_T1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_logic_result_arc: PNML!GSPNArc (
				id<-'faults_notnode_transaction_T1_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_T1,
				type<-#normal,
				inscription<-transaction_T1_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T1_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_notnode_transaction_T1_from_gate1_place_arc',
				source<-faultsExpressionNode.FaultExpression,
				target<-transaction_T1,
				type<-#normal,
				inscription<-transaction_T1_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T1_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_to_gate1_place_arc: PNML!GSPNArc (
				id<-'faults_notnode_transaction_T1_to_gate1_place_arc',
				source<-transaction_T1,
				type<-#normal,
				target<-faultsExpressionNode.FaultExpression,
				inscription<-transaction_T1_to_gate1_place_arc_annotation,
				containerPage <- sistema
		)
	do {
		thisModule.myid <- thisModule.myid + 1;
		
		for(n in PNML!PnObject.allInstances()->select(i | i.id.oclIsUndefined())) {
			thisModule.myid <- thisModule.myid + 1;
			n.id <- 'prova' + thisModule.myid.toString();
		}
		
		thisModule.registerFaultPropagationManager(faultsGenerateErrors.PropagationLogicStringFormat, faultsGenerateErrors);
		thisModule.registerFaultPropagationLogic(faultsGenerateErrors.PropagationLogicStringFormat, faultsGenerateErrors.PropagationLogic);
	}
}
rule FaultsExpressionFaultNodeToPN extends FaultsExpressionNodeToPN {
	from
		faultsExpressionNode : IM2!FaultsExpressionFaultNode
--		faultsGenerateErrors : IM2!FaultsGenerateErrors
--		(
--			faultsGenerateErrors = faultsExpressionNode.faultsGenerateErrors
--		)
	using {
		fault : IM2!Fault = faultsExpressionNode.Fault;
	}
	to
		logicResult_place : PNML!Place ( name <- logicResult_place_name_ft  ),
		logicResult_place_name_ft : PNML!Name (
				text <- 'logicResult_'+componente.Name+'_'+fault.Name+'_logic_'+faultsGenerateErrors.Name+thisModule.myid
		),
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di mettere uno ed un solo token quando si verifica il fault
-------------------------------------------------------------------------------
-- Creo la transizione che preleva il token dal place che evidenzia il fault
		transaction_to_evidence : PNML!GSPNImmediateTransition (
	--		id <- 'faults_generates_errors_'+faultsGenerateErrors.Name+'_propagation_logic_'+componente.Name+'_transaction_to_evidence_'+fault.Name,
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che mette il token nel risultato di questa espressione logica 
		transaction_to_evidence_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_evidence_to_logic_result_arc: PNML!GSPNArc (
	--			id<-'faults_fault_transaction_to_evidence_to_logic_result_arc',
				source<-transaction_to_evidence,
				target<-logicResult_place,
				type<-#normal,
				inscription<-transaction_to_evidence_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che rimette il token nel place che evidenzia il fault 
		transaction_to_evidence_to_faulty_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_evidence_to_faulty_place_arc: PNML!GSPNArc (
	--			id<-'faults_fault_transaction_to_evidence_to_faulty_place_arc',
				source<-transaction_to_evidence,
				target<-fault,
				type<-#normal,
				inscription<-transaction_to_evidence_to_faulty_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco d'attivazione della transizione che rimuove un token dal place che evidenzia il fault 
		transaction_to_evidence_from_faulty_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_evidence_from_faulty_place_arc: PNML!GSPNArc (
	--			id<-'faults_fault_transaction_to_evidence_from_faulty_place_arc',
				source<-fault,
				target<-transaction_to_evidence,
				type<-#normal,
				inscription<-transaction_to_evidence_from_faulty_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo un arco inibitore che impedisce che sul token risultato dell'espressione possa finire pi� di un token 
		transaction_to_evidence_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_evidence_from_logic_result_arc: PNML!GSPNArc (
	--			id<-'faults_fault_transaction_to_evidence_from_logic_result_arc',
				source<-logicResult_place,
				target<-transaction_to_evidence,
				type<-#inhibitor,
				inscription<-transaction_to_evidence_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di rimuovere un token dalla logica quando l'errore scompare
-------------------------------------------------------------------------------
		transition_faultnode_false : PNML!GSPNImmediateTransition (
			containerPage <- sistema			
		),
		transition_faultnode_false_from_error_ins : PNML!PTArcAnnotation ( text <- 1 ),
		transition_faultnode_false_from_error : PNML!GSPNArc (
	--		id <- 'faultnode_false_from_error',
			source <- fault,
			target <- transition_faultnode_false,
			type <- #inhibitor,
			inscription <- transition_faultnode_false_from_error_ins,
			containerPage <- sistema
		),
		transition_faultnode_false_from_result_ins : PNML!PTArcAnnotation ( text <- 1 ),
		transition_faultnode_false_from_result : PNML!GSPNArc (
	--		id <- 'faultnode_false_from_result',
			source <- logicResult_place,
			target <- transition_faultnode_false,
			type <- #normal,
			inscription <- transition_faultnode_false_from_result_ins,
			containerPage <- sistema
		)
--		transaction_remove_evidence : PNML!GSPNImmediateTransition (
--			id <- 'faults_generates_errors_'+faultsGenerateErrors.Name+'_propagation_logic_'+componente.Name+'_transaction_remove_evidence_'+fault.Name,
--			Priority <- 2,
--			containerPage <- sistema
--		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
--		transaction_remove_evidence_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
--				text<-1
--		),
--		transaction_remove_evidence_from_logic_result_arc: PNML!GSPNArc (
--				id<-'faults_fault_transaction_remove_evidence_from_logic_result_arc',
--				source<-logicResult_place,
--				target<-transaction_remove_evidence,
--				type<-#normal,
--				inscription<-transaction_remove_evidence_from_logic_result_arc_annotation,
--				containerPage <- sistema
--		),
-- Creo l'arco inibitore che attiva permette di rimuovere il token dal risultato di questa espressione
-- logica se nn ci sono faults 
--		transaction_remove_evidence_from_faulty_place_arc_annotation : PNML!PTArcAnnotation (
--				text<-1
--		),
--		transaction_remove_evidence_from_faulty_place_arc: PNML!GSPNArc (
--				id<-'faults_fault_transaction_remove_evidence_from_faulty_place_arc',
--				source<-thisModule.resolveTemp(fault, 'faulty_place'),
--				target<-transaction_to_evidence,
--				type<-#inhibitor,
--				inscription<-transaction_remove_evidence_from_faulty_place_arc_annotation,
--				containerPage <- sistema
--	)
		
	do {
		for(n in PNML!PnObject.allInstances()->select(i | i.id.oclIsUndefined())) {
			thisModule.myid <- thisModule.myid + 1;
			n.id <- 'FaultsExpressionFaultNodeToPN_'+thisModule.myid.toString();
		}
				
		thisModule.registerFaultPropagationManager(faultsGenerateErrors.PropagationLogicStringFormat, faultsGenerateErrors);
		thisModule.registerFaultPropagationLogic(faultsGenerateErrors.PropagationLogicStringFormat, faultsGenerateErrors.PropagationLogic);
	}
}

abstract rule FaultsGeneratesError {
	from
		faultsGeneratesError : IM2!FaultsGenerateErrors
	using
	{
		componente : IM2!Component = faultsGeneratesError.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
		page : PNML!Page = sistema;

		faultPropagationResult_place : PNML!Place = thisModule.getFaultPropagationLogic(faultsGeneratesError);
	}
	to
--------------------------------------------------------------------------------------------
-- in relazione alle figura faultGeneratesErrors_from_uml_to_idm
--------------------------------------------------------------------------------------------
-- Crea case per la generazione dell'errore
		propagation_case : PNML!GSPNImmediateTransition (
--			id <- 'faults_generates_error_'+componente.Name+'_'+faultsGeneratesError.Name+'_propagation',
			Priority <- 1,
			Weight <- faultsGeneratesError.PropagationProbability,
			containerPage<-sistema
		),
		
-- place di comodo per registrare l'attivazione della propagazione
		tmp_activated_propagation_place_markup : PNML!PTMarking (
				text <- 0
		),
		tmp_activated_propagation_place_name : PNML!Name (
				text <- 'tmp_activated_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name
		),
		tmp_activated_propagation_place : PNML!Place (
--				id <- 'tmp_activated_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
				name <- tmp_activated_propagation_place_name,
				initialMarking <- tmp_activated_propagation_place_markup,
				containerPage <- componente.intermediateModel
		),

-- Creo l'arco che aggiunge un token in tmp_activated_propagation_place 
		from_activationDelay_to_tmp_activated_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		from_activationDelay_to_tmp_activated_arc: PNML!GSPNArc (
--				id<-'faults_generate_errors_from_activationDelay_to_tmp_activated_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
				source<-faultsGeneratesError.ActivationDelay,
				target<-tmp_activated_propagation_place,
				type<-#normal,
				inscription<-from_activationDelay_to_tmp_activated_arc_annotation,
				containerPage <- sistema
		),
		

-- Creo l'arco che rimuove un token in tmp_activated_propagation_place e esegue la propagazione
-- tmp_activated_propagation_place abilita/disabilita la propagazione
		from_tmp_activated_to_propagation_case_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		from_tmp_activated_to_propagation_case_arc: PNML!GSPNArc (
--				id<-'faults_generate_errors_from_tmp_activated_to_propagation_case_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
				source<-tmp_activated_propagation_place,
				target<-propagation_case,
				type<-#normal,
				inscription<-from_tmp_activated_to_propagation_case_arc_annotation,
				containerPage <- sistema
		),

-- Creo l'arco che rimuove un token in tmp_activated_propagation_place e non esegue la propagazione
-- tmp_activated_propagation_place abilita/disabilita la propagazione
		from_tmp_activated_to_not_propagation_case_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		from_tmp_activated_to_not_propagation_case_arc: PNML!GSPNArc (
--				id<-'faults_generate_errors_from_tmp_activated_to_not_propagation_case_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
				source<-tmp_activated_propagation_place,
				target<-not_propagation_case,
				type<-#normal,
				inscription<-from_tmp_activated_to_not_propagation_case_arc_annotation,
				containerPage <- sistema
		),
		
		not_propagation_case : PNML!GSPNImmediateTransition (
--			id <- 'faults_generates_error_'+componente.Name+'_'+faultsGeneratesError.Name+'_not_propagation',
			Priority <- 1,
			Weight <- 1-faultsGeneratesError.PropagationProbability,
			containerPage<-sistema
		),
		

-- place per l'attivazione della generazione dell'errore
		errorsActivation_place_markup : PNML!PTMarking (
				text <- 0
		),
		errorsActivation_place_name : PNML!Name (
				text <- 'errorsActivation_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name
		),
		errorsActivation_place : PNML!Place (
--				id <- 'errorsActivation_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
				name <- errorsActivation_place_name,
				initialMarking <- errorsActivation_place_markup,
				containerPage <- componente.intermediateModel
		),
-- la transizione che, nel caso di pi� errori possono essere attivati dalla stessa logica di propagazione,
-- consente di scegliere quale errore viene generato
		transaction_weight : PNML!GSPNImmediateTransition (
--			id <- 'faults_generate_errors_weight_'+faultsGeneratesError.Name,
			Priority <- 2,
			Weight <- faultsGeneratesError.Weight,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_weight_from_fault_propagation_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_weight_from_fault_propagation_logic_result_arc: PNML!GSPNArc (
--				id<-'transaction_weight_from_fault_propagation_logic_result_arc',
				source<-faultPropagationResult_place,
				target<-transaction_weight,
				type<-#normal,
				inscription<-transaction_weight_from_fault_propagation_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che rimette il token nel risultato di questa espressione logica 
		transaction_weight_to_fault_propagation_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_weight_to_fault_propagation_logic_result_arc: PNML!GSPNArc (
--				id<-'transaction_weight_to_fault_propagation_logic_result_arc',
				source<-transaction_weight,
				target<-faultPropagationResult_place,
				type<-#normal,
				inscription<-transaction_weight_to_fault_propagation_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che mette il token nel place che permette l'attivazione (cmq ancora non sicura) degli errori
		transaction_weight_to_errorsActivation_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_weight_to_errorsActivation_arc: PNML!GSPNArc (
--				id<-'transaction_weight_to_errorsActivation_arc',
				source<-transaction_weight,
				target<-errorsActivation_place,
				type<-#normal,
				inscription<-transaction_weight_to_errorsActivation_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione temporizzata per l'attivazione dell'errore
		transaction_activationDelay_from_errorsActivation_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_activationDelay_from_errorsActivation: PNML!GSPNArc (
--				id<-'transaction_activationDelay_from_errorsActivation',
				source<-errorsActivation_place,
				target<-faultsGeneratesError.ActivationDelay,
				type<-#normal,
				inscription<-transaction_activationDelay_from_errorsActivation_arc_annotation,
				containerPage <- sistema
		)
	do {
		for(n in PNML!PnObject.allInstances()->select(i | i.id.oclIsUndefined())) {
			thisModule.myid <- thisModule.myid + 1;
			n.id <- 'FaultsGenerateErrors_'+thisModule.myid.toString();
		}
	}
}

rule FaultsGeneratesErrorNoManager extends FaultsGeneratesError {
	from
		faultsGeneratesError : IM2!FaultsGenerateErrors
		(
			(thisModule.faultPropagationManager.get(faultsGeneratesError.PropagationLogicStringFormat)<>OclUndefined) and
			(thisModule.faultPropagationManager.get(faultsGeneratesError.PropagationLogicStringFormat)<>faultsGeneratesError)
		)
	to
		propagation_case : PNML!GSPNImmediateTransition (),
-----------------------------------------------------------------------------------
-- Creo l'arco che attiva la propagazione solo se c'e' un token nel place active_place
-----------------------------------------------------------------------------------
		transaction_weight_from_active_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_weight_from_active_arc: PNML!GSPNArc (
				id<-'transaction_weight_from_active_arc',
				source<- thisModule.faultPropagationManager(faultsGeneratesError.PropagationLogicStringFormat),
				target<-transaction_weight,
				type<-#normal,
				inscription<-transaction_weight_from_active_arc_annotation,
				containerPage <- sistema
		)
		
}
rule FaultsGeneratesErrorManager extends FaultsGeneratesError {
	from
		faultsGeneratesError : IM2!FaultsGenerateErrors
		(
			thisModule.faultPropagationManager.get(faultsGeneratesError.PropagationLogicStringFormat)=OclUndefined or
			thisModule.faultPropagationManager.get(faultsGeneratesError.PropagationLogicStringFormat)=faultsGeneratesError
		)
	to
		propagation_case : PNML!GSPNImmediateTransition (),
--------------------------------------------------------------------------------------------
-- La regola crea i place e le trasformazioni che consentono di attivare una sola volta la propagazione dai fault all'errore.
-- Quando il risultato della logica di propagazione viene annullato � permessa la generazione di un nuovo errore
-- in relazione alle figura multiple_propagation_logic
--------------------------------------------------------------------------------------------
-- nel place active la presenza di un token attiva le transizioni per scegliere quale propagazione
-- deve avvenire
		active_place_markup : PNML!PTMarking (
				text <- 0
		),
		active_place_name : PNML!Name (
				text <- 'active_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name
		),
		active_place : PNML!Place (
				id <- 'faults_generates_errors_active_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
				name <- active_place_name,
				initialMarking <- active_place_markup,
				containerPage <- componente.intermediateModel
		),
-- questo place � utilizzato a supporto per memorizzare il fatto che il token nel 
-- place d'attivazione della propagazione � gi� stato messo
		activated_place_markup : PNML!PTMarking (
				text <- 0
		),
		activated_place_name : PNML!Name (
				text <- 'activated_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name
		),
		activated_place : PNML!Place (
				id <- 'faults_generates_errors_activated_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
				name <- activated_place_name,
				initialMarking <- activated_place_markup,
				containerPage <- componente.intermediateModel
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione � verificata aggiunge un token in activated e active
-----------------------------------------------------------------------------------------
		transaction_t0 : PNML!GSPNImmediateTransition (
			id <- 'faults_generates_enabler_t0_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione � verificata
		transaction_t0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		transaction_t0_from_logic_result_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t0_from_logic_result_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- faultPropagationResult_place,
			target <- transaction_t0,
			type<-#normal,
			inscription <- transaction_t0_from_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimette il token nel risultato della propagazione logica quando la transizione
-- che notifica l'attivazione scatta
		transaction_t0_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		transaction_t0_to_logic_result_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t0_to_logic_result_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- transaction_t0,
			target <- faultPropagationResult_place,
			type<-#normal,
			inscription <- transaction_t0_to_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che impedisce di rimettere il token in active dopo che la propagazione � avvenuta
		transaction_t0_from_activated_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		transaction_t0_from_activated_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t0_from_activated_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- activated_place,
			target <- transaction_t0,
			type<-#inhibitor,
			inscription <- transaction_t0_from_activated_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che memorizza l'avvenuta attivazione della propagazione
		transaction_t0_to_activated_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		transaction_t0_to_activated_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t0_to_activated_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- transaction_t0,
			target <- activated_place,
			type<-#normal,
			inscription <- transaction_t0_to_activated_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco attivazione la propagazione
		transaction_t0_to_active_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		transaction_t0_to_active_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t0_to_active_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- transaction_t0,
			target <- active_place,
			type<-#normal,
			inscription <- transaction_t0_to_active_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione non � verificata rimuove un token (se presente) da
-- activated
-----------------------------------------------------------------------------------------
		transaction_t1 : PNML!GSPNImmediateTransition (
			id<-'faults_generates_errors_transiction_t1_Reset_activated_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione NON � verificata
		transaction_t1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_t1_from_logic_result_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t1_from_logic_result_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- faultPropagationResult_place,
			target <- transaction_t1,
			type <- #inhibitor,
			inscription <- transaction_t1_from_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token da activated (se presente)
		transaction_t1_from_activated_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		transaction_t1_from_activated_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t1_from_activated_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- activated_place,
			target <- transaction_t1,
			type<-#normal,
			inscription <- transaction_t1_from_activated_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione non � verificata rimuove un token (se presente) da
-- active
-----------------------------------------------------------------------------------------
		transaction_t2 : PNML!GSPNImmediateTransition (
			id<-'faults_generates_errors_transaction_t2_reset_activate_place_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione NON � verificata
		transaction_t2_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		transaction_t2_from_logic_result_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t2_from_logic_result_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- faultPropagationResult_place,
			target <- transaction_t2,
			type <- #inhibitor,
			inscription <- transaction_t2_from_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token da activated (se presente)
		transaction_t2_from_active_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_t2_from_active_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_t2_from_active_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source <- active_place,
			target <- transaction_t2,
			type<-#normal,
			inscription <- transaction_t2_from_active_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------
-- Creo l'arco che attiva la propagazione solo se c'e' un token nel place active_place
-----------------------------------------------------------------------------------
		transaction_weight_from_active_arc_annotation : PNML!PTArcAnnotation (
			text<-1
		),
		transaction_weight_from_active_arc: PNML!GSPNArc (
			id<-'faults_generates_errors_transaction_weight_from_active_arc_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name,
			source<-active_place,
			target<-transaction_weight,
			type<-#normal,
			inscription<-transaction_weight_from_active_arc_annotation,
			containerPage <- sistema
		)
}

rule FaultsGeneratesErrorPropagate {
	from
		faultsGeneratesError : IM2!FaultsGenerateErrors,
		error : IM2!Error
		(
				faultsGeneratesError.Destination.includes(error)
		)
	using
	{
		componente : IM2!Component = faultsGeneratesError.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
	}
	to
-- Creo l'arco che mette un token nel place associato all'errore
		propagation_to_error_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		propagation_to_error_arc: PNML!GSPNArc (
				id<-'faults_generate_errors_'+componente.Name+'_faultsGeneratesError_'+faultsGeneratesError.Name+'_to_'+error.Name,
				source <- faultsGeneratesError,
				target <- error,
				type<-#normal,
				inscription<-propagation_to_error_arc_annotation,
				containerPage <- sistema
		)
}



abstract rule ErrorsExpressionNodeToPN {
	from
		errorsExpressionNode : IM2!ErrorsExpressionNode
--		errorPropagation : IM2!ErrorPropagation
		(
--			errorPropagation = errorsExpressionNode.errorPropagation and
			(thisModule.errorPropagationManager.get(errorsExpressionNode.errorPropagation.PropagationLogicStringFormat)=errorsExpressionNode.errorPropagation) or
			(thisModule.errorPropagationManager.get(errorsExpressionNode.errorPropagation.PropagationLogicStringFormat)=OclUndefined)
		)
	using {
		errorPropagation : IM2!ErrorPropagation = errorsExpressionNode.errorPropagation;
		componente : IM2!Component = errorPropagation.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
	}
	to
-- Crea il place per rappresentare il fault esterno del componente
		logicResult_place : PNML!Place (
				name <- logicResult_place_name,
				initialMarking <- logicResult_place_markup,
				containerPage <- sistema
		),
		logicResult_place_markup : PNML!PTMarking (
				text <- 0
		),
		logicResult_place_name : PNML!Name (
				text <- 'logicResult_'+componente.Name+'_logic_'+errorPropagation.Name+thisModule.myid
		)
	do {
		thisModule.myid = thisModule.myid + 1;
	}
}
rule ErrorsExpressionAndNodeToPN extends ErrorsExpressionNodeToPN {
	from
		errorsExpressionNode : IM2!ErrorsExpressionAndNode
--		errorPropagation : IM2!ErrorPropagation
--		(
--			errorPropagation = errorsExpressionNode.errorPropagation
--		)
	to
		logicResult_place : PNML!Place (),
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di mettere uno ed un solo token quando la condizione logica � verifica
-- e di rimuoverlo quando non � pi� verificata
-- riferirsi alla figura logica_propagazione_and_from_uml_to_idm
-- la riga della tabella di verit� � sempre della forma gate1 & gate2 = result
-------------------------------------------------------------------------------
-- Creo la transizione per la condizione 1 & 0 = 0
		transaction_T0 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_T0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T0_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T0,
				type<-#normal,
				inscription <- transaction_T0_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T0_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T0_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression1,
				target <- transaction_T0,
				type<-#normal,
				inscription <- transaction_T0_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T0_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T0_from_gate2_place_arc',
				source <- errorsExpressionNode.ErrorsExpression2,
				target <- transaction_T0,
				type <- #inhibitor,
				inscription <- transaction_T0_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T0_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_to_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T0_to_gate1_place_arc',
				source <- transaction_T0,
				target <- errorsExpressionNode.ErrorsExpression1,
				type<-#normal, 
				inscription <- transaction_T0_to_gate1_place_arc_annotation,
				containerPage <- sistema
		),

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 1 & 1 = 1
----------------------------------------------------------------------------------------
		transaction_T1 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione logica
-- possa essere presente pi� di un token
		transaction_T1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T1_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T1,
				type <- #inhibitor,
				inscription <- transaction_T1_from_logic_result_arc_annotation,
				containerPage <- sistema
		),

-- Creo l'arco che aggiunge un token nel place del risultato di questa espressione logica
		transaction_T1_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_to_logic_result_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T1_to_logic_result_arc',
				source <- transaction_T1,
				target <- logicResult_place,
				type<-#normal,
				inscription <- transaction_T1_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T1_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T1_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T1_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression1,
				target <- transaction_T1,
				type<-#normal,
				inscription <- transaction_T1_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T1_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_from_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T1_from_gate2_place_arc',
				source <- errorsExpressionNode.ErrorsExpression2,
				target <- transaction_T1,
				type<-#normal,
				inscription <- transaction_T1_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T1_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_to_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T1_to_gate1_place_arc',
				source <- transaction_T1,
				target <- errorsExpressionNode.ErrorsExpression1,
				type<-#normal,
				inscription <- transaction_T1_to_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate2  
		transaction_T1_to_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_to_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T1_to_gate2_place_arc',
				source <- transaction_T1,
				target <- errorsExpressionNode.ErrorsExpression2,
				type<-#normal,
				inscription <- transaction_T1_to_gate2_place_arc_annotation,
				containerPage <- sistema
		),
		

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 0 & 1 = 0
----------------------------------------------------------------------------------------
		transaction_T2 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_T2_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T2_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T2,
				type<-#normal,
				inscription <- transaction_T2_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T2_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_from_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T2_from_gate2_place_arc',
				source <- errorsExpressionNode.ErrorsExpression2,
				target <- transaction_T2,
				type<-#normal,
				inscription <- transaction_T2_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T2_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T2_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression1,
				target <- transaction_T2,
				type <- #inhibitor,
				inscription <- transaction_T2_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T2_to_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_to_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T2_to_gate2_place_arc',
				source <- transaction_T2,
				target <- errorsExpressionNode.ErrorsExpression2,
				type<-#normal,
				inscription <- transaction_T2_to_gate2_place_arc_annotation,
				containerPage <- sistema
		),
		
----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 0 & 0 = 0
----------------------------------------------------------------------------------------
		transaction_T3 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_T3_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T3_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T3_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T3,
				inscription <- transaction_T3_from_logic_result_arc_annotation,
				type<-#normal,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T3_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T3_from_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T3_from_gate2_place_arc',
				source <- errorsExpressionNode.ErrorsExpression2,
				target <- transaction_T3,
				type <- #inhibitor,
				inscription <- transaction_T3_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T3_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T3_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_andnode_transaction_T3_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression1,
				target <- transaction_T3,
				type <- #inhibitor,
				inscription <- transaction_T3_from_gate1_place_arc_annotation,
				containerPage <- sistema
		)
	do {
		thisModule.registerErrorPropagationManager(errorPropagation.PropagationLogicStringFormat, errorPropagation);
		thisModule.registerErrorPropagationLogic(errorPropagation.PropagationLogicStringFormat, errorPropagation.PropagationLogic);
	}
}
rule ErrorsExpressionOrNodeToPN extends ErrorsExpressionNodeToPN {
	from
		errorsExpressionNode : IM2!ErrorsExpressionOrNode
--		errorPropagation : IM2!ErrorPropagation
--		(
--			errorPropagation = errorsExpressionNode.errorPropagation
--		)
	to
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di mettere uno ed un solo token quando la condizione logica � verifica
-- e di rimuoverlo quando non � pi� verificata
-- riferirsi alla figura logica_propagazione_or_from_uml_to_idm
-- la riga della tabella di verit� � sempre della forma gate1 | gate2 = result
-------------------------------------------------------------------------------
-- Creo la transizione per la condizione 1 | 0 = 1
		transaction_T0 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione
-- possa essere presente pi� di un token
		transaction_T0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T0_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T0,
				type <- #inhibitor,
				inscription <- transaction_T0_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che aggiunge un token nel risultato di questa espressione
		transaction_T0_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T0_to_logic_result_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T0_to_logic_result_arc',
				source <- transaction_T0,
				target <- logicResult_place,
				type<-#normal,
				inscription <- transaction_T0_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T0_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T0_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T0_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression1,
				target <- transaction_T0,
				type<-#normal,
				inscription <- transaction_T0_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T0_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T0_from_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T0_from_gate2_place_arc',
				source <- errorsExpressionNode.ErrorsExpression2,
				target <- transaction_T0,
				type <- #inhibitor,
				inscription <- transaction_T0_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T0_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T0_to_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T0_to_gate1_place_arc',
				source <- transaction_T0,
				target <- errorsExpressionNode.ErrorsExpression1,
				type<-#normal,
				inscription <- transaction_T0_to_gate1_place_arc_annotation,
				containerPage <- sistema
		),

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 1 | 1 = 1
----------------------------------------------------------------------------------------
		transaction_T1 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione logica
-- possa essere presente pi� di un token
		transaction_T1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T1_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T1,
				type <- #inhibitor,
				inscription <- transaction_T1_from_logic_result_arc_annotation,
				containerPage <- sistema
		),

-- Creo l'arco che aggiunge un token nel place del risultato di questa espressione logica
		transaction_T1_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_to_logic_result_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T1_to_logic_result_arc',
				source <- transaction_T1,
				target <- logicResult_place,
				type<-#normal,
				inscription <- transaction_T1_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T1_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T1_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression1,
				target <- transaction_T1,
				type<-#normal,
				inscription <- transaction_T1_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T1_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_from_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T1_from_gate2_place_arc',
				source <- errorsExpressionNode.ErrorsExpression2,
				target <- transaction_T1,
				type<-#normal,
				inscription <- transaction_T1_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T1_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_to_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T1_to_gate1_place_arc',
				source <- transaction_T1,
				target <- errorsExpressionNode.ErrorsExpression1,
				type<-#normal,
				inscription <- transaction_T1_to_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate2  
		transaction_T1_to_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_to_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T1_to_gate2_place_arc',
				source <- transaction_T1,
				target <- errorsExpressionNode.ErrorsExpression2,
				type<-#normal,
				inscription <- transaction_T1_to_gate2_place_arc_annotation,
				containerPage <- sistema
		),
		

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 0 | 1 = 1
----------------------------------------------------------------------------------------
		transaction_T2 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione
-- possa essere presente pi� di un token
		transaction_T2_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T2_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T2,
				type <- #inhibitor,
				inscription <- transaction_T2_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che aggiunge un token nel risultato di questa espressione
		transaction_T2_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_to_logic_result_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T2_to_logic_result_arc',
				source <- transaction_T2,
				target <- logicResult_place,
				type<-#normal,
				inscription <- transaction_T2_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T2_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_from_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T2_from_gate2_place_arc',
				source <- errorsExpressionNode.ErrorsExpression2,
				target <- transaction_T2,
				type<-#normal,
				inscription <- transaction_T2_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T2_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T2_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression1,
				target <- transaction_T2,
				type <- #inhibitor,
				inscription <- transaction_T2_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T2_to_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T2_to_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T2_to_gate2_place_arc',
				source <- transaction_T2,
				target <- errorsExpressionNode.ErrorsExpression2,
				type<-#normal,
				inscription <- transaction_T2_to_gate2_place_arc_annotation,
				containerPage <- sistema
		),
		
----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione 0 | 0 = 0
----------------------------------------------------------------------------------------
		transaction_T3 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_T3_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T3_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T3_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T3,
				type<-#normal,
				inscription <- transaction_T3_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate2  
		transaction_T3_from_gate2_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T3_from_gate2_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T3_from_gate2_place_arc',
				source <- errorsExpressionNode.ErrorsExpression2,
				target <- transaction_T3,
				type <- #inhibitor,
				inscription <- transaction_T3_from_gate2_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T3_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T3_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_ornode_transaction_T3_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression1,
				target <- transaction_T3,
				type <- #inhibitor,
				inscription <- transaction_T3_from_gate1_place_arc_annotation,
				containerPage <- sistema
		)
	do {
		--ORNODE
		thisModule.registerErrorPropagationManager(errorPropagation.PropagationLogicStringFormat, errorPropagation);
		thisModule.registerErrorPropagationLogic(errorPropagation.PropagationLogicStringFormat, thisModule.resolveTemp(errorPropagation.PropagationLogic, 'logicResult_place'));
	}
}
rule ErrorsExpressionNotNodeToPN extends ErrorsExpressionNodeToPN {
	from
		errorsExpressionNode : IM2!ErrorsExpressionNotNode
--		errorPropagation : IM2!ErrorPropagation
--		(
--			errorPropagation = errorsExpressionNode.errorPropagation
--		)
	to
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di mettere uno ed un solo token quando la condizione logica � verifica
-- e di rimuoverlo quando non � pi� verificata
-- riferirsi alla figura logica_propagazione_or_from_uml_to_idm
-- la riga della tabella di verit� � sempre della forma ~ gate1  = result
-------------------------------------------------------------------------------
-- Creo la transizione per la condizione ~ 0 = 1
		transaction_T0 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che inpedisce che nel place del risultato di questa espressione
-- possa essere presente pi� di un token
		transaction_T0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_notnode_transaction_T0_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T0,
				type <- #inhibitor,
				inscription <- transaction_T0_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che aggiunge un token nel risultato di questa espressione
		transaction_T0_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T0_to_logic_result_arc: PNML!GSPNArc (
				id<-'errors_notnode_transaction_T0_to_logic_result_arc',
				source <- transaction_T0,
				target <- logicResult_place,
				type<-#normal,
				inscription <- transaction_T0_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T0_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T0_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_notnode_transaction_T0_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression,
				target <- transaction_T0,
				type <- #inhibitor,
				inscription <- transaction_T0_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),

----------------------------------------------------------------------------------------
-- Creo la transizione per la condizione ~ 1 = 0
----------------------------------------------------------------------------------------
		transaction_T1 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token dal place che rappresenta il risultato dell'espressione
		transaction_T1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_from_logic_result_arc: PNML!GSPNArc (
				id<-'errors_notnode_transaction_T1_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_T1,
				type<-#normal,
				inscription <- transaction_T1_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per l'input dal place di gate1  
		transaction_T1_from_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_from_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_notnode_transaction_T1_from_gate1_place_arc',
				source <- errorsExpressionNode.ErrorsExpression,
				target <- transaction_T1,
				type<-#normal,
				inscription <- transaction_T1_from_gate1_place_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che per reintrodurre il place in gate1  
		transaction_T1_to_gate1_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_T1_to_gate1_place_arc: PNML!GSPNArc (
				id<-'errors_notnode_transaction_T1_to_gate1_place_arc',
				source <- transaction_T1,
				target <- errorsExpressionNode.ErrorsExpression,
				type<-#normal,
				inscription <- transaction_T1_to_gate1_place_arc_annotation,
				containerPage <- sistema
		)
	do {
		--NOTNODE
		thisModule.registerErrorPropagationManager(errorPropagation.PropagationLogicStringFormat, errorPropagation);
		thisModule.registerErrorPropagationLogic(errorPropagation.PropagationLogicStringFormat, thisModule.resolveTemp(errorPropagation.PropagationLogic, 'logicResult_place'));
	}
}
rule ErrorsExpressionErrorNodeToPN extends ErrorsExpressionNodeToPN {
	from
		errorsExpressionNode : IM2!ErrorsExpressionErrorNode
--		errorPropagation : IM2!ErrorPropagation
--		(
--			errorPropagation = errorsExpressionNode.errorPropagation
--		)
	to
		logicResult_place : PNML!Place(),
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di mettere uno ed un solo token quando si verifica l'errore
-------------------------------------------------------------------------------
-- Creo la transizione che preleva il token dal place che evidenzia il fault
		transaction_to_evidence : PNML!GSPNImmediateTransition (
--			id <- 'errors_error_transaction_to_evidence',
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che mette il token nel risultato di questa espressione logica 
		transaction_to_evidence_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_to_evidence_to_logic_result_arc: PNML!GSPNArc (
				source <- transaction_to_evidence,
				target <- logicResult_place,
				type<-#normal,
				inscription <- transaction_to_evidence_to_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che rimette il token nel place che evidenzia il fault 
		transaction_to_evidence_to_faulty_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_to_evidence_to_faulty_place_arc: PNML!GSPNArc (
	--			id<-'errors_error_transaction_to_evidence_to_faulty_place_arc',
				source <- transaction_to_evidence,
				target <- errorsExpressionNode.Error,
				type<-#normal,
				inscription <- transaction_to_evidence_to_faulty_place_arc_annotation,
				containerPage <- sistema
		),
-- (condizione necessaria) nel place dell'errore deve esserci almeno un token  
		transaction_to_evidence_from_faulty_place_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_to_evidence_from_faulty_place_arc: PNML!GSPNArc (
	--			id<-'errors_error_transaction_to_evidence_from_faulty_place_arc',
				source <- errorsExpressionNode.Error,
				target <- transaction_to_evidence,
				type<-#normal,
				inscription <- transaction_to_evidence_from_faulty_place_arc_annotation,
				containerPage <- sistema
		),
-- (condizione necessaria) nel place della valutazione logica non deve esserci nessun token  
		transaction_to_evidence_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_to_evidence_from_logic_result_arc: PNML!GSPNArc (
	--			id<-'errors_error_transaction_to_evidence_from_logic_result_arc',
				source <- logicResult_place,
				target <- transaction_to_evidence,
				type <- #inhibitor,
				inscription <- transaction_to_evidence_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-------------------------------------------------------------------------------
-- la transizione che seguono si occupano di rimuovere un token dalla logica quando l'errore scompare
-------------------------------------------------------------------------------
		transition_errornode_false : PNML!GSPNImmediateTransition (
			containerPage <- sistema			
		),
		transition_errornode_false_from_error_ins : PNML!PTArcAnnotation ( text <- 1 ),
		transition_errornode_false_from_error : PNML!GSPNArc (
	--		id <- 'errornode_false_from_error',
			source <- errorsExpressionNode.Error,
			target <- transition_errornode_false,
			type <- #inhibitor,
			inscription <- transition_errornode_false_from_error_ins,
			containerPage <- sistema
		),
		transition_errornode_false_from_result_ins : PNML!PTArcAnnotation ( text <- 1 ),
		transition_errornode_false_from_result : PNML!GSPNArc (
	--		id <- 'errornode_false_from_result',
			source <- logicResult_place,
			target <- transition_errornode_false,
			type <- #normal,
			inscription <- transition_errornode_false_from_result_ins,
			containerPage <- sistema
		)
--		transaction_remove_evidence : PNML!GSPNImmediateTransition (
--			Priority <- 2,
--			containerPage <- sistema
--		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
--		transaction_remove_evidence_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
--				text <- 1
--		),
--		transaction_remove_evidence_from_logic_result_arc: PNML!GSPNArc (
--				id<-'errors_error_transaction_remove_evidence_from_logic_result_arc',
--				source <- logicResult_place,
--				target <- transaction_remove_evidence,
--				type<-#normal,
--				inscription <- transaction_remove_evidence_from_logic_result_arc_annotation,
--				containerPage <- sistema
--		),
-- Creo l'arco inibitore che attiva permette di rimuovere il token dal risultato di questa espressione
-- logica se nn ci sono faults 
--		transaction_remove_evidence_from_faulty_place_arc_annotation : PNML!PTArcAnnotation (
--				text <- 1
--		),
--		transaction_remove_evidence_from_faulty_place_arc: PNML!GSPNArc (
--				id<-'errors_error_transaction_remove_evidence_from_faulty_place_arc',
--				source <- errorsExpressionNode.Error,
--				target <- transaction_to_evidence,
--				type <- #inhibitor,
--				inscription <- transaction_remove_evidence_from_faulty_place_arc_annotation,
--				containerPage <- sistema
--		)
		
	do {
		--ERRORNODE
		for(n in PNML!PnObject.allInstances()->select(i | i.id.oclIsUndefined())) {
			thisModule.myid <- thisModule.myid + 1;
			n.id <- 'ErrorsExpressionErrorNodeToPN_'+thisModule.myid.toString();
		}
		
		
		thisModule.registerErrorPropagationManager(errorPropagation.PropagationLogicStringFormat, errorPropagation);
		thisModule.registerErrorPropagationLogic(errorPropagation.PropagationLogicStringFormat, errorPropagation.PropagationLogic);
		

	}
}

abstract rule InternalPropagation {
	from
		internalPropagation : IM2!InternalPropagation
	using
	{
		componente : IM2!Component = internalPropagation.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
		internalPropagationResult_place : PNML!Place = thisModule.getErrorPropagationLogic(internalPropagation);
	}
	to
--------------------------------------------------------------------------------------------
-- in relazione alle figura faultGeneratesErrors_from_uml_to_idm
--------------------------------------------------------------------------------------------
-- Crea case per la generazione dell'errore
		propagation_case : PNML!GSPNImmediateTransition (
--			id <- 'internal_propagation_'+componente.Name+'_'+internalPropagation.Name+'_propagation',
			Priority <- 1,
			Weight <- internalPropagation.PropagationProbability,
			containerPage<-thisModule.getPage(sistema)
		),
		

-- place di comodo per abilitare o non abilitare la propagazione
		tmp_propagation_place_markup : PNML!PTMarking (
				text <- 0
		),
		tmp_propagation_place_name : PNML!Name (
				text <- 'tmp_propagation_'+componente.Name+'_internalPropagation_'+internalPropagation.Name
		),
		tmp_propagation_place : PNML!Place (
--				id <- 'tmp_propagation_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
				name <- tmp_propagation_place_name,
				initialMarking <- tmp_propagation_place_markup,
				containerPage <- sistema
		),
		
-- Creo l'arco che aggiunge un token in tmp_propagation e abilita la scelta tra propagare e non propagare l'errore 
		from_propagationdelay_to_tmp_propagation_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		from_propagationdelay_to_tmp_propagation_arc: PNML!GSPNArc (
--			id <- 'internalPropagation_from_propagationdelay_to_tmp_propagation_arc_annotation_'+componente.Name+'_'+internalPropagation.Name,
			source <- internalPropagation.PropagationDelay,
			target <- tmp_propagation_place,
			type<-#normal,
			inscription <- from_propagationdelay_to_tmp_propagation_arc_annotation,
			containerPage <- sistema
		),
		
-- Creo l'arco che rimuove il token da tmp_propagation e esegue la propagazione 
		from_tmp_propagation_to_propagate_case_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		from_tmp_propagation_to_propagate_case_arc: PNML!GSPNArc (
	--		id <- 'internalPropagation_from_tmp_propagation_to_propagate_case_arc_'+componente.Name+'_'+internalPropagation.Name,
			source <- tmp_propagation_place,
			target <- propagation_case,
			type<-#normal,
			inscription <- from_tmp_propagation_to_propagate_case_arc_annotation,
			containerPage <- sistema
		),
		
-- Creo l'arco che rimuove il token da tmp_propagation e non esegue la propagazione 
		from_tmp_propagation_to_not_propagate_case_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		from_tmp_propagation_to_not_propagate_case_arc: PNML!GSPNArc (
--			id <- 'internalPropagation_from_tmp_propagation_to_not_propagate_case_arc_'+componente.Name+'_'+internalPropagation.Name,
			source <- tmp_propagation_place,
			target <- not_propagation_case,
			type<-#normal,
			inscription <- from_tmp_propagation_to_not_propagate_case_arc_annotation,
			containerPage <- sistema
		),
		
		not_propagation_case : PNML!GSPNImmediateTransition (
--			id <- 'internal_propagation_'+componente.Name+'_'+internalPropagation.Name+'_not_propagation',
			Priority <- 1,
			Weight <- 1-internalPropagation.PropagationProbability,
			containerPage<-thisModule.getPage(sistema)
		),
		
-- place per l'attivazione della generazione dell'errore
		errorsActivation_place_markup : PNML!PTMarking (
				text <- 0
		),
		errorsActivation_place_name : PNML!Name (
				text <- 'errorsActivation_'+componente.Name+'_internalPropagation_'+internalPropagation.Name
		),
		errorsActivation_place : PNML!Place (
--				id <- 'errorsActivation_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
				name <- errorsActivation_place_name,
				initialMarking <- errorsActivation_place_markup,
				containerPage <- sistema
		),
-- la transizione che, nel caso di pi� errori possono essere attivati dalla stessa logica di propagazione,
-- consente di scegliere quale errore viene generato
		transaction_weight : PNML!GSPNImmediateTransition (
			Priority <- 2,
			Weight <- internalPropagation.Weight,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_weight_from_internal_propagation_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_weight_from_internal_propagation_logic_result_arc: PNML!GSPNArc (
	--			id<-'internal_propagation_transiction_weight_from_logic_result_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
				source <- internalPropagationResult_place,
				target <- transaction_weight,
				type<-#normal,
				inscription <- transaction_weight_from_internal_propagation_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che rimette  il token nel risultato di questa espressione logica 
		transaction_weight_to_internal_propagation_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_weight_to_internal_propagation_logic_result_arc: PNML!GSPNArc (
--				id<-'internal_propagation_transiction_weight_to_logic_result_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
				source <- transaction_weight,
				target <- internalPropagationResult_place,
				type<-#normal,
				inscription <- transaction_weight_to_internal_propagation_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che mette il token nel place che permette l'attivazione (cmq ancora non sicura) degli errori
		transaction_weight_to_errorsActivation_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_weight_to_errorsActivation_arc: PNML!GSPNArc (
--				id<-'internal_propagation_transiction_weight_to_errors_activation_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
				source <- transaction_weight,
				target <- errorsActivation_place,
				type<-#normal,
				inscription <- transaction_weight_to_errorsActivation_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione temporizzata per l'attivazione dell'errore
		transaction_activationDelay_from_errorsActivation_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_activationDelay_from_errorsActivation: PNML!GSPNArc (
--				id<-'internal_propagation_transiction_weight_from_errors_activation_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
				source <- errorsActivation_place,
				target <- internalPropagation.PropagationDelay,
				type<-#normal,
				inscription <- transaction_activationDelay_from_errorsActivation_arc_annotation,
				containerPage <- sistema
		)
	do {
		for(n in PNML!PnObject.allInstances()->select(i | i.id.oclIsUndefined())) {
			thisModule.myid <- thisModule.myid + 1;
			n.id <- 'InternalPropagation_'+thisModule.myid.toString();
		}
	}
}
rule InternalPropagationNoManager extends InternalPropagation {
	from
		internalPropagation : IM2!InternalPropagation
		(
			not thisModule.errorPropagationManager(internalPropagation.PropagationLogicStringFormat).isOclUndefined() and
			not (thisModule.errorPropagationManager(internalPropagation.PropagationLogicStringFormat)=internalPropagation)
		)
	to
		propagation_case : PNML!GSPNImmediateTransition (),
-----------------------------------------------------------------------------------
-- Creo l'arco che attiva la propagazione solo se c'e' un token nel place active_place
-----------------------------------------------------------------------------------
		transaction_weight_from_active_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_weight_from_active_arc: PNML!GSPNArc (
				source <- thisModule.resolveTemp(thisModule.errorPropagationManager(internalPropagation.PropagationLogicStringFormat), 'active_place'),
				target <- transaction_weight,
				type<-#normal,
				inscription <- transaction_weight_from_active_arc_annotation,
				containerPage <- sistema
		)
}
rule InternalPropagationManager extends InternalPropagation {
	from
		internalPropagation : IM2!InternalPropagation
		(
			thisModule.errorPropagationManager(internalPropagation.PropagationLogicStringFormat).isOclUndefined() or
			thisModule.errorPropagationManager(internalPropagation.PropagationLogicStringFormat)=internalPropagation
		)
	to
		propagation_case : PNML!GSPNImmediateTransition (),
--------------------------------------------------------------------------------------------
-- La regola crea i place e le trasformazioni che consentono di attivare una sola volta la propagazione dai fault all'errore.
-- Quando il risultato della logica di propagazione viene annullato � permessa la generazione di un nuovo errore
-- in relazione alle figura multiple_propagation_logic
--------------------------------------------------------------------------------------------
-- nel place active la presenza di un token attiva le transizioni per scegliere quale propagazione
-- deve avvenire
		active_place_markup : PNML!PTMarking (
				text <- 0
		),
		active_place_name : PNML!Name (
				text <- 'internal_propagation_active_'+componente.Name+'_internalPropagation_'+internalPropagation.Name
		),
		active_place : PNML!Place (
				id <- 'internal_propagation_active_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
				name <- active_place_name,
				initialMarking <- active_place_markup,
				containerPage <- sistema
		),
-- questo place � utilizzato a supporto per memorizzare il fatto che il token nel 
-- place d'attivazione della propagazione � gi� stato messo
		activated_place_markup : PNML!PTMarking (
				text <- 0
		),
		activated_place_name : PNML!Name (
				text <- 'internal_propagation_activated_'+componente.Name+'_internalPropagation_'+internalPropagation.Name
		),
		activated_place : PNML!Place (
				id <- 'internal_propagation_activated_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
				name <- activated_place_name,
				initialMarking <- activated_place_markup,
				containerPage <- sistema
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione � verificata aggiunge un token in activated e active
-----------------------------------------------------------------------------------------
		transaction_t0 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- thisModule.getPage(sistema)
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione � verificata
		transaction_t0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_from_logic_result_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_t0_from_logic_result_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- internalPropagationResult_place,
			target <- transaction_t0,
			type<-#normal,
			inscription <- transaction_t0_from_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimette il token nel risultato della propagazione logica quando la transizione
-- che notifica l'attivazione scatta
		transaction_t0_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_to_logic_result_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_t0_to_logic_result_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- transaction_t0,
			target <- internalPropagationResult_place,
			type<-#normal,
			inscription <- transaction_t0_to_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che impedisce di rimettere il token in active dopo che la propagazione � avvenuta
		transaction_t0_from_activated_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_from_activated_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_t0_from_activated_arc_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- activated_place,
			target <- transaction_t0,
			type <- #inhibitor,
			inscription <- transaction_t0_from_activated_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che memorizza l'avvenuta attivazione della propagazione
		transaction_t0_to_activated_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_to_activated_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_t0_to_activated_arc_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- transaction_t0,
			target <- activated_place,
			type<-#normal,
			inscription <- transaction_t0_to_activated_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco attivazione la propagazione
		transaction_t0_to_active_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_to_active_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_t0_to_active_arc_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- transaction_t0,
			target <- active_place,
			type<-#normal,
			inscription <- transaction_t0_to_active_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione non � verificata rimuove un token (se presente) da
-- activated
-----------------------------------------------------------------------------------------
		transaction_t1 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione NON � verificata
		transaction_t1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t1_from_logic_result_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_t1_from_logic_result_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- internalPropagationResult_place,
			target <- transaction_t1,
			type <- #inhibitor,
			inscription <- transaction_t1_from_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token da activated (se presente)
		transaction_t1_from_activated_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t1_from_activated_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_r1-from_activated_arc_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- activated_place,
			target <- transaction_t1,
			type<-#normal,
			inscription <- transaction_t1_from_activated_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione non � verificata rimuove un token (se presente) da
-- active
-----------------------------------------------------------------------------------------
		transaction_t2 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione NON � verificata
		transaction_t2_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t2_from_logic_result_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_t2_from_logic_result_arc_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- internalPropagationResult_place,
			target <- transaction_t2,
			type <- #inhibitor,
			inscription <- transaction_t2_from_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token da activated (se presente)
		transaction_t2_from_active_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t2_from_active_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_t2_from_active_arc_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- active_place,
			target <- transaction_t2,
			type<-#normal,
			inscription <- transaction_t2_from_active_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------
-- Creo l'arco che attiva la propagazione solo se c'e' un token nel place active_place
-----------------------------------------------------------------------------------
		transaction_weight_from_active_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_weight_from_active_arc: PNML!GSPNArc (
			id<-'internal_propagation_transiction_weight_from_active_'+componente.Name+'_internalPropagation_'+internalPropagation.Name,
			source <- active_place,
			target <- transaction_weight,
			type<-#normal,
			inscription <- transaction_weight_from_active_arc_annotation,
			containerPage <- sistema
		)
}
rule InternalPropagationPropagate {
	from
		internalPropagation : IM2!InternalPropagation,
		Error : IM2!Error
		(
				internalPropagation.destination.includes(Error)
		)
		
	using
	{
		componente : IM2!Component = internalPropagation.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
	}
	to
-- Creo l'arco che mette un token nel place associato all'errore
		propagation_to_error_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		propagation_to_error_arc: PNML!GSPNArc (
				source<-internalPropagation,
				target<-Error,
				type<-#normal,
				inscription<-propagation_to_error_arc_annotation,
				containerPage<-thisModule.getPage(sistema)
		)
}


abstract rule ErrorsProducesFailures {
	from
		errorsProducesFailures : IM2!ErrorsProducesFailures
	using
	{
		componente : IM2!Component = errorsProducesFailures.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
		errorPropagationResult_place : PNML!Place = thisModule.getErrorPropagationLogic(errorsProducesFailures);
	}
	to
--------------------------------------------------------------------------------------------
-- in relazione alle figura faultGeneratesErrors_from_uml_to_idm
--------------------------------------------------------------------------------------------

-- Crea case per la generazione dell'errore
		propagation_case : PNML!GSPNImmediateTransition (
--			id <- 'errors_produces_failures_'+componente.Name+'_'+errorsProducesFailures.Name+'_propagation',
			Priority <- 1,
			Weight <- errorsProducesFailures.PropagationProbability,
			containerPage<-sistema
		),
		
-- place per l'attivazione della generazione del fallimento
		tmp_propagation_place_markup : PNML!PTMarking (
				text <- 0
		),
		tmp_propagation_place_name : PNML!Name (
				text <- 'tmp_propagation_'+componente.Name+'_errors_produces_failures_'+errorsProducesFailures.Name
		),
		tmp_propagation_place : PNML!Place (
--				id <- 'tmp_propagation_'+componente.Name+'_errors_produces_failures_'+errorsProducesFailures.Name,
				name <- tmp_propagation_place_name,
				initialMarking <- tmp_propagation_place_markup,
				containerPage <- sistema
		),

-- Creo l'arco che aggiunge un token in tmp_propagation e che permette di eseguire la generazione del fault o di
-- eseguire la "non generare"
		from_propagationdelay_to_tmp_propagation_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		from_propagationdelay_to_tmp_propagation_arc: PNML!GSPNArc (
--				id<-'errors_produces_failures_'+componente.Name+'_'+errorsProducesFailures.Name+'_from_propagationdelay_to_tmp_propagation_arc',
				source <- errorsProducesFailures.PropagationDelay,
				target <- tmp_propagation_place,
				type<-#normal,
				inscription <- from_propagationdelay_to_tmp_propagation_arc_annotation,
				containerPage <- sistema
		),
		
-- Creo l'arco che rimuove il token eseguendo la gnerazione del fault 
		from_tmp_propagation_to_propagate_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		from_tmp_propagation_to_propagate_arc: PNML!GSPNArc (
--				id<-'errors_produces_failures_'+componente.Name+'_'+errorsProducesFailures.Name+'_from_tmp_propagation_to_propagate_arc',
				source <- tmp_propagation_place,
				target <- propagation_case,
				type<-#normal,
				inscription <- from_tmp_propagation_to_propagate_arc_annotation,
				containerPage <- sistema
		),

-- Creo l'arco che rimuove il token eseguendo la "non generazione del fault" 
		from_tmp_propagation_to_not_propagate_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		from_tmp_propagation_to_not_propagate_arc: PNML!GSPNArc (
--				id<-'errors_produces_failures_from_tmp_propagation_to_not_propagate_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
				source <- tmp_propagation_place,
				target <- not_propagation_case,
				type<-#normal,
				inscription <- from_tmp_propagation_to_not_propagate_arc_annotation,
				containerPage <- sistema
		),
		
-- Crea case per la generazione dell'errore
		not_propagation_case : PNML!GSPNImmediateTransition (
--			id<-'errors_produces_failures_not_propagation_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			Priority <- 1,
			Weight <- 1-errorsProducesFailures.PropagationProbability,
			containerPage<-sistema
		),
		
-- place per l'attivazione della generazione del fallimento
		errorsActivation_place_markup : PNML!PTMarking (
				text <- 0
		),
		errorsActivation_place_name : PNML!Name (
				text <- 'errorsActivation_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name
		),
		errorsActivation_place : PNML!Place (
--				id <- 'errorsActivation_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
				name <- errorsActivation_place_name,
				initialMarking <- errorsActivation_place_markup,
				containerPage <- sistema
		),
-- la transizione che, nel caso di pi� errori possono essere attivati dalla stessa logica di propagazione,
-- consente di scegliere quale errore viene generato
		transaction_weight : PNML!GSPNImmediateTransition (
			Priority <- 2,
			Weight <- errorsProducesFailures.Weight,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token nel risultato di questa espressione logica 
		transaction_weight_from_error_propagation_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_weight_from_error_propagation_logic_result_arc: PNML!GSPNArc (
--			id<-'errors_produces_failures_transition_weight_from_error_logic_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- errorPropagationResult_place,
			target <- transaction_weight,
			type<-#normal,
			inscription <- transaction_weight_from_error_propagation_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimette il token nel risultato di questa espressione logica 
		transaction_weight_to_error_propagation_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_weight_to_error_propagation_logic_result_arc: PNML!GSPNArc (
--			id<-'errors_produces_failures_transition_weight_to_error_logic_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- transaction_weight,
			target <- errorPropagationResult_place,
			type<-#normal,
			inscription <- transaction_weight_to_error_propagation_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che mette il token nel place che permette l'attivazione (cmq ancora non sicura) degli errori
		transaction_weight_to_errorsActivation_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_weight_to_errorsActivation_arc: PNML!GSPNArc (
--			id<-'errors_produces_failures_transition_weight_to_errors_activation_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- transaction_weight,
			target <- errorsActivation_place,
			type<-#normal,
			inscription <- transaction_weight_to_errorsActivation_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione temporizzata per l'attivazione dell'errore
		transaction_activationDelay_from_errorsActivation_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_activationDelay_from_errorsActivation: PNML!GSPNArc (
--			id<-'errors_produces_failures_transition_activationDelay_from_errorsActivation_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- errorsActivation_place,
			target <- errorsProducesFailures.PropagationDelay,
			type<-#normal,
			inscription <- transaction_activationDelay_from_errorsActivation_arc_annotation,
			containerPage <- sistema
		)
	do {
		for(n in PNML!PnObject.allInstances()->select(i | i.id.oclIsUndefined())) {
			thisModule.myid <- thisModule.myid + 1;
			n.id <- 'ErrorsProduceFailures_'+thisModule.myid.toString();
		}
	}
}
rule ErrorsProducesFailuresNoManager extends ErrorsProducesFailures {
	from
		errorsProducesFailures : IM2!ErrorsProducesFailures
		(
			(thisModule.errorPropagationManager.get(errorsProducesFailures.PropagationLogicStringFormat)<>OclUndefined) and
			(thisModule.errorPropagationManager.get(errorsProducesFailures.PropagationLogicStringFormat)<>errorsProducesFailures)
		)
	to
		propagation_case : PNML!GSPNImmediateTransition (),
-----------------------------------------------------------------------------------
-- Creo l'arco che attiva la propagazione solo se c'e' un token nel place active_place
-----------------------------------------------------------------------------------
		transaction_weight_from_active_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_weight_from_active_arc: PNML!GSPNArc (
--				id<-'ErrorsProducesFailuresNoManager_transaction_weight_from_active_arc',
				source <- thisModule.resolveTemp(thisModule.errorPropagationManager(errorsProducesFailures.PropagationLogicStringFormat), 'active_place'),
				target <- transaction_weight,
				type<-#normal,
				inscription <- transaction_weight_from_active_arc_annotation,
				containerPage <- sistema
		)
}
rule ErrorsProducesFailuresManager extends ErrorsProducesFailures {
	from
		errorsProducesFailures : IM2!ErrorsProducesFailures
		(
			(thisModule.errorPropagationManager.get(errorsProducesFailures.PropagationLogicStringFormat)=OclUndefined) or
			(thisModule.errorPropagationManager.get(errorsProducesFailures.PropagationLogicStringFormat)=errorsProducesFailures)
		)
	to
		propagation_case : PNML!GSPNImmediateTransition (),
--------------------------------------------------------------------------------------------
-- La regola crea i place e le trasformazioni che consentono di attivare una sola volta la propagazione dai fault all'errore.
-- Quando il risultato della logica di propagazione viene annullato � permessa la generazione di un nuovo errore
-- in relazione alle figura multiple_propagation_logic
--------------------------------------------------------------------------------------------
-- nel place active la presenza di un token attiva le transizioni per scegliere quale propagazione
-- deve avvenire
		active_place_markup : PNML!PTMarking (
				text <- 0
		),
		active_place_name : PNML!Name (
				text <- 'active_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name
		),
		active_place : PNML!Place (
--				id <- 'active_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
				name <- active_place_name,
				initialMarking <- active_place_markup,
				containerPage <- sistema
		),
-- questo place � utilizzato a supporto per memorizzare il fatto che il token nel 
-- place d'attivazione della propagazione � gi� stato messo
		activated_place_markup : PNML!PTMarking (
				text <- 0
		),
		activated_place_name : PNML!Name (
				text <- 'activated_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name
		),
		activated_place : PNML!Place (
--				id <- 'activated_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
				name <- activated_place_name,
				initialMarking <- activated_place_markup,
				containerPage <- sistema
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione � verificata aggiunge un token in activated e active
-----------------------------------------------------------------------------------------
		transaction_t0 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione � verificata
		transaction_t0_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		transaction_t0_from_logic_result_arc: PNML!GSPNArc (
				source <- errorPropagationResult_place,
				target <- transaction_t0,
				type<-#normal,
				inscription <- transaction_t0_from_logic_result_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che rimette il token nel risultato della propagazione logica quando la transizione
-- che notifica l'attivazione scatta
		transaction_t0_to_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_to_logic_result_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_t0_to_error_logic_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- transaction_t0,
			target <- errorPropagationResult_place,
			type<-#normal,
			inscription <- transaction_t0_to_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che impedisce di rimettere il token in active dopo che la propagazione � avvenuta
		transaction_t0_from_activated_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_from_activated_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_t0_from_activated_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- activated_place,
			target <- transaction_t0,
			type <- #inhibitor,
			inscription <- transaction_t0_from_activated_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che memorizza l'avvenuta attivazione della propagazione
		transaction_t0_to_activated_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_to_activated_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_t0_to_activated_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- transaction_t0,
			target <- activated_place,
			type<-#normal,
			inscription <- transaction_t0_to_activated_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco attivazione la propagazione
		transaction_t0_to_active_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t0_to_active_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_t0_to_activate_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- transaction_t0,
			target <- active_place,
			type<-#normal,
			inscription <- transaction_t0_to_active_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione non � verificata rimuove un token (se presente) da
-- activated
-----------------------------------------------------------------------------------------
		transaction_t1 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- thisModule.getPage(sistema)
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione NON � verificata
		transaction_t1_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t1_from_logic_result_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_t1_from_logic_result_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- errorPropagationResult_place,
			target <- transaction_t1,
			type <- #inhibitor,
			inscription <- transaction_t1_from_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token da activated (se presente)
		transaction_t1_from_activated_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t1_from_activated_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_t1_from_activated_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- activated_place,
			target <- transaction_t1,
			type<-#normal,
			inscription <- transaction_t1_from_activated_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------------
-- quando la logica di propagazione non � verificata rimuove un token (se presente) da
-- active
-----------------------------------------------------------------------------------------
		transaction_t2 : PNML!GSPNImmediateTransition (
			Priority <- 2,
			containerPage <- sistema
		),
-- Creo l'arco che abilita la transizione se la logica di propagazione NON � verificata
		transaction_t2_from_logic_result_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t2_from_logic_result_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_t2_from_logic_result_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- errorPropagationResult_place,
			target <- transaction_t2,
			type <- #inhibitor,
			inscription <- transaction_t2_from_logic_result_arc_annotation,
			containerPage <- sistema
		),
-- Creo l'arco che rimuove il token da activated (se presente)
		transaction_t2_from_active_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_t2_from_active_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_t2_from_active_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- active_place,
			target <- transaction_t2,
			type<-#normal,
			inscription <- transaction_t2_from_active_arc_annotation,
			containerPage <- sistema
		),
-----------------------------------------------------------------------------------
-- Creo l'arco che attiva la propagazione solo se c'e' un token nel place active_place
-----------------------------------------------------------------------------------
		transaction_weight_from_active_arc_annotation : PNML!PTArcAnnotation (
			text <- 1
		),
		transaction_weight_from_active_arc: PNML!GSPNArc (
			id<-'errors_produces_failures_transition_weight_from_active_arc_'+componente.Name+'_errorsProducesFailures_'+errorsProducesFailures.Name,
			source <- active_place,
			target <- transaction_weight,
			type<-#normal,
			inscription <- transaction_weight_from_active_arc_annotation,
			containerPage <- sistema
		)
}
rule ErrorsProducesFailuresPropagate {
	from
		errorsProducesFailures : IM2!ErrorsProducesFailures,
		failureMode : IM2!FailureMode
		(
				errorsProducesFailures.Destination.includes(failureMode)
		)
		
	using
	{
		componente : IM2!Component = errorsProducesFailures.Component;
		sistema : IM2!Sistema = componente.intermediateModel;
	}
	to
-- Creo l'arco che mette un token nel place associato al modo di fallimento
		propagation_to_failure_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		propagation_to_failure_arc: PNML!GSPNArc (
				id<-'ErrorsProducesFailuresPropagate_propagation_to_failure_arc',
				source <- errorsProducesFailures,
				target <- failureMode,
				type<-#normal,
				inscription <- propagation_to_failure_arc_annotation,
				containerPage <- sistema
		),
-- Creo l'arco che mette un token nel place che indica il fallimento della componente
		propagation_to_failed_arc_annotation : PNML!PTArcAnnotation (
				text <- 1
		),
		propagation_to_failed_arc: PNML!GSPNArc (
				id<-'ErrorsProducesFailuresPropagate_propagation_to_failed_arc',
				source <- errorsProducesFailures,
				target <- componente,
				type<-#normal,
				inscription <- propagation_to_failed_arc_annotation,
				containerPage <- sistema
		)
	do {
		thisModule.myid <- thisModule.myid + 1;
		
		propagation_to_failure_arc.id <- propagation_to_failure_arc.id + thisModule.myid.toString();
		propagation_to_failed_arc.id <- propagation_to_failed_arc.id + thisModule.myid.toString();
	}
}




-- crea le sotto reti che si occupano di rimuovere tutti i token da un place quando il componente ha subito un fallimento
lazy rule removeTokenOnFailed {
	from
		componente : IM2!Component,
		place : PNML!Place,
		name : String,
		failed_place : GPSN!Place
	using {
		sistema : IM2!Sistema = componente.intermediateModel;
	}
	to
-- Creo la transizione che rimuove i token da faulty_place
		transaction_remove_token_from_faulty_place : PNML!GSPNImmediateTransition (
			id <- 'remove_tokens_on_failing_component_'+componente.Name+'_FROM_'+place.id,
			Priority <- 2,
			containerPage <- componente.intermediateModel
		),
-- Creo l'arco entrante che rimuove un token alla volta da faulty_place
		transaction_remove_token_from_faulty_place_from_faulty_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_remove_token_from_faulty_place_from_faulty_place_arc: PNML!GSPNArc (
				id<-'remove_token_from_'+place.id+'_'+componente.Name+'_'+name,
				source<-place,
				target<-transaction_remove_token_from_faulty_place,
				type<-#normal,
				inscription<-transaction_remove_token_from_faulty_place_from_faulty_place_arc_annotation,
				containerPage<-sistema
		),
-- Creo l'arco che abilita il reset dello del place faulty_place
		transaction_remove_token_from_faulty_place_from_failed_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_remove_token_from_faulty_place_from_failed_place_arc: PNML!GSPNArc (
				id<-'remove_token_from_'+place.id+'_'+componente.Name+'_'+name+'_from_failed_place',
				source<-failed_place,
				target<-transaction_remove_token_from_faulty_place,
				type<-#normal,
				inscription<-transaction_remove_token_from_faulty_place_from_failed_place_arc_annotation,
				containerPage<-sistema
		),
-- Creo l'arco che rimette il token in failed_place dopo aver tolto un token da faulty-place
		transaction_remove_token_from_faulty_place_to_failed_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_remove_token_from_faulty_place_to_failed_place_arc: PNML!GSPNArc (
				id<-'remove_token_from_'+place.id+'_'+componente.Name+'_'+name+'_to_failed_place',
				source<-transaction_remove_token_from_faulty_place,
				target<-failed_place,
				type<-#normal,
				inscription<-transaction_remove_token_from_faulty_place_to_failed_place_arc_annotation,
				containerPage<-sistema
		)
}

lazy rule executeActiviyIfComponentNotFailed {
	from
		activity : IM2!Activity
		(
			activity.Component<>OclUndefined
		)
	to 
		transaction_T0_from_failed_place_arc_annotation : PNML!PTArcAnnotation (
				text<-1
		),
		transaction_T0_from_failed_place_arc: PNML!GSPNArc (
				source <- activity.Component,
				target <- activity.When,
				type <- #inhibitor,
				inscription <- transaction_T0_from_failed_place_arc_annotation,
				containerPage <- activity.Component.intermediateModel
		)
}


rule InstantOfTime {
	from
		idm_instant : IM2!InstantOfTime
	to
		evaltype : PNML!InstantOfTime 
		(
			instant <- thisModule.newVariableExpression(PNML!Variable.allInstances()->select(v | v.name = 'Time').first())
		)
}
rule IntervalOfTime {
	from
		idm_interval : IM2!IntervalOfTime
	to
		evaltype : PNML!IntervalOfTimeCumulated
		(
			intervalBegin <- thisModule.newValueExpression(idm_interval.begin),
			intervalEnd <- thisModule.newVariableExpression(PNML!Variable.allInstances()->select(v | v.name = 'Time').first())
		)
}
rule MeasureToRewardFunction {
	from 
		idm_measure : IM2!DependabilityMeasure
	using {
		mexp : OrderedSet(PNML!MarkingExpression) = OrderedSet{};
		tmp : PNML!OpSum = OclUndefined; 
	}
	to
		measure : PNML!Measure
		(
			name <- idm_measure.Name,
			evaluationType <- idm_measure.evaluations.asSequence().first(),
			rewardFunction <- ite
		),
		ite : PNML!IfThenElse
		(
			condition <- cond,
			ifTrue <- thisModule.newValueExpression(1),
			ifFalse <- thisModule.newValueExpression(0)
		),
		cond : PNML!OpEqual
		(
			expression2 <- thisModule.newValueExpression(0)
			
		)
	do {
		if(idm_measure.target->size() = 1)
		{
			cond.expression1 <- thisModule.newMarkingExpression(idm_measure.target.asSequence().first());
		}
		else
		{
		--	cond.expression1 <- thisModule.newOpSum();
			for(i in idm_measure.target) {
				mexp = mexp->including(thisModule.newMarkingExpression(i));
			}
			tmp <- thisModule.newOpSum(mexp->at(1),mexp->at(2));
			cond.expression1 <- tmp;
			--cond.expression1 <- thisModule.newOpSum(thisModule.newMarkingExpression(idm_measure.target.asSequence().first()), OclUndefined);
			--tmp = cond.expression1;
			--TODO
		}
	}
}

lazy rule newVariableExpression {
	from 
		var : PNML!Variable
	to
		vexp : PNML!VariableExpression
		(
			variable <- var
		)
}
lazy rule newValueExpression {
	from
		v : Real
	to
		vexpr : PNML!ValueExpression ( value <- v )
}
lazy rule newMarkingExpression {
	from 
		f : IM2!FailureMode
	to
		m : PNML!MarkingExpression
		(
			place <- thisModule.resolveTemp(f, 'failureMode_place')
		)
}
rule newOpSum( e1 : PNML!ArithmeticExpression, e2 : PNML!ArithmeticExpression) { 
--rule newOpSum() {
	to
		sum : PNML!OpSum
		(
			expression1 <- e1,
			expression2 <- e2
		)
}