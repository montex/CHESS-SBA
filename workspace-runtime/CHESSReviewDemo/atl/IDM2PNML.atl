-- @path IDM=/CHESSReviewDemo/metamodels/IM2.ecore
-- @path PNML=/CHESSReviewDemo/metamodels/placeTransition.ecore

module IDM2PNML;
create OUT : PNML from IN : IDM;

helper def: trCount : Integer = 1;
helper def: placeCount : Integer = 1;
helper def: arcCount : Integer = 1;
helper def: otherCount : Integer = 1;
helper def: timePoints : OrderedSet(Real) = OrderedSet{};

helper def: priTransientDuration : Integer = 4;
helper def: priPropagation : Integer = 5;
helper def: priPropagationChoice : Integer = 7;
helper def: priReset : Integer = 6;
helper def: priActivity : Integer = 2;
helper def: priActivitySchedule : Integer = 1;
helper def: priActivityOutcome : Integer = 3;
helper def: priReliability : Integer = 8;

helper def: getPage : PNML!Page = IDM!Sistema.allInstances()->first();

helper def: tmpLogicExp : PNML!LogicalExpression = OclUndefined;

helper context IDM!NamedElement def: toString() : String = self.Name;
helper context IDM!Error def: toString() : String = self.Name;
helper context IDM!FailureMode def: toString() : String = self.Name;

helper context PNML!Place def: toString() : String = self.id;
helper context PNML!Transition def: toString() : String = self.id;

rule Sistema {
	from
		s : IDM!Sistema
	to
		pp: PNML!Page (
			id <- s.Name,
			objects <- Sequence{}
		),
		net: PNML!PetriNet (
			id <-  s.Name,
			pages <- Sequence{pp},
			type <- #GSPN
		),
		doc: PNML!PetriNetDoc (
			nets <- Sequence{net}
		),
		
		var : PNML!Variable (
			name <- 'Time'
		),
		varvals : PNML!VariableValues (
			variable <- var,
			values <- OrderedSet{}
		),
		study: PNML!Study (
			name <- 'DefaultStudy',
			vars <- Sequence{varvals}
		),
		evalList: PNML!EvaluationList (
			studies <- Sequence{study},
			measures <- PNML!Measure.allInstances()
		)
	do {
		for(i in IDM!InstantOfTime.allInstances()) {
			varvals.values <- varvals.values.append(i.timePoint);
		}
		for(i in IDM!IntervalOfTime.allInstances()) {
			varvals.values <- varvals.values.append(i.end);
		}
	}
}

-- Crea la transizione di reset per ciascun componente
rule Component {
	from
		c : IDM!Component
	to
		doreset : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- c.Name + '_doreset',
			initialMarking <- thisModule.newPTMarking(0)
		),
		reset : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- c.Name + '_reset',
			Priority <- thisModule.priReset,
			Weight <- 1
		),
		arcreset : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- c.Name + '_arcreset',
			source <- doreset,
			target <- reset
		)
	do {
		for(f in c.Faults) {
			if(f.oclIsTypeOf(IDM!InternalFault)) {
				thisModule.newInputArcMultiplicityOfPlace(f, reset);
			}
		}
		for(e in c.Errors) {
			thisModule.newInputArcMultiplicityOfPlace(e, reset);
		}
		for(fm in c.FailureModes) {
			thisModule.newInputArcMultiplicityOfPlace(fm, reset);
		}
	}
}

-- Crea le distribuzioni
rule Exponential { from e : IDM!Exponential to ee : PNML!Exponential ( Rate <- e.Rate ) }
rule Deterministic { from d : IDM!Deterministic to dd : PNML!Deterministic ( Value <- d.Value ) }
rule Uniform { from u : IDM!Uniform to uu : PNML!Uniform ( Lower <- u.Lower, Upper <- u.Upper ) }
rule Gaussian { from g : IDM!Gaussian to gg : PNML!Gaussian ( Mean <- g.Mean, Variance <- g.Variance ) }
rule Gamma { from g : IDM!Gamma to gg : PNML!Gamma ( Alpha <- g.Alpha, Beta <- g.Beta ) }
rule Weibull { from w : IDM!Weibull to ww : PNML!Weibull ( Alpha <- w.Alpha, Beta <- w.Beta ) }

-- Regole per InternalFault
abstract rule InternalFault {
	from 
		ft : IDM!InternalFault
	to
		--Place
		faulty : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0),
			id <- ft.Name
		),
		transient : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0),
			id <- ft.Name + '_transient'	
		),
		tmpfaulty : PNML!Place (
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0),
			id <- ft.Name + '_tmp'			
		),
		
		e1 : PNML!OpEqual ( expression1 <- e2, expression2 <- e3 ),
		e2 : PNML!MarkingExpression ( place <- faulty ),
		e3 : PNML!ValueExpression ( value <- 0 ),
		
		--Transizioni (quelle per FO e TD vengono create dalle regole che estendono questa)
		casepermanent : PNML!GSPNImmediateTransition (
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_caseperm',
			Priority <- thisModule.priPropagationChoice,
			Weight <- ft.PermanentProbability
		),
		casetransient : PNML!GSPNImmediateTransition (
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_casetrans',
			Priority <- thisModule.priPropagationChoice,
			Weight <- (1 - ft.PermanentProbability)
		),		
		
		--Archi
		totmp : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			target <- tmpfaulty,
			id <- ft.Name + '_totmp'
		),
			--Permanent Fault
		tmp_to_permcase : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- tmpfaulty,
			target <- casepermanent,
			id <- ft.Name + '_tmp_to_permcase'	
		),
		permcase_to_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casepermanent,
			target <- faulty,
			id <- ft.Name + '_permcase_to_faulty'
		),
			--Transient Fault
		tmp_to_transcase : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- tmpfaulty,
			target <- casetransient,
			id <- ft.Name + '_tmp_to_transcase'	
		),
		transcase_to_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casetransient,
			target <- faulty,
			id <- ft.Name + '_transcase_to_faulty'				
		),
		transcase_to_transient : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- casetransient,
			target <- transient,
			id <- ft.Name + '_transcase_to_transient'				
		),
		removetrans_trans : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- transient,
			id <- ft.Name + '_removetrans_trans'
		),
		removetrans_faulty : PNML!GSPNArc (
			containerPage <- thisModule.getPage,
			source <- faulty,
			id <- ft.Name + '_removetrans_faulty'
		)		
	do {
		thisModule.makeUniqueID(faulty);
		thisModule.makeUniqueID(transient);
		thisModule.makeUniqueID(tmpfaulty);
		
		thisModule.makeUniqueID(casepermanent);
		thisModule.makeUniqueID(casetransient);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(tmp_to_permcase);
		thisModule.makeUniqueID(permcase_to_faulty);
		thisModule.makeUniqueID(tmp_to_transcase);
		thisModule.makeUniqueID(transcase_to_faulty);
		thisModule.makeUniqueID(transcase_to_transient);
		thisModule.makeUniqueID(removetrans_trans);
		thisModule.makeUniqueID(removetrans_faulty);
	}
}
rule InternalFaultTT extends InternalFault { --FO timed, TD timed
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occurrence.Value > 0 and ft.TransientDuration.Value > 0
				else
					ft.Occurrence.Value > 0
				endif
			else
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.TransientDuration.Value > 0
				else
					true
				endif
			endif
		)
	to
		faulty : PNML!Place,
		tmpfaulty : PNML!Place,
		e1 : PNML!OpEqual ( expression1 <- e2, expression2 <- e3 ),
		fo : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.Occurrence,
			id <- ft.Name + '_FO',
			Guard <- e1
		),
		td : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.TransientDuration,
			id <- ft.Name + '_TD'
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultII extends InternalFault { --FO immediate, TD immediate
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) and ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
				ft.Occurrence.Value = 0 and ft.TransientDuration.Value = 0
			else
				false
			endif
		)
	to
		faulty : PNML!Place,
		tmpfaulty : PNML!Place,
		fo : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_FO',
			Priority <- thisModule.priPropagation,
			Weight <- 1,
			Guard <- e1
		),
		td : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_TD',
			Priority <- thisModule.priTransientDuration,
			Weight <- 1
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultTI extends InternalFault { --FO timed, TD immediate
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occcurence.Value > 0 and ft.TransientDuration.Value = 0
				else
					false
				endif
			else
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.TransientDuration.Value = 0
				else
					false
				endif
			endif
		)
	to
		faulty : PNML!Place,
		tmpfaulty : PNML!Place,
		e1 : PNML!OpEqual ( expression1 <- e2, expression2 <- e3 ),
		fo : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.Occurrence,
			id <- ft.Name + '_FO',
			Guard <- e1
		),
		td : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_TD',
			Priority <- thisModule.priTransientDuration,
			Weight <- 1
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}
rule InternalFaultIT extends InternalFault { --FO immediate, TD timed
	from 
		ft : IDM!InternalFault
		(
			if ft.Occurrence.oclIsTypeOf(IDM!Deterministic) then
				if ft.TransientDuration.oclIsTypeOf(IDM!Deterministic) then
					ft.Occurrence.Value = 0 and ft.TransientDuration.Value > 0
				else
					ft.Occurrence.Value = 0
				endif
			else
				false
			endif
		)
	to
		faulty : PNML!Place,
		tmpfaulty : PNML!Place,
		e1 : PNML!OpEqual ( expression1 <- e2, expression2 <- e3 ),
		fo : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- ft.Name + '_FO',
			Priority <- thisModule.priPropagation,
			Weight <- 1,
			Guard <- e1
		),
		td : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			Distribution <- ft.TransientDuration,
			id <- ft.Name + '_TD'
		),
		totmp : PNML!GSPNArc ( source <- fo ),
		removetrans_trans : PNML!GSPNArc ( target <- td ),
		removetrans_faulty : PNML!GSPNArc ( target <- td )
}

rule Error { --manca l'implementazione di VanishingTime 
	from 
		e : IDM!Error
	to
		err : PNML!Place (
			id <- e.Name,
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0)
		),
		detected : PNML!Place (
			id <- e.Name + '_detected',
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0)
		)
	do {
		thisModule.makeUniqueID(err);
		thisModule.makeUniqueID(detected);
	}
}
rule ErrorVanishImmediate extends Error {
	from
		e : IDM!Error
		(
			if e.VanishingTime.oclIsUndefined() then
				false
			else
				if e.VanishingTime.oclIsTypeOf(IDM!Deterministic) then
					e.VanishingTime.Value = 0
				else
					false
				endif
			endif
		)
	to
		err : PNML!Place,
		detected : PNML!Place,
		vanish : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- e.Name + '_vanish',
			Priority <- thisModule.priTransientDuration,
			Weight <- 1
		),
		tovanish : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- e.Name + '_to_vanish',
			source <- err,
			target <- vanish
		)
	do {
		thisModule.makeUniqueID(err);
		thisModule.makeUniqueID(detected);
		thisModule.makeUniqueID(vanish);
		thisModule.makeUniqueID(tovanish);
	}		
}
rule ErrorVanishTimed extends Error {
	from
		e : IDM!Error
		(
			if e.VanishingTime.oclIsUndefined() then
				false
			else
				if e.VanishingTime.oclIsTypeOf(IDM!Deterministic) then
					e.VanishingTime.Value > 0
				else
					true
				endif
			endif
		)
	to
		err : PNML!Place,
		detected : PNML!Place,
		vanish : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			id <- e.Name + '_vanish',
			Distribution <- e.VanishingTime
		),
		tovanish : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- e.Name + '_to_vanish',
			source <- err,
			target <- vanish
		)
	do {
		thisModule.makeUniqueID(err);
		thisModule.makeUniqueID(detected);
		thisModule.makeUniqueID(vanish);
		thisModule.makeUniqueID(tovanish);
	}		
}

rule FailureMode {
	from
		fm : IDM!FailureMode
	to
		fmode : PNML!Place (
			id <- fm.Name,
			containerPage <- thisModule.getPage,
			initialMarking <- thisModule.newPTMarking(0)			
		)
	do {
		thisModule.makeUniqueID(fmode);
	}
}

--FaultsExpression elements
rule FaultsExpressionFaultNode {
	from
		n : IDM!FaultsExpressionFaultNode
	to
		nn : PNML!OpGreater ( expression1 <- e1, expression2 <- e2 ),
		e1 : PNML!MarkingExpression (
			place <- 
			if n.Fault.oclIsTypeOf(IDM!InternalFault) then
				n.Fault
			else
				n.Fault.Source
			endif
		),
		e2 : PNML!ValueExpression ( value <- 0 )
}
rule FaultsExpressionNotNode {
	from
		n : IDM!FaultsExpressionNotNode
	to
		nn : PNML!OpNot ( expression <- n.FaultsExpression )
}
rule FaultsExpressionAndNode {
	from
		n : IDM!FaultsExpressionAndNode
	to
		nn : PNML!OpAnd ( e1 <- n.FaultsExpression1, e2 <- n.FaultsExpression2 )
}
rule FaultsExpressionOrNode {
	from
		n : IDM!FaultsExpressionOrNode
	to
		nn : PNML!OpOr ( e1 <- n.FaultsExpression1, e2 <- n.FaultsExpression2 )
}

--ErrorsExpression elements
rule ErrorsExpressionFaultNode {
	from
		n : IDM!ErrorsExpressionErrorNode
	to
		nn : PNML!OpGreater ( expression1 <- e1, expression2 <- e2 ),
		e1 : PNML!MarkingExpression
		(
			place <- n.Error
		),
		e2 : PNML!ValueExpression ( value <- 0 )
}
rule ErrorsExpressionNotNode {
	from
		n : IDM!ErrorsExpressionNotNode
	to
		nn : PNML!OpNot ( expression <- n.ErrorsExpression )
}
rule ErrorsExpressionAndNode {
	from
		n : IDM!ErrorsExpressionAndNode
	to
		nn : PNML!OpAnd ( e1 <- n.ErrorsExpression1, e2 <- n.ErrorsExpression2 )
}
rule ErrorsExpressionOrNode {
	from
		n : IDM!ErrorsExpressionOrNode
	to
		nn : PNML!OpOr ( e1 <- n.ErrorsExpression1, e2 <- n.ErrorsExpression2 )
}

--FaultsGenerateErrors
abstract rule FGE {
	from
		fge : IDM!FaultsGenerateErrors
	to
		andop : PNML!OpAnd
		(
			expression1 <- fge.PropagationLogic
		),		
		tmp : PNML!Place
		(
			id <- fge.Name + '_tmp',
			initialMarking <- thisModule.newPTMarking(0),
			containerPage <- thisModule.getPage
		),
		casepropagate : PNML!GSPNImmediateTransition
		(
			id <- fge.Name + '_caseprop',
			Weight <- fge.PropagationProbability,
			Priority <- thisModule.priPropagationChoice,
			containerPage <- thisModule.getPage
		),
		caseskip : PNML!GSPNImmediateTransition
		(
			id <- fge.Name + '_caseskip',
			Weight <- ( 1 - fge.PropagationProbability ),
			Priority <- thisModule.priPropagationChoice,
			containerPage <- thisModule.getPage
		),
		--Archi
		totmp : PNML!GSPNArc
		(
			id <- fge.Name + '_totmp',
--			source <- trfge,
			target <- tmp,
			containerPage <- thisModule.getPage
		),
		topropagate : PNML!GSPNArc
		(
			id <- fge.Name + '_toprop',
			containerPage <- thisModule.getPage,
			source <- tmp,
			target <- casepropagate
		),
		toskip : PNML!GSPNArc
		(
			id <- fge.Name + '_toskip',
			containerPage <- thisModule.getPage,
			source <- tmp,
			target <- caseskip
		)
}
rule FGETimed extends FGE {
	from
		fge : IDM!FaultsGenerateErrors
		(
			if fge.ActivationDelay.oclIsTypeOf(IDM!Deterministic) then
				fge.ActivationDelay.Value > 0
			else
				true
			endif
		)
	to
		trfge : PNML!GSPNTimedTransition
		(
			id <- fge.Name,
			Distribution <- fge.ActivationDelay,
			containerPage <- thisModule.getPage,
			Guard <- andop
		),
		andop : PNML!OpAnd,
		totmp : PNML!GSPNArc
		(
			source <- trfge
		)
	do {
		thisModule.makeUniqueID(trfge);
		thisModule.makeUniqueID(tmp);
		thisModule.makeUniqueID(casepropagate);
		thisModule.makeUniqueID(caseskip);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(topropagate);
		thisModule.makeUniqueID(toskip);
		
		thisModule.tmpLogicExp <- andop;

		for(e in fge.Destination.subSequence(2, fge.Destination.size())) {
			thisModule.tmpLogicExp.expression2 <- thisModule.newOpOr( 
				thisModule.newOpEqual(
					thisModule.newMarkingExpression(e),
					thisModule.newValueExpression(0)
				),
				OclUndefined
			);
			thisModule.newOutputArc(casepropagate, e);
			thisModule.tmpLogicExp <- thisModule.tmpLogicExp.expression2;
		}
		
		thisModule.tmpLogicExp.expression2 <- thisModule.newOpEqual(
			thisModule.newMarkingExpression(fge.Destination.first()),
			thisModule.newValueExpression(0)
		);
		thisModule.newOutputArc(casepropagate, fge.Destination.first());
		thisModule.tmpLogicExp <- thisModule.tmpLogicExp.expression2;
	}
}
rule FGEImmediate extends FGE {
	from
		fge : IDM!FaultsGenerateErrors
		(
			if fge.ActivationDelay.oclIsTypeOf(IDM!Deterministic) then
				fge.ActivationDelay.Value = 0
			else
				false
			endif
		)
	to
		trfge : PNML!GSPNImmediateTransition
		(
			id <- fge.Name,
			containerPage <- thisModule.getPage,
			Weight <- fge.Weight,
			Priority <- thisModule.priPropagation,
			Guard <- andop
		),
		andop : PNML!OpAnd,
		totmp : PNML!GSPNArc
		(
			source <- trfge
		)
	do {
		thisModule.makeUniqueID(trfge);
		thisModule.makeUniqueID(tmp);
		thisModule.makeUniqueID(casepropagate);
		thisModule.makeUniqueID(caseskip);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(topropagate);
		thisModule.makeUniqueID(toskip);
		
		thisModule.tmpLogicExp <- andop;

		for(e in fge.Destination.subSequence(2, fge.Destination.size())) {
			thisModule.tmpLogicExp.expression2 <- thisModule.newOpOr( 
				thisModule.newOpEqual(
					thisModule.newMarkingExpression(e),
					thisModule.newValueExpression(0)
				),
				OclUndefined
			);
			thisModule.newOutputArc(casepropagate, e);
			thisModule.tmpLogicExp <- thisModule.tmpLogicExp.expression2;
		}
		
		thisModule.tmpLogicExp.expression2 <- thisModule.newOpEqual(
			thisModule.newMarkingExpression(fge.Destination.first()),
			thisModule.newValueExpression(0)
		);
		thisModule.newOutputArc(casepropagate, fge.Destination.first());
		thisModule.tmpLogicExp <- thisModule.tmpLogicExp.expression2;
	}
}

--ErrorsProduceFailures
abstract rule EPF {
	from
		epf : IDM!ErrorsProducesFailures
	to
		andop : PNML!OpAnd
		(
			expression1 <- epf.PropagationLogic
		),		
		tmp : PNML!Place
		(
			id <- epf.Name + '_tmp',
			initialMarking <- thisModule.newPTMarking(0),
			containerPage <- thisModule.getPage
		),
		casepropagate : PNML!GSPNImmediateTransition
		(
			id <- epf.Name + '_caseprop',
			Weight <- epf.PropagationProbability,
			Priority <- thisModule.priPropagationChoice,
			containerPage <- thisModule.getPage
		),
		caseskip : PNML!GSPNImmediateTransition
		(
			id <- epf.Name + '_caseskip',
			Weight <- ( 1 - epf.PropagationProbability ),
			Priority <- thisModule.priPropagationChoice,
			containerPage <- thisModule.getPage
		),
		--Archi
		totmp : PNML!GSPNArc
		(
			id <- epf.Name + '_totmp',
--			source <- trfge,
			target <- tmp,
			containerPage <- thisModule.getPage
		),
		topropagate : PNML!GSPNArc
		(
			id <- epf.Name + '_toprop',
			containerPage <- thisModule.getPage,
			source <- tmp,
			target <- casepropagate
		),
		toskip : PNML!GSPNArc
		(
			id <- epf.Name + '_toskip',
			containerPage <- thisModule.getPage,
			source <- tmp,
			target <- caseskip
		)
}
rule EPFTimed extends EPF {
	from
		epf : IDM!ErrorsProducesFailures
		(
			if epf.PropagationDelay.oclIsTypeOf(IDM!Deterministic) then
				epf.PropagationDelay.Value > 0
			else
				true
			endif
		)
	to
		trepf : PNML!GSPNTimedTransition
		(
			id <- epf.Name,
			Distribution <- epf.PropagationDelay,
			containerPage <- thisModule.getPage,
			Guard <- andop
		),
		andop : PNML!OpAnd,
		totmp : PNML!GSPNArc
		(
			source <- trepf
		)
	do {
		thisModule.makeUniqueID(trepf);
		thisModule.makeUniqueID(tmp);
		thisModule.makeUniqueID(casepropagate);
		thisModule.makeUniqueID(caseskip);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(topropagate);
		thisModule.makeUniqueID(toskip);
		
		thisModule.tmpLogicExp <- andop;

		for(fm in epf.Destination.subSequence(2, epf.Destination.size())) {
			thisModule.tmpLogicExp.expression2 <- thisModule.newOpOr( 
				thisModule.newOpEqual(
					thisModule.newMarkingExpression(fm),
					thisModule.newValueExpression(0)
				),
				OclUndefined
			);
			thisModule.newOutputArc(casepropagate, fm);
			thisModule.tmpLogicExp <- thisModule.tmpLogicExp.expression2;
		}
		
		thisModule.tmpLogicExp.expression2 <- thisModule.newOpEqual(
			thisModule.newMarkingExpression(epf.Destination.first()),
			thisModule.newValueExpression(0)
		);
		thisModule.newOutputArc(casepropagate, epf.Destination.first());
		thisModule.tmpLogicExp <- thisModule.tmpLogicExp.expression2;
	}
}
rule EPFImmediate extends EPF {
	from
		epf : IDM!ErrorsProducesFailures
		(
			if epf.PropagationDelay.oclIsTypeOf(IDM!Deterministic) then
				epf.PropagationDelay.Value = 0
			else
				false
			endif
		)
	to
		trepf : PNML!GSPNImmediateTransition
		(
			id <- epf.Name,
			containerPage <- thisModule.getPage,
			Weight <- epf.Weight,
			Priority <- thisModule.priPropagation,
			Guard <- andop
		),
		andop : PNML!OpAnd,
		totmp : PNML!GSPNArc
		(
			source <- trepf
		)
	do {
		thisModule.makeUniqueID(trepf);
		thisModule.makeUniqueID(tmp);
		thisModule.makeUniqueID(casepropagate);
		thisModule.makeUniqueID(caseskip);
		
		thisModule.makeUniqueID(totmp);
		thisModule.makeUniqueID(topropagate);
		thisModule.makeUniqueID(toskip);
		
		thisModule.tmpLogicExp <- andop;

		for(fm in epf.Destination.subSequence(2, epf.Destination.size())) {
			thisModule.tmpLogicExp.expression2 <- thisModule.newOpOr( 
				thisModule.newOpEqual(
					thisModule.newMarkingExpression(fm),
					thisModule.newValueExpression(0)
				),
				OclUndefined
			);
			thisModule.newOutputArc(casepropagate, fm);
			thisModule.tmpLogicExp <- thisModule.tmpLogicExp.expression2;
		}
		
		thisModule.tmpLogicExp.expression2 <- thisModule.newOpEqual(
			thisModule.newMarkingExpression(epf.Destination.first()),
			thisModule.newValueExpression(0)
		);
		thisModule.newOutputArc(casepropagate, epf.Destination.first());
		thisModule.tmpLogicExp <- thisModule.tmpLogicExp.expression2;
	}
}

--Crea un ID unico per Place, sTransizioni e Archi, aggiungendo un numero progressivo all'ID attuale
rule makeUniqueID(obj : PNML!PnObject) {
	do {
		if(obj.oclIsKindOf(PNML!Transition)) {
			obj.id <- 'T' + thisModule.trCount.toString() + '_' + obj.id;
			thisModule.trCount <- thisModule.trCount + 1;
		}
		else if(obj.oclIsKindOf(PNML!Place)) {
			obj.id <- 'P' + thisModule.placeCount.toString() + '_' + obj.id;
			thisModule.placeCount <- thisModule.placeCount + 1;
		}
		else if(obj.oclIsKindOf(PNML!Arc)) {
			obj.id <- 'A' + thisModule.arcCount.toString() + '_' + obj.id;
			thisModule.arcCount <- thisModule.arcCount + 1;
		}
		else {
			obj.id <- 'O' + thisModule.otherCount.toString() + '_' + obj.id;
			thisModule.otherCount <- thisModule.otherCount + 1;
		}		
	}
}

-- ScheduleExpression nodes
	-- T
rule ScheduleExpImmediately {
	from
		se : IDM!ScheduleExpressionImmediately
	using {
		act : IDM!Activity = IDM!Activity.allInstances()->select(i | i.When.T = se).first();
	}
	to
		tr : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T',
			Weight <- 1,
			Priority <- thisModule.priActivitySchedule,
			Guard <- g_and
		),
		arc : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T_oarc',
			source <- tr,
			target <- act
		),
		g_and : PNML!OpAnd
		(
			expression1 <- act.When.EX,
			expression2 <- g_eq
		),
		g_eq : PNML!OpEqual
		(
			expression1 <- g_mexp,
			expression2 <- thisModule.newValueExpression(0)
		),
		g_mexp : PNML!MarkingExpression
		(
			place <- act
		)
}
rule ScheduleExpAtTime {
	from 
		se : IDM!ScheduleExpressionAtTime
	using {
		act : IDM!Activity = IDM!Activity.allInstances()->select(i | i.When.T = se).first();
	}
	to
		tr : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T',
			Distribution <- delay
		),
		arc : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T_oarc',
			source <- tr,
			target <- act
		),
		delay : PNML!Deterministic ( Value <- se.t ),
		wait : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T_wait',
			initialMarking <- thisModule.newPTMarking(1)
		),
		fromwait : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T_fromwait',
			source <- wait,
			target <- tr
		)
}
rule ScheduleExpPeriodic {
	from
		se : IDM!ScheduleExpressionPeriodic
	using {
		act : IDM!Activity = IDM!Activity.allInstances()->select(i | i.When.T = se).first();
	}
	to
		tr : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T',
			Distribution <- se.PeriodDuration
		),
		arc : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T_oarc',
			source <- tr,
			target <- act
		),
		wait : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T_wait',
			initialMarking <- thisModule.newPTMarking(1)
		),
		fromwait : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T_fromwait',
			source <- wait,
			target <- tr
		),
		looptowait : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_schedule_T_looptowait',
			source <- tr,
			target <- wait				
		)
}
	-- EX
rule ScheduleExpTrue {
	from
		se : IDM!ScheduleExpressionTrue
	to
		tt : PNML!OpTrue
}
rule ScheduleExpNot {
	from
		se : IDM!ScheduleExpressionNot
	to
		notexp : PNML!OpNot
		(
			expression <- se.e
		)
}
rule ScheduleExpOr {
	from
		se : IDM!ScheduleExpressionOr
	to
		orexp : PNML!OpOr
		(
			expression1 <- se.e1,
			expression2 <- se.e2
		)
}
rule ScheduleExpAnd {
	from
		se : IDM!ScheduleExpressionAnd
	to
		orexp : PNML!OpAnd
		(
			expression1 <- se.e1,
			expression2 <- se.e2
		)	
}
rule ScheduleExpFailed {
	from 
		se : IDM!ScheduleExpressionFailed
	to
	 	gthan : PNML!OpGreater
		(
			expression1 <- mexp,
			expression2 <- thisModule.newValueExpression(0)
		),
		mexp : PNML!MarkingExpression
		(
			place <- se.failureMode
		)
}
rule ScheduleExpErrorDetected {
	from
		se : IDM!ScheduleExpressionErrorDetected
	to
	 	gthan : PNML!OpGreater
		(
			expression1 <- mexp,
			expression2 <- thisModule.newValueExpression(0)
		),
		mexp : PNML!MarkingExpression
		(
			place <- thisModule.resolveTemp(se.error, 'detected')
		)
}
	-- L
rule ScheduleExpBefore {
	from 
		se : IDM!ScheduleExpressionBefore
	using {
		act : IDM!Activity = IDM!Activity.allInstances()->select(i | i.When.L = se).first();
	}
	to
		limit : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L',
			initialMarking <- thisModule.newPTMarking(0)
		),
		fireonce : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_fireonce',
			initialMarking <- thisModule.newPTMarking(0)
		),	
		elapse : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_elapse',
			Distribution <- delay
		),
		delay : PNML!Deterministic ( Value <- se.t ),
		from_fireonce : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- fireonce.id + '_to_' + elapse.id,
			source <- fireonce,
			target <- elapse
		),
		to_limit : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- elapse.id + '_to_' + limit.id,
			source <- elapse,
			target <- limit				
		),
		inhibit : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_inhibit',
			source <- limit,
			target <- act.When.T,
			type <- #inhibitor
		)
}
rule ScheduleExpAfter {
	from 
		se : IDM!ScheduleExpressionAfter
	using {
		act : IDM!Activity = IDM!Activity.allInstances()->select(i | i.When.L = se).first();
	}
	to
		limit : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L',
			initialMarking <- thisModule.newPTMarking(0)
		),
		elapse : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_elapse',
			Distribution <- delay
		),
		delay : PNML!Deterministic ( Value <- se.t ),
		from_limit : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- limit.id + '_to_' + elapse.id,
			source <- limit,
			target <- elapse				
		),
		inhibit : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_inhibit',
			source <- limit,
			target <- act.When.T,
			type <- #inhibitor
		)
}
rule ScheduleExpInterval {
	from 
		se : IDM!ScheduleExpressionInterval
	using {
		act : IDM!Activity = IDM!Activity.allInstances()->select(i | i.When.L = se).first();
	}
	to
		limit : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L',
			initialMarking <- thisModule.newPTMarking(0)
		),
		elapse_t1 : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_elapse_t1',
			Distribution <- delay_t1
		),
		delay_t1 : PNML!Deterministic ( Value <- se.t1 ),
		
		elapse_t2 : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_elapse_t2',
			Distribution <- delay_t2
		),
		delay_t2 : PNML!Deterministic ( Value <- se.t2 ),
		
		ininterval : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_ininterval',
			initialMarking <- thisModule.newPTMarking(0)
		),
		
		from_limit : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- limit.id + '_to_' + elapse_t1.id,
			source <- limit,
			target <- elapse_t1
		),
		enterinterval : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- elapse_t1.id + '_to_' + ininterval.id,
			source <- elapse_t1,
			target <- ininterval
		),
		exitinterval : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- ininterval.id + '_to_' + elapse_t2.id,
			source <- ininterval,
			target <- elapse_t2
		),
		to_limit : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- elapse_t2.id + '_to_' + limit.id,
			source <- elapse_t2,
			target <- limit			
		),
		inhibit : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_L_inhibit',
			source <- limit,
			target <- act.When.T,
			type <- #inhibitor
		)
}

--Activities
abstract rule Activity {
	from
		act : IDM!Activity
	to
		enabled : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_enabled',
			initialMarking <- thisModule.newPTMarking(0)
		),
		completed : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_completed',
			initialMarking <- thisModule.newPTMarking(0) 	
		),
		tr_success : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_outcome_success',
			Priority <- thisModule.priActivityOutcome
		),
		tr_failed : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_outcome_failed',
			Priority <- thisModule.priActivityOutcome
		),
		tosuccess : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			source <- completed,
			target <- tr_success,
			id <- completed.id + '_to_' + tr_success.id
		),
		tofailed : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			source <- completed,
			target <- tr_failed,
			id <- completed.id + '_to_' + tr_failed.id
		)
}
	--Repair
rule RepairTimed extends Activity {
	from
		act : IDM!RepairActivity
		(
			if act.Duration.oclIsTypeOf(IDM!Deterministic) then
				act.Duration.Value > 0
			else
				true
			endif
		)
	to
		enabled : PNML!Place,
		completed : PNML!Place,
		tr_rep : PNML!GSPNTimedTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name,
			Distribution <- act.Duration
		),
		enabledtotr : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_enabled_to' + enabled.id,
			source <- enabled,
			target <- tr_rep
		),
		trtocompleted : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			source <- tr_rep,
			target <- completed,
			id <- tr_rep.id + '_to_' + completed.id
		),
		tr_success : PNML!GSPNImmediateTransition ( Weight <- act.SuccessProbability ),
		tr_failed : PNML!GSPNImmediateTransition ( Weight <- (1-act.SuccessProbability) )
	do { 
		for( c in act.Target ) {
			thisModule.newOutputArc(tr_success, c);
		}
	}
}
rule RepairImmediate extends Activity {
	from
		act : IDM!RepairActivity
		(
			if act.Duration.oclIsTypeOf(IDM!Deterministic) then
				act.Duration.Value = 0
			else
				false
			endif
		)
	to
		enabled : PNML!Place,
		completed : PNML!Place,
		tr_rep : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- act.Name,
			Weight <- 1,
			Priority <- thisModule.priActivity
		),
		enabledtotr : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			id <- act.Name + '_enabled_to' + enabled.id,
			source <- enabled,
			target <- tr_rep
		),
		trtocompleted : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			source <- tr_rep,
			target <- completed,
			id <- tr_rep.id + '_to_' + completed.id
		),
		tr_success : PNML!GSPNImmediateTransition ( Weight <- act.SuccessProbability ),
		tr_failed : PNML!GSPNImmediateTransition ( Weight <- (1-act.SuccessProbability) )
	do { 
		for( c in act.Target ) {
			thisModule.newOutputArc(tr_success, c);
		}
	}
}

--Evaluation types
rule InstantOfTime {
	from
		idm_instant : IDM!InstantOfTime
	to
		evaltype : PNML!InstantOfTime 
		(
			instant <- thisModule.newVariableExpression(PNML!Variable.allInstances()->select(v | v.name = 'Time').first())
		)
}
rule IntervalOfTime {
	from
		idm_interval : IDM!IntervalOfTime
	to
		evaltype : PNML!IntervalOfTime
		(
			intervalBegin <- thisModule.newValueExpression(idm_interval.begin),
			intervalEnd <- thisModule.newVariableExpression(PNML!Variable.allInstances()->select(v | v.name = 'Time').first())
		)
}
rule IntervalOfTimeAveraged {
	from
		idm_interval : IDM!IntervalOfTimeAveraged
	to
		evaltype : PNML!IntervalOfTimeAveraged
		(
			intervalBegin <- thisModule.newValueExpression(idm_interval.begin),
			intervalEnd <- thisModule.newVariableExpression(PNML!Variable.allInstances()->select(v | v.name = 'Time').first())
		)
}

--Measures of interest
abstract rule MeasureOfInterest {
	from
		idm_measure : IDM!DependabilityMeasure
	to
		measure : PNML!Measure
		(
			name <- idm_measure.Name,
			evaluationType <- idm_measure.evaluations.asSequence().first(),
			rewardFunction <- ite
		),
		ite : PNML!IfThenElse
		(
--			condition <- cond,
			ifTrue <- thisModule.newValueExpression(1),
			ifFalse <- thisModule.newValueExpression(0)
		)
}
rule Reliability extends MeasureOfInterest {
	from 
		idm_measure : IDM!Reliability
	to
		measure : PNML!Measure,
		ite : PNML!IfThenElse
		(
			condition <- cond	
		),
		cond : PNML!OpEqual
		(
			expression1 <- thisModule.newMarkingExpression(relplace),
			expression2 <- thisModule.newValueExpression(0)
		),
		relplace : PNML!Place
		(
			containerPage <- thisModule.getPage,
			id <- measure.name + '_memory_pl',
			initialMarking <- thisModule.newPTMarking(0)
		),
		reltrans : PNML!GSPNImmediateTransition
		(
			containerPage <- thisModule.getPage,
			id <- measure.name + '_memory_tr',
			Weight <- 1,
			Priority <- thisModule.priReliability
		),
		relarc : PNML!GSPNArc 
		(
			containerPage <- thisModule.getPage,
			id <- measure.name + '_memory_arc',
			source <- reltrans,
			target <- relplace
		),
		g_and : PNML!OpAnd
		(
--			expression1 <- g_first,
			expression2 <- g_rel
		),
		g_first : PNML!OpGreater
		(
			expression1 <- thisModule.newMarkingExpression(idm_measure.target.first()),
			expression2 <- thisModule.newValueExpression(0)				
		),
		g_rel : PNML!OpEqual
		(
			expression1 <- thisModule.newMarkingExpression(relplace),
			expression2 <- thisModule.newValueExpression(0)
		)
	do {
		thisModule.tmpLogicExp <- g_first;
		for(fm in idm_measure.target.excluding(idm_measure.target.first())) {
			thisModule.tmpLogicExp <- thisModule.newOpOr(
				thisModule.newOpGreater(
					thisModule.newMarkingExpression(fm),
					thisModule.newValueExpression(0)
				),
				thisModule.tmpLogicExp
			);
		}
		g_and.expression1 <- thisModule.tmpLogicExp;
		reltrans.Guard <- g_and;
	}
}
rule Availability extends MeasureOfInterest {
	from 
		idm_measure : IDM!Availability
	to
		measure : PNML!Measure,
		ite : PNML!IfThenElse,
		cond : PNML!OpEqual
		(
			expression1 <- thisModule.newMarkingExpression(idm_measure.target.first()),
			expression2 <- thisModule.newValueExpression(0)
		)
	do {
		thisModule.tmpLogicExp <- cond;
		for(fm in idm_measure.target.subSequence(2, idm_measure.target.size())) {
			thisModule.tmpLogicExp <- thisModule.newOpAnd(
				thisModule.newOpEqual(
					thisModule.newMarkingExpression(fm),
					thisModule.newValueExpression(0)
				),
				thisModule.tmpLogicExp
			);
		}
		ite.condition <- thisModule.tmpLogicExp;
	}
}

--Rules to generate expression nodes
lazy rule newVariableExpression {
	from 
		var : PNML!Variable
	to
		vexp : PNML!VariableExpression
		(
			variable <- var
		)
}
lazy rule newValueExpression {
	from
		v : Real
	to
		vexpr : PNML!ValueExpression ( value <- v )
}
rule newMarkingExpression( p : PNML!Place ) {
	to
		m : PNML!MarkingExpression
		(
			place <- p
		)
	do {
		m;
	}
}
rule newOpEqual ( e1 : PNML!ArithmeticExpression, e2 : PNML!ArithmeticExpression) {
	to
		eq : PNML!OpEqual
		(
			expression1 <- e1,
			expression2 <- e2
		)
	do {
		eq;
	}
}
rule newOpGreater ( e1 : PNML!ArithmeticExpression, e2 : PNML!ArithmeticExpression) {
	to
		eq : PNML!OpGreater
		(
			expression1 <- e1,
			expression2 <- e2
		)
	do {
		eq;
	}
}
rule newOpSum ( e1 : PNML!ArithmeticExpression, e2 : PNML!ArithmeticExpression) { 
	to
		sum : PNML!OpSum
		(
			expression1 <- e1,
			expression2 <- e2
		)
	do {
		sum;
	}
}
rule newOpAnd ( e1 : PNML!LogicalExpression, e2 : PNML!LogicalExpression) { 
	to
		opand : PNML!OpAnd
		(
			expression1 <- e1,
			expression2 <- e2
		)
	do { 
		opand;
	}
}
rule newOpOr ( e1 : PNML!LogicalExpression, e2 : PNML!LogicalExpression) { 
	to
		opor : PNML!OpOr
		( 
			expression1 <- e1,
			expression2 <- e2
		)
	do {
		opor;
	}
}

--Other rules
	--Creates a new output arc between a transition and a place
rule newOutputArc ( t : PNML!Transition, p : PNML!Place ) { 
	to
		arc : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			source <- t,
			target <- p,
			id <- t.toString() + '_to_' + p.toString()
		)
}
	--Creates a new input arc between a place and a transition
rule newInputArc ( p : PNML!Place, t : PNML!Transition ) {
	to 
		arc : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			source <- p,
			target <- t,
			id <- p.toString() + '_to_' + t.toString()
		)
}
	--Creates a new input arc between a place and a transition,
	--having as multiplicity the number of tokens in the place (i.e., MARK(p))
rule newInputArcMultiplicityOfPlace ( p : PNML!Place, t : PNML!Transition ) {
	to 
		arc : PNML!GSPNArc
		(
			containerPage <- thisModule.getPage,
			source <- p,
			target <- t,
			id <- p.toString() + '_to_' + t.toString(),
			MultiplicityFunction <- expmark
		),
	    expmark : PNML!MarkingExpression
		(
			place <- p	
		)
}
	--Creates a new "PTMarking" element from on an integer value
lazy rule newPTMarking {
	from
		v : Integer
	to
		m : PNML!PTMarking (
			text <- v
		)
}