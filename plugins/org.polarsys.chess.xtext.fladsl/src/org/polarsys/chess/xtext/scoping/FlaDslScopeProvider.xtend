/*
 * generated by Xtext
 */
 /*------------------------------------------------------------------------------
 -
 - Copyright (c) 2013, 2015 Intecs SpA 
 - All rights reserved. This program and the accompanying materials
 - are made available under the terms of the Eclipse Public License v1.0
 - which accompanies this distribution, and is available at
 - http://www.eclipse.org/legal/epl-v10.html
 -
 - Contributors:
 - 
 - Stefano Puri stefano.puri@intecs.it
 -  
 - Initial API and implementation and/or initial documentation
 ------------------------------------------------------------------------------*/
 
package org.polarsys.chess.xtext.scoping

import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.polarsys.chess.xtext.global.utils.XtextUtils
import org.eclipse.uml2.uml.Port
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.common.util.EList
import org.polarsys.chess.chessmlprofile.Dependability.FailurePropagation.FLABehavior;
import org.polarsys.chess.chessmlprofile.Dependability.FailurePropagation.FPTC;
import org.eclipse.uml2.uml.EncapsulatedClassifier

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class FlaDslScopeProvider extends AbstractDeclarativeScopeProvider {

	EncapsulatedClassifier contextComponent ;
	
	new(){
		val contextElement = XtextUtils.getContextElement;
  		if(contextElement instanceof FPTC){
			contextComponent = (contextElement as FPTC).getBase_Component();
		}else if(contextElement instanceof FLABehavior){
			if ((contextElement as FLABehavior).getBase_Class() != null) {
				contextComponent = (contextElement as FLABehavior).getBase_Class() as EncapsulatedClassifier;
			}
			else if ((contextElement as FLABehavior).getBase_InstanceSpecification != null) {
				contextComponent = (contextElement as FLABehavior).getBase_InstanceSpecification.classifiers.get(0) as EncapsulatedClassifier;
			}
		} 
	} 

/* 
	def IScope scope_InputExpression_ref(InputExpression inExpr, EReference ref){
		
		val ports = contextComponent.ownedPorts
		
		//ports.forEach[println((it as Port).qualifiedName)]
		
//		val scope = delegateGetScope(inExpr, ref)
//		
//		val filter = [IEObjectDescription descr | ports.contains(descr.EObjectOrProxy as Port)]
//		
//		new FilteringScope(scope, filter);
		
		return Scopes.scopeFor(ports)
	}*/
	
	override IScope getScope(EObject context, EReference reference){
	   val EList<Port> ports = this.contextComponent.getOwnedPorts();
	    return Scopes.scopeFor(ports);
  	}
  	
  
}
