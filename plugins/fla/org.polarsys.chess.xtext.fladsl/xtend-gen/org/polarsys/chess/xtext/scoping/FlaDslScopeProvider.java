/**
 * generated by Xtext
 */
package org.polarsys.chess.xtext.scoping;

import com.google.common.base.Objects;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.uml2.uml.Classifier;
import org.eclipse.uml2.uml.EncapsulatedClassifier;
import org.eclipse.uml2.uml.InstanceSpecification;
import org.eclipse.uml2.uml.Port;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.polarsys.chess.chessmlprofile.Dependability.FailurePropagation.FLABehavior;
import org.polarsys.chess.chessmlprofile.Dependability.FailurePropagation.FPTC;
import org.polarsys.chess.xtext.global.utils.XtextUtils;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class FlaDslScopeProvider extends AbstractDeclarativeScopeProvider {
  private EncapsulatedClassifier contextComponent;
  
  public FlaDslScopeProvider() {
    final Object contextElement = XtextUtils.getContextElement();
    if ((contextElement instanceof FPTC)) {
      this.contextComponent = ((FPTC) contextElement).getBase_Component();
    } else {
      if ((contextElement instanceof FLABehavior)) {
        org.eclipse.uml2.uml.Class _base_Class = ((FLABehavior) contextElement).getBase_Class();
        boolean _notEquals = (!Objects.equal(_base_Class, null));
        if (_notEquals) {
          org.eclipse.uml2.uml.Class _base_Class_1 = ((FLABehavior) contextElement).getBase_Class();
          this.contextComponent = ((EncapsulatedClassifier) _base_Class_1);
        } else {
          InstanceSpecification _base_InstanceSpecification = ((FLABehavior) contextElement).getBase_InstanceSpecification();
          boolean _notEquals_1 = (!Objects.equal(_base_InstanceSpecification, null));
          if (_notEquals_1) {
            Classifier _get = ((FLABehavior) contextElement).getBase_InstanceSpecification().getClassifiers().get(0);
            this.contextComponent = ((EncapsulatedClassifier) _get);
          }
        }
      }
    }
  }
  
  /**
   * def IScope scope_InputExpression_ref(InputExpression inExpr, EReference ref){
   * 
   * val ports = contextComponent.ownedPorts
   * 
   * //ports.forEach[println((it as Port).qualifiedName)]
   * 
   * //		val scope = delegateGetScope(inExpr, ref)
   * //
   * //		val filter = [IEObjectDescription descr | ports.contains(descr.EObjectOrProxy as Port)]
   * //
   * //		new FilteringScope(scope, filter);
   * 
   * return Scopes.scopeFor(ports)
   * }
   */
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    final EList<Port> ports = this.contextComponent.getOwnedPorts();
    return Scopes.scopeFor(ports);
  }
}
